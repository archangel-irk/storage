
### lib/binary.js
[
  {
    "tags": [
      {
        "type": "class",
        "string": "Represents the Binary BSON type."
      },
      {
        "type": "param",
        "types": [
          "Buffer"
        ],
        "name": "buffer",
        "description": "a buffer object containing the binary data.",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "Number"
        ],
        "name": "[subType]",
        "description": "the option binary type.",
        "optional": true
      },
      {
        "type": "return",
        "types": [
          "Grid"
        ],
        "description": ""
      }
    ],
    "description": {
      "full": "<p>A class representation of the BSON Binary type.</p><p>Sub types</p><ul>\n<li><strong>BSON.BSON_BINARY_SUBTYPE_DEFAULT</strong>, default BSON type.</li>\n<li><strong>BSON.BSON_BINARY_SUBTYPE_FUNCTION</strong>, BSON function type.</li>\n<li><strong>BSON.BSON_BINARY_SUBTYPE_BYTE_ARRAY</strong>, BSON byte array type.</li>\n<li><strong>BSON.BSON_BINARY_SUBTYPE_UUID</strong>, BSON uuid type.</li>\n<li><strong>BSON.BSON_BINARY_SUBTYPE_MD5</strong>, BSON md5 type.</li>\n<li><strong>BSON.BSON_BINARY_SUBTYPE_USER_DEFINED</strong>, BSON user defined type.</li>\n</ul>\n",
      "summary": "<p>A class representation of the BSON Binary type.</p>",
      "body": "<p>Sub types</p><ul>\n<li><strong>BSON.BSON_BINARY_SUBTYPE_DEFAULT</strong>, default BSON type.</li>\n<li><strong>BSON.BSON_BINARY_SUBTYPE_FUNCTION</strong>, BSON function type.</li>\n<li><strong>BSON.BSON_BINARY_SUBTYPE_BYTE_ARRAY</strong>, BSON byte array type.</li>\n<li><strong>BSON.BSON_BINARY_SUBTYPE_UUID</strong>, BSON uuid type.</li>\n<li><strong>BSON.BSON_BINARY_SUBTYPE_MD5</strong>, BSON md5 type.</li>\n<li><strong>BSON.BSON_BINARY_SUBTYPE_USER_DEFINED</strong>, BSON user defined type.</li>\n</ul>\n"
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 1,
    "codeStart": 17,
    "code": "function Binary(buffer, subType) {\n  if(!(this instanceof Binary)) return new Binary(buffer, subType);\n\n  this._bsontype = 'Binary';\n\n  if(buffer instanceof Number) {\n    this.sub_type = buffer;\n    this.position = 0;\n  } else {\n    this.sub_type = subType == null ? BSON_BINARY_SUBTYPE_DEFAULT : subType;\n    this.position = 0;\n  }\n\n  if(buffer != null && !(buffer instanceof Number)) {\n    // Only accept Buffer, Uint8Array or Arrays\n    if(typeof buffer == 'string') {\n      // Different ways of writing the length of the string for the different types\n      if(typeof Buffer != 'undefined') {\n        this.buffer = new Buffer(buffer);\n      } else if(typeof Uint8Array != 'undefined' || (Object.prototype.toString.call(buffer) == '[object Array]')) {\n        this.buffer = writeStringToArray(buffer);\n      } else {\n        throw new Error(\"only String, Buffer, Uint8Array or Array accepted\");\n      }\n    } else {\n      this.buffer = buffer;\n    }\n    this.position = buffer.length;\n  } else {\n    if(typeof Buffer != 'undefined') {\n      this.buffer =  new Buffer(Binary.BUFFER_SIZE);\n    } else if(typeof Uint8Array != 'undefined'){\n      this.buffer = new Uint8Array(new ArrayBuffer(Binary.BUFFER_SIZE));\n    } else {\n      this.buffer = new Array(Binary.BUFFER_SIZE);\n    }\n    // Set position to start of buffer\n    this.position = 0;\n  }\n}",
    "ctx": {
      "type": "function",
      "name": "Binary",
      "string": "Binary()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Character"
        ],
        "name": "byte_value",
        "description": "a single byte we wish to write.",
        "optional": false
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Updates this binary with byte_value.</p>",
      "summary": "<p>Updates this binary with byte_value.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 58,
    "codeStart": 64,
    "code": "Binary.prototype.put = function put(byte_value) {\n  // If it's a string and a has more than one character throw an error\n  if(byte_value['length'] != null && typeof byte_value != 'number' && byte_value.length != 1) throw new Error(\"only accepts single character String, Uint8Array or Array\");\n  if(typeof byte_value != 'number' && byte_value < 0 || byte_value > 255) throw new Error(\"only accepts number in a valid unsigned byte range 0-255\");\n\n  // Decode the byte value once\n  var decoded_byte = null;\n  if(typeof byte_value == 'string') {\n    decoded_byte = byte_value.charCodeAt(0);\n  } else if(byte_value['length'] != null) {\n    decoded_byte = byte_value[0];\n  } else {\n    decoded_byte = byte_value;\n  }\n\n  if(this.buffer.length > this.position) {\n    this.buffer[this.position++] = decoded_byte;\n  } else {\n    if(typeof Buffer != 'undefined' && Buffer.isBuffer(this.buffer)) {\n      // Create additional overflow buffer\n      var buffer = new Buffer(Binary.BUFFER_SIZE + this.buffer.length);\n      // Combine the two buffers together\n      this.buffer.copy(buffer, 0, 0, this.buffer.length);\n      this.buffer = buffer;\n      this.buffer[this.position++] = decoded_byte;\n    } else {\n      var buffer = null;\n      // Create a new buffer (typed or normal array)\n      if(Object.prototype.toString.call(this.buffer) == '[object Uint8Array]') {\n        buffer = new Uint8Array(new ArrayBuffer(Binary.BUFFER_SIZE + this.buffer.length));\n      } else {\n        buffer = new Array(Binary.BUFFER_SIZE + this.buffer.length);\n      }\n\n      // We need to copy all the content to the new array\n      for(var i = 0; i < this.buffer.length; i++) {\n        buffer[i] = this.buffer[i];\n      }\n\n      // Reassign the buffer\n      this.buffer = buffer;\n      // Write the byte\n      this.buffer[this.position++] = decoded_byte;\n    }\n  }\n};",
    "ctx": {
      "type": "method",
      "constructor": "Binary",
      "cons": "Binary",
      "name": "put",
      "string": "Binary.prototype.put()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Buffer",
          "String"
        ],
        "name": "string",
        "description": "a string or buffer to be written to the Binary BSON object.",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "Number"
        ],
        "name": "offset",
        "description": "specify the binary of where to write the content.",
        "optional": false
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Writes a buffer or string to the binary.</p>",
      "summary": "<p>Writes a buffer or string to the binary.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 111,
    "codeStart": 118,
    "code": "Binary.prototype.write = function write(string, offset) {\n  offset = typeof offset == 'number' ? offset : this.position;\n\n  // If the buffer is to small let's extend the buffer\n  if(this.buffer.length < offset + string.length) {\n    var buffer = null;\n    // If we are in node.js\n    if(typeof Buffer != 'undefined' && Buffer.isBuffer(this.buffer)) {\n      buffer = new Buffer(this.buffer.length + string.length);\n      this.buffer.copy(buffer, 0, 0, this.buffer.length);\n    } else if(Object.prototype.toString.call(this.buffer) == '[object Uint8Array]') {\n      // Create a new buffer\n      buffer = new Uint8Array(new ArrayBuffer(this.buffer.length + string.length))\n      // Copy the content\n      for(var i = 0; i < this.position; i++) {\n        buffer[i] = this.buffer[i];\n      }\n    }\n\n    // Assign the new buffer\n    this.buffer = buffer;\n  }\n\n  if(typeof Buffer != 'undefined' && Buffer.isBuffer(string) && Buffer.isBuffer(this.buffer)) {\n    string.copy(this.buffer, offset, 0, string.length);\n    this.position = (offset + string.length) > this.position ? (offset + string.length) : this.position;\n    // offset = string.length\n  } else if(typeof Buffer != 'undefined' && typeof string == 'string' && Buffer.isBuffer(this.buffer)) {\n    this.buffer.write(string, 'binary', offset);\n    this.position = (offset + string.length) > this.position ? (offset + string.length) : this.position;\n    // offset = string.length;\n  } else if(Object.prototype.toString.call(string) == '[object Uint8Array]'\n    || Object.prototype.toString.call(string) == '[object Array]' && typeof string != 'string') {\n    for(var i = 0; i < string.length; i++) {\n      this.buffer[offset++] = string[i];\n    }\n\n    this.position = offset > this.position ? offset : this.position;\n  } else if(typeof string == 'string') {\n    for(var i = 0; i < string.length; i++) {\n      this.buffer[offset++] = string.charCodeAt(i);\n    }\n\n    this.position = offset > this.position ? offset : this.position;\n  }\n};",
    "ctx": {
      "type": "method",
      "constructor": "Binary",
      "cons": "Binary",
      "name": "write",
      "string": "Binary.prototype.write()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Number"
        ],
        "name": "position",
        "description": "read from the given position in the Binary.",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "Number"
        ],
        "name": "length",
        "description": "the number of bytes to read.",
        "optional": false
      },
      {
        "type": "return",
        "types": [
          "Buffer"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Reads <strong>length</strong> bytes starting at <strong>position</strong>.</p>",
      "summary": "<p>Reads <strong>length</strong> bytes starting at <strong>position</strong>.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 165,
    "codeStart": 173,
    "code": "Binary.prototype.read = function read(position, length) {\n  length = length && length > 0\n    ? length\n    : this.position;\n\n  // Let's return the data based on the type we have\n  if(this.buffer['slice']) {\n    return this.buffer.slice(position, position + length);\n  } else {\n    // Create a buffer to keep the result\n    var buffer = typeof Uint8Array != 'undefined' ? new Uint8Array(new ArrayBuffer(length)) : new Array(length);\n    for(var i = 0; i < length; i++) {\n      buffer[i] = this.buffer[position++];\n    }\n  }\n  // Return the buffer\n  return buffer;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Binary",
      "cons": "Binary",
      "name": "read",
      "string": "Binary.prototype.read()"
    }
  },
  {
    "tags": [
      {
        "type": "return",
        "types": [
          "String"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Returns the value of this binary as a string.</p>",
      "summary": "<p>Returns the value of this binary as a string.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 192,
    "codeStart": 198,
    "code": "Binary.prototype.value = function value(asRaw) {\n  asRaw = asRaw == null ? false : asRaw;\n\n  // Optimize to serialize for the situation where the data == size of buffer\n  if(asRaw && typeof Buffer != 'undefined' && Buffer.isBuffer(this.buffer) && this.buffer.length == this.position)\n    return this.buffer;\n\n  // If it's a node.js buffer object\n  if(typeof Buffer != 'undefined' && Buffer.isBuffer(this.buffer)) {\n    return asRaw ? this.buffer.slice(0, this.position) : this.buffer.toString('binary', 0, this.position);\n  } else {\n    if(asRaw) {\n      // we support the slice command use it\n      if(this.buffer['slice'] != null) {\n        return this.buffer.slice(0, this.position);\n      } else {\n        // Create a new buffer to copy content to\n        var newBuffer = Object.prototype.toString.call(this.buffer) == '[object Uint8Array]' ? new Uint8Array(new ArrayBuffer(this.position)) : new Array(this.position);\n        // Copy content\n        for(var i = 0; i < this.position; i++) {\n          newBuffer[i] = this.buffer[i];\n        }\n        // Return the buffer\n        return newBuffer;\n      }\n    } else {\n      return convertArraytoUtf8BinaryString(this.buffer, 0, this.position);\n    }\n  }\n};",
    "ctx": {
      "type": "method",
      "constructor": "Binary",
      "cons": "Binary",
      "name": "value",
      "string": "Binary.prototype.value()"
    }
  },
  {
    "tags": [
      {
        "type": "return",
        "types": [
          "Number"
        ],
        "description": "the length of the binary."
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Length.</p>",
      "summary": "<p>Length.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 229,
    "codeStart": 235,
    "code": "Binary.prototype.length = function length() {\n  return this.position;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Binary",
      "cons": "Binary",
      "name": "length",
      "string": "Binary.prototype.length()"
    }
  },
  {
    "tags": [
      {
        "type": "ignore",
        "string": ""
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "",
      "summary": "",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": false,
    "line": 239,
    "codeStart": 243,
    "code": "Binary.prototype.toJSON = function() {\n  return this.buffer != null ? this.buffer.toString('base64') : '';\n};",
    "ctx": {
      "type": "method",
      "constructor": "Binary",
      "cons": "Binary",
      "name": "toJSON",
      "string": "Binary.prototype.toJSON()"
    }
  },
  {
    "tags": [
      {
        "type": "ignore",
        "string": ""
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "",
      "summary": "",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": false,
    "line": 247,
    "codeStart": 251,
    "code": "Binary.prototype.toString = function(format) {\n  return this.buffer != null ? this.buffer.slice(0, this.position).toString(format) : '';\n};\n\n// Binary default subtype\nvar BSON_BINARY_SUBTYPE_DEFAULT = 0;",
    "ctx": {
      "type": "method",
      "constructor": "Binary",
      "cons": "Binary",
      "name": "toString",
      "string": "Binary.prototype.toString()"
    }
  },
  {
    "tags": [
      {
        "type": "ignore",
        "string": ""
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "",
      "summary": "",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": false,
    "line": 258,
    "codeStart": 262,
    "code": "var writeStringToArray = function(data) {\n  // Create a buffer\n  var buffer = typeof Uint8Array != 'undefined' ? new Uint8Array(new ArrayBuffer(data.length)) : new Array(data.length);\n  // Write the content to the buffer\n  for(var i = 0; i < data.length; i++) {\n    buffer[i] = data.charCodeAt(i);\n  }\n  // Write the string to the buffer\n  return buffer;\n};",
    "ctx": {
      "type": "function",
      "name": "writeStringToArray",
      "string": "writeStringToArray()"
    }
  },
  {
    "tags": [
      {
        "type": "ignore",
        "string": ""
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Convert Array ot Uint8Array to Binary String</p>",
      "summary": "<p>Convert Array ot Uint8Array to Binary String</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": false,
    "line": 273,
    "codeStart": 279,
    "code": "var convertArraytoUtf8BinaryString = function(byteArray, startIndex, endIndex) {\n  var result = \"\";\n  for(var i = startIndex; i < endIndex; i++) {\n    result = result + String.fromCharCode(byteArray[i]);\n  }\n  return result;\n};\n\nBinary.BUFFER_SIZE = 256;",
    "ctx": {
      "type": "function",
      "name": "convertArraytoUtf8BinaryString",
      "string": "convertArraytoUtf8BinaryString()"
    }
  },
  {
    "tags": [
      {
        "type": "classconstant",
        "string": "SUBTYPE_DEFAULT"
      }
    ],
    "description": {
      "full": "<p>Default BSON type</p>",
      "summary": "<p>Default BSON type</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 289,
    "codeStart": 294,
    "code": "Binary.SUBTYPE_DEFAULT = 0;",
    "ctx": {
      "type": "property",
      "receiver": "Binary",
      "name": "SUBTYPE_DEFAULT",
      "value": "0",
      "string": "Binary.SUBTYPE_DEFAULT"
    }
  },
  {
    "tags": [
      {
        "type": "classconstant",
        "string": "SUBTYPE_DEFAULT"
      }
    ],
    "description": {
      "full": "<p>Function BSON type</p>",
      "summary": "<p>Function BSON type</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 295,
    "codeStart": 300,
    "code": "Binary.SUBTYPE_FUNCTION = 1;",
    "ctx": {
      "type": "property",
      "receiver": "Binary",
      "name": "SUBTYPE_FUNCTION",
      "value": "1",
      "string": "Binary.SUBTYPE_FUNCTION"
    }
  },
  {
    "tags": [
      {
        "type": "classconstant",
        "string": "SUBTYPE_DEFAULT"
      }
    ],
    "description": {
      "full": "<p>Byte Array BSON type</p>",
      "summary": "<p>Byte Array BSON type</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 301,
    "codeStart": 306,
    "code": "Binary.SUBTYPE_BYTE_ARRAY = 2;",
    "ctx": {
      "type": "property",
      "receiver": "Binary",
      "name": "SUBTYPE_BYTE_ARRAY",
      "value": "2",
      "string": "Binary.SUBTYPE_BYTE_ARRAY"
    }
  },
  {
    "tags": [
      {
        "type": "classconstant",
        "string": "SUBTYPE_DEFAULT"
      }
    ],
    "description": {
      "full": "<p>OLD UUID BSON type</p>",
      "summary": "<p>OLD UUID BSON type</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 307,
    "codeStart": 312,
    "code": "Binary.SUBTYPE_UUID_OLD = 3;",
    "ctx": {
      "type": "property",
      "receiver": "Binary",
      "name": "SUBTYPE_UUID_OLD",
      "value": "3",
      "string": "Binary.SUBTYPE_UUID_OLD"
    }
  },
  {
    "tags": [
      {
        "type": "classconstant",
        "string": "SUBTYPE_DEFAULT"
      }
    ],
    "description": {
      "full": "<p>UUID BSON type</p>",
      "summary": "<p>UUID BSON type</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 313,
    "codeStart": 318,
    "code": "Binary.SUBTYPE_UUID = 4;",
    "ctx": {
      "type": "property",
      "receiver": "Binary",
      "name": "SUBTYPE_UUID",
      "value": "4",
      "string": "Binary.SUBTYPE_UUID"
    }
  },
  {
    "tags": [
      {
        "type": "classconstant",
        "string": "SUBTYPE_DEFAULT"
      }
    ],
    "description": {
      "full": "<p>MD5 BSON type</p>",
      "summary": "<p>MD5 BSON type</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 319,
    "codeStart": 324,
    "code": "Binary.SUBTYPE_MD5 = 5;",
    "ctx": {
      "type": "property",
      "receiver": "Binary",
      "name": "SUBTYPE_MD5",
      "value": "5",
      "string": "Binary.SUBTYPE_MD5"
    }
  },
  {
    "tags": [
      {
        "type": "classconstant",
        "string": "SUBTYPE_DEFAULT"
      }
    ],
    "description": {
      "full": "<p>User BSON type</p>",
      "summary": "<p>User BSON type</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 325,
    "codeStart": 330,
    "code": "Binary.SUBTYPE_USER_DEFINED = 128;",
    "ctx": {
      "type": "property",
      "receiver": "Binary",
      "name": "SUBTYPE_USER_DEFINED",
      "value": "128",
      "string": "Binary.SUBTYPE_USER_DEFINED"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Expose.</p>",
      "summary": "<p>Expose.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 332,
    "codeStart": 335,
    "code": "module.exports = Binary;\nmodule.exports.Binary = Binary;",
    "ctx": {
      "type": "property",
      "receiver": "module",
      "name": "exports",
      "value": "Binary",
      "string": "module.exports"
    }
  }
]
### lib/binaryparser.js
[
  {
    "tags": [
      {
        "type": "see",
        "title": "",
        "url": "https://github.com/mongodb/js-bson/blob/master/lib/bson/binary_parser.js"
      }
    ],
    "description": {
      "full": "<p>Binary Parser.<br />Jonas Raoni Soares Silva<br /><a href=\"http://jsfromhell.com/classes/binary-parser\">http://jsfromhell.com/classes/binary-parser</a> [v1.0]</p>",
      "summary": "<p>Binary Parser.<br />Jonas Raoni Soares Silva<br /><a href=\"http://jsfromhell.com/classes/binary-parser\">http://jsfromhell.com/classes/binary-parser</a> [v1.0]</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 1,
    "codeStart": 8,
    "code": "var chr = String.fromCharCode;\n\nvar maxBits = [];\nfor (var i = 0; i < 64; i++) {\n\tmaxBits[i] = Math.pow(2, i);\n}\n\nfunction BinaryParser (bigEndian, allowExceptions) {\n  if(!(this instanceof BinaryParser)) return new BinaryParser(bigEndian, allowExceptions);\n  \n\tthis.bigEndian = bigEndian;\n\tthis.allowExceptions = allowExceptions;\n}\n\nBinaryParser.warn = function warn (msg) {\n\tif (this.allowExceptions) {\n\t\tthrow new Error(msg);\n  }\n\n\treturn 1;\n};\n\nBinaryParser.decodeInt = function decodeInt (data, bits, signed, forceBigEndian) {\n  var b = new this.Buffer(this.bigEndian || forceBigEndian, data)\n      , x = b.readBits(0, bits)\n      , max = maxBits[bits]; //max = Math.pow( 2, bits );\n  \n  return signed && x >= max / 2\n      ? x - max\n      : x;\n};\n\nBinaryParser.encodeInt = function encodeInt (data, bits, signed, forceBigEndian) {\n\tvar max = maxBits[bits];\n\n  if (data >= max || data < -(max / 2)) {\n    this.warn(\"encodeInt::overflow\");\n    data = 0;\n  }\n\n\tif (data < 0) {\n    data += max;\n  }\n\n\tfor (var r = []; data; r[r.length] = String.fromCharCode(data % 256), data = Math.floor(data / 256));\n\n\tfor (bits = -(-bits >> 3) - r.length; bits--; r[r.length] = \"\\0\");\n\n  return ((this.bigEndian || forceBigEndian) ? r.reverse() : r).join(\"\");\n};\n\nBinaryParser.toSmall    = function( data ){ return this.decodeInt( data,  8, true  ); };\nBinaryParser.fromSmall  = function( data ){ return this.encodeInt( data,  8, true  ); };\nBinaryParser.toByte     = function( data ){ return this.decodeInt( data,  8, false ); };\nBinaryParser.fromByte   = function( data ){ return this.encodeInt( data,  8, false ); };\nBinaryParser.toShort    = function( data ){ return this.decodeInt( data, 16, true  ); };\nBinaryParser.fromShort  = function( data ){ return this.encodeInt( data, 16, true  ); };\nBinaryParser.toWord     = function( data ){ return this.decodeInt( data, 16, false ); };\nBinaryParser.fromWord   = function( data ){ return this.encodeInt( data, 16, false ); };\nBinaryParser.toInt      = function( data ){ return this.decodeInt( data, 32, true  ); };\nBinaryParser.fromInt    = function( data ){ return this.encodeInt( data, 32, true  ); };\nBinaryParser.toLong     = function( data ){ return this.decodeInt( data, 64, true  ); };\nBinaryParser.fromLong   = function( data ){ return this.encodeInt( data, 64, true  ); };\nBinaryParser.toDWord    = function( data ){ return this.decodeInt( data, 32, false ); };\nBinaryParser.fromDWord  = function( data ){ return this.encodeInt( data, 32, false ); };\nBinaryParser.toQWord    = function( data ){ return this.decodeInt( data, 64, true ); };\nBinaryParser.fromQWord  = function( data ){ return this.encodeInt( data, 64, true ); };",
    "ctx": {
      "type": "declaration",
      "name": "chr",
      "value": "String.fromCharCode",
      "string": "chr"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>BinaryParser buffer constructor.</p>",
      "summary": "<p>BinaryParser buffer constructor.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 76,
    "codeStart": 79,
    "code": "function BinaryParserBuffer (bigEndian, buffer) {\n  this.bigEndian = bigEndian || 0;\n  this.buffer = [];\n  this.setBuffer(buffer);\n}\n\nBinaryParserBuffer.prototype.setBuffer = function setBuffer (data) {\n  var l, i, b;\n\n\tif (data) {\n    i = l = data.length;\n    b = this.buffer = new Array(l);\n\t\tfor (; i; b[l - i] = data.charCodeAt(--i));\n\t\tthis.bigEndian && b.reverse();\n\t}\n};\n\nBinaryParserBuffer.prototype.hasNeededBits = function hasNeededBits (neededBits) {\n\treturn this.buffer.length >= -(-neededBits >> 3);\n};\n\nBinaryParserBuffer.prototype.checkBuffer = function checkBuffer (neededBits) {\n\tif (!this.hasNeededBits(neededBits)) {\n\t\tthrow new Error(\"checkBuffer::missing bytes\");\n  }\n};\n\nBinaryParserBuffer.prototype.readBits = function readBits (start, length) {\n\t//shl fix: Henri Torgemane ~1996 (compressed by Jonas Raoni)\n\n\tfunction shl (a, b) {\n\t\tfor (; b--; a = ((a %= 0x7fffffff + 1) & 0x40000000) == 0x40000000 ? a * 2 : (a - 0x40000000) * 2 + 0x7fffffff + 1);\n\t\treturn a;\n\t}\n\n\tif (start < 0 || length <= 0) {\n\t\treturn 0;\n  }\n\n\tthis.checkBuffer(start + length);\n\n  var offsetLeft\n    , offsetRight = start % 8\n    , curByte = this.buffer.length - ( start >> 3 ) - 1\n    , lastByte = this.buffer.length + ( -( start + length ) >> 3 )\n    , diff = curByte - lastByte\n    , sum = ((this.buffer[ curByte ] >> offsetRight) & ((1 << (diff ? 8 - offsetRight : length)) - 1)) + (diff && (offsetLeft = (start + length) % 8) ? (this.buffer[lastByte++] & ((1 << offsetLeft) - 1)) << (diff-- << 3) - offsetRight : 0);\n\n\tfor(; diff; sum += shl(this.buffer[lastByte++], (diff-- << 3) - offsetRight));\n\n\treturn sum;\n};",
    "ctx": {
      "type": "function",
      "name": "BinaryParserBuffer",
      "string": "BinaryParserBuffer()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Expose.</p>",
      "summary": "<p>Expose.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 132,
    "codeStart": 135,
    "code": "BinaryParser.Buffer = BinaryParserBuffer;\n\nexports.BinaryParser = BinaryParser;",
    "ctx": {
      "type": "property",
      "receiver": "BinaryParser",
      "name": "Buffer",
      "value": "BinaryParserBuffer",
      "string": "BinaryParser.Buffer"
    }
  }
]
### lib/collection.js
[
  {
    "tags": [],
    "description": {
      "full": "<p>Module dependencies.</p>",
      "summary": "<p>Module dependencies.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 1,
    "codeStart": 5,
    "code": "var Schema = require('./schema')\n  , Document = require('./document');\n\n//TODO: написать метод .upsert( doc ) - обновление документа, а если его нет, то создание\n\n//TODO: доделать логику с apiResource (сохранять ссылку на него и использовть при методе doc.save)",
    "ctx": {
      "type": "declaration",
      "name": "Schema",
      "value": "require('./schema')",
      "string": "Schema"
    }
  },
  {
    "tags": [
      {
        "type": "example",
        "string": ""
      },
      {
        "type": "param",
        "types": [
          "string"
        ],
        "name": "name",
        "description": "- название коллекции",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "Schema"
        ],
        "name": "schema",
        "description": "- Схема или объект описания схемы",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "[api]",
        "description": "- ссылка на api ресурс",
        "optional": true
      },
      {
        "type": "constructor",
        "string": ""
      }
    ],
    "description": {
      "full": "<p>Конструктор коллекций.</p>",
      "summary": "<p>Конструктор коллекций.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": true,
    "ignore": false,
    "line": 11,
    "codeStart": 21,
    "code": "function Collection ( name, schema, api ){\n  // Сохраним название пространства имён\n  this.name = name;\n  // Хранилище для документов\n  this.documents = {};\n\n  if ( _.isObject( schema ) && !( schema instanceof Schema ) ) {\n    schema = new Schema( schema );\n  }\n\n  // Сохраним ссылку на api для метода .save()\n  this.api = api;\n\n  // Используемая схема для коллекции\n  this.schema = schema;\n\n  // Отображение объекта documents в виде массива (для нокаута)\n  this.array = [];\n  // Нужно для обновления привязок к этому свойству для knockoutjs\n  window.ko && ko.track( this, ['array'] );\n}\n\nCollection.prototype = {",
    "ctx": {
      "type": "constructor",
      "name": "Collection",
      "string": "Collection()"
    }
  },
  {
    "tags": [
      {
        "type": "example",
        "string": "storage.collection.add({ type: 'jelly bean' });\nstorage.collection.add([{ type: 'jelly bean' }, { type: 'snickers' }]);\nstorage.collection.add({ _id: '*****', type: 'jelly bean' }, true);\n"
      },
      {
        "type": "param",
        "types": [
          "object",
          "Array.<object>"
        ],
        "name": "[doc]",
        "description": "- Документ",
        "optional": true
      },
      {
        "type": "param",
        "types": [
          "object"
        ],
        "name": "[fields]",
        "description": "- выбранные поля при запросе (не реализовано в документе)",
        "optional": true
      },
      {
        "type": "param",
        "types": [
          "boolean"
        ],
        "name": "[init]",
        "description": "- hydrate document - наполнить документ данными (используется в api-client)",
        "optional": true
      },
      {
        "type": "param",
        "types": [
          "boolean"
        ],
        "name": "[_storageWillMutate]",
        "description": "- Флаг добавления массива документов. только для внутреннего использования",
        "optional": true
      },
      {
        "type": "returns",
        "types": [
          "storage.Document",
          "Array.<storage.Document>"
        ],
        "description": ""
      }
    ],
    "description": {
      "full": "<p>Добавить документ или массив документов.</p>",
      "summary": "<p>Добавить документ или массив документов.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 44,
    "codeStart": 58,
    "code": "add: function( doc, fields, init, _storageWillMutate ){\n  var self = this;\n\n  // Если документа нет, значит будет пустой\n  if ( doc == null ) doc = null;\n\n  // Массив документов\n  if ( _.isArray( doc ) ){\n    var savedDocs = [];\n\n    _.each( doc, function( doc ){\n      savedDocs.push( self.add( doc, fields, init, true ) );\n    });\n\n    this.storageHasMutated();\n\n    return savedDocs;\n  }\n\n  var id = doc && doc._id;\n\n  // Если документ уже есть, то просто установить значения\n  if ( id && this.documents[ id ] ){\n    this.documents[ id ].set( doc );\n\n  } else {\n    var discriminatorMapping = this.schema\n      ? this.schema.discriminatorMapping\n      : null;\n\n    var key = discriminatorMapping && discriminatorMapping.isRoot\n      ? discriminatorMapping.key\n      : null;\n\n    // Выбираем схему, если есть дискриминатор\n    var schema;\n    if (key && doc && doc[key] && this.schema.discriminators && this.schema.discriminators[doc[key]]) {\n      schema = this.schema.discriminators[doc[key]];\n\n    } else {\n      schema = this.schema;\n    }\n\n    var newDoc = new Document( doc, this.name, schema, fields, init );\n    id = newDoc._id.toString();\n  }\n\n  // Для одиночных документов тоже нужно  вызвать storageHasMutated\n  if ( !_storageWillMutate ){\n    this.storageHasMutated();\n  }\n\n  return this.documents[ id ];\n},",
    "ctx": {
      "type": "method",
      "name": "add",
      "string": "add()"
    }
  },
  {
    "tags": [
      {
        "type": "example",
        "string": "storage.collection.remove( Document );\nstorage.collection.remove( uuid );\n"
      },
      {
        "type": "param",
        "types": [
          "object",
          "number"
        ],
        "name": "document",
        "description": "- Сам документ или его id.",
        "optional": false
      },
      {
        "type": "returns",
        "types": [
          "boolean"
        ],
        "description": ""
      }
    ],
    "description": {
      "full": "<p>Удаленить документ.</p>",
      "summary": "<p>Удаленить документ.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 113,
    "codeStart": 123,
    "code": "remove: function( document ){\n  return delete this.documents[ document._id || document ];\n},",
    "ctx": {
      "type": "method",
      "name": "remove",
      "string": "remove()"
    }
  },
  {
    "tags": [
      {
        "type": "example",
        "string": "// named john\nstorage.collection.find({ name: 'john' });\nstorage.collection.find({ author: 'Shakespeare', year: 1611 });\n"
      },
      {
        "type": "param",
        "types": [
          "conditions"
        ],
        "name": "",
        "description": "",
        "optional": false
      },
      {
        "type": "returns",
        "types": [
          "Array.<storage.Document>"
        ],
        "description": ""
      }
    ],
    "description": {
      "full": "<p>Найти документы.</p>",
      "summary": "<p>Найти документы.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 127,
    "codeStart": 138,
    "code": "find: function( conditions ){\n  return _.where( this.documents, conditions );\n},",
    "ctx": {
      "type": "method",
      "name": "find",
      "string": "find()"
    }
  },
  {
    "tags": [
      {
        "type": "example",
        "string": "storage.collection.findById( id );\n"
      },
      {
        "type": "param",
        "types": [
          "_id"
        ],
        "name": "",
        "description": "",
        "optional": false
      },
      {
        "type": "returns",
        "types": [
          "storage.Document",
          "undefined"
        ],
        "description": ""
      }
    ],
    "description": {
      "full": "<p>Найти один документ по id.</p>",
      "summary": "<p>Найти один документ по id.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 142,
    "codeStart": 151,
    "code": "findById: function( _id ){\n  return this.documents[ _id ];\n},",
    "ctx": {
      "type": "method",
      "name": "findById",
      "string": "findById()"
    }
  },
  {
    "tags": [
      {
        "type": "example",
        "string": "storage.collection.findByIdAndRemove( id ) // returns сollection\n"
      },
      {
        "type": "see",
        "local": "Collection.findById"
      },
      {
        "type": "see",
        "local": "Collection.remove "
      },
      {
        "type": "param",
        "types": [
          "_id"
        ],
        "name": "",
        "description": "",
        "optional": false
      },
      {
        "type": "returns",
        "types": [
          "Collection"
        ],
        "description": ""
      }
    ],
    "description": {
      "full": "<p>Найти по id документ и удалить его.</p>",
      "summary": "<p>Найти по id документ и удалить его.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 155,
    "codeStart": 167,
    "code": "findByIdAndRemove: function( _id ){\n  this.remove( this.findById( _id ) );\n  return this;\n},",
    "ctx": {
      "type": "method",
      "name": "findByIdAndRemove",
      "string": "findByIdAndRemove()"
    }
  },
  {
    "tags": [
      {
        "type": "see",
        "local": "Collection.findById"
      },
      {
        "type": "see",
        "local": "Collection.update "
      },
      {
        "type": "param",
        "types": [
          "_id"
        ],
        "name": "",
        "description": "",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "string",
          "object"
        ],
        "name": "path",
        "description": "",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "object",
          "boolean",
          "number",
          "string",
          "null",
          "undefined"
        ],
        "name": "value",
        "description": "",
        "optional": false
      },
      {
        "type": "returns",
        "types": [
          "storage.Document",
          "undefined"
        ],
        "description": ""
      }
    ],
    "description": {
      "full": "<p>Найти по id документ и обновить его.</p>",
      "summary": "<p>Найти по id документ и обновить его.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 172,
    "codeStart": 183,
    "code": "findByIdAndUpdate: function( _id, path, value ){\n  return this.update( this.findById( _id ), path, value );\n},",
    "ctx": {
      "type": "method",
      "name": "findByIdAndUpdate",
      "string": "findByIdAndUpdate()"
    }
  },
  {
    "tags": [
      {
        "type": "example",
        "string": "// find one iphone adventures\nstorage.adventure.findOne({ type: 'iphone' });\n"
      },
      {
        "type": "param",
        "types": [
          "conditions"
        ],
        "name": "",
        "description": "",
        "optional": false
      },
      {
        "type": "returns",
        "types": [
          "storage.Document",
          "undefined"
        ],
        "description": ""
      }
    ],
    "description": {
      "full": "<p>Найти один документ.</p>",
      "summary": "<p>Найти один документ.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 187,
    "codeStart": 197,
    "code": "findOne: function( conditions ){\n  return _.findWhere( this.documents, conditions );\n},",
    "ctx": {
      "type": "method",
      "name": "findOne",
      "string": "findOne()"
    }
  },
  {
    "tags": [
      {
        "type": "example",
        "string": "storage.collection.findOneAndRemove( conditions ) // returns сollection\n"
      },
      {
        "type": "see",
        "local": "Collection.findOne"
      },
      {
        "type": "see",
        "local": "Collection.remove "
      },
      {
        "type": "param",
        "types": [
          "object"
        ],
        "name": "conditions",
        "description": "",
        "optional": false
      },
      {
        "type": "returns",
        "types": [
          "Collection"
        ],
        "description": ""
      }
    ],
    "description": {
      "full": "<p>Найти по условию один документ и удалить его.</p>",
      "summary": "<p>Найти по условию один документ и удалить его.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 201,
    "codeStart": 213,
    "code": "findOneAndRemove: function( conditions ){\n  this.remove( this.findOne( conditions ) );\n  return this;\n},",
    "ctx": {
      "type": "method",
      "name": "findOneAndRemove",
      "string": "findOneAndRemove()"
    }
  },
  {
    "tags": [
      {
        "type": "see",
        "local": "Collection.findOne"
      },
      {
        "type": "see",
        "local": "Collection.update "
      },
      {
        "type": "param",
        "types": [
          "object"
        ],
        "name": "conditions",
        "description": "",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "string",
          "object"
        ],
        "name": "path",
        "description": "",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "object",
          "boolean",
          "number",
          "string",
          "null",
          "undefined"
        ],
        "name": "value",
        "description": "",
        "optional": false
      },
      {
        "type": "returns",
        "types": [
          "storage.Document",
          "undefined"
        ],
        "description": ""
      }
    ],
    "description": {
      "full": "<p>Найти документ по условию и обновить его.</p>",
      "summary": "<p>Найти документ по условию и обновить его.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 218,
    "codeStart": 229,
    "code": "findOneAndUpdate: function( conditions, path, value ){\n  return this.update( this.findOne( conditions ), path, value );\n},",
    "ctx": {
      "type": "method",
      "name": "findOneAndUpdate",
      "string": "findOneAndUpdate()"
    }
  },
  {
    "tags": [
      {
        "type": "example",
        "string": "storage.places.update( storage.places.findById( 0 ), {\n  name: 'Irkutsk'\n});\n"
      },
      {
        "type": "param",
        "types": [
          "number",
          "object"
        ],
        "name": "document",
        "description": "",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "string",
          "object"
        ],
        "name": "path",
        "description": "",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "object",
          "boolean",
          "number",
          "string",
          "null",
          "undefined"
        ],
        "name": "value",
        "description": "",
        "optional": false
      },
      {
        "type": "returns",
        "types": [
          "storage.Document",
          "Boolean"
        ],
        "description": ""
      }
    ],
    "description": {
      "full": "<p>Обновить существующие поля в документе.</p>",
      "summary": "<p>Обновить существующие поля в документе.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 233,
    "codeStart": 246,
    "code": "update: function( document, path, value ){\n  var doc = this.documents[ document._id || document ];\n\n  if ( doc == null ){\n    console.warn('storage::update: Document is not found.');\n    return false;\n  }\n\n  return doc.set( path, value );\n},",
    "ctx": {
      "type": "method",
      "name": "update",
      "string": "update()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Обработчик на изменения (добавление, удаление) данных в коллекции</p>",
      "summary": "<p>Обработчик на изменения (добавление, удаление) данных в коллекции</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 257,
    "codeStart": 260,
    "code": "storageHasMutated: function(){\n  // Обновим массив документов (специальное отображение для перебора нокаутом)\n  this.array = _.toArray( this.documents );\n}\n};",
    "ctx": {
      "type": "method",
      "name": "storageHasMutated",
      "string": "storageHasMutated()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Module exports.</p>",
      "summary": "<p>Module exports.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 266,
    "codeStart": 270,
    "code": "module.exports = Collection;",
    "ctx": {
      "type": "property",
      "receiver": "module",
      "name": "exports",
      "value": "Collection",
      "string": "module.exports"
    }
  }
]
### lib/document.js
[
  {
    "tags": [],
    "description": {
      "full": "<p>Module dependencies.</p>",
      "summary": "<p>Module dependencies.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 1,
    "codeStart": 5,
    "code": "var Events = require('./events')\n  , StorageError = require('./error')\n  , MixedSchema = require('./schema/mixed')\n  , ObjectId = require('./types/objectid')\n  , Schema = require('./schema')\n  , ValidatorError = require('./schematype').ValidatorError\n  , utils = require('./utils')\n  , clone = utils.clone\n  , ValidationError = StorageError.ValidationError\n  , InternalCache = require('./internal')\n  , deepEqual = utils.deepEqual\n  , DocumentArray\n  , SchemaArray\n  , Embedded;",
    "ctx": {
      "type": "declaration",
      "name": "Events",
      "value": "require('./events')",
      "string": "Events"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "object"
        ],
        "name": "data",
        "description": "- значения, которые нужно установить",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "string",
          "undefined"
        ],
        "name": "[collectionName]",
        "description": "- коллекция в которой будет находится документ",
        "optional": true
      },
      {
        "type": "param",
        "types": [
          "Schema"
        ],
        "name": "schema",
        "description": "- схема по которой будет создан документ",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "object"
        ],
        "name": "[fields]",
        "description": "- выбранные поля в документе (не реализовано)",
        "optional": true
      },
      {
        "type": "param",
        "types": [
          "Boolean"
        ],
        "name": "[init]",
        "description": "- hydrate document - наполнить документ данными (используется в api-client)",
        "optional": true
      },
      {
        "type": "constructor",
        "string": ""
      }
    ],
    "description": {
      "full": "<p>Конструктор документа.</p>",
      "summary": "<p>Конструктор документа.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": true,
    "ignore": false,
    "line": 20,
    "codeStart": 30,
    "code": "function Document ( data, collectionName, schema, fields, init ){\n  this.$__ = new InternalCache;\n  this.isNew = true;\n\n  // Создать пустой документ с флагом init\n  // new TestDocument(true);\n  if ( 'boolean' === typeof data ){\n    init = data;\n    data = null;\n  }\n\n  if ( _.isObject( schema ) && !( schema instanceof Schema )) {\n    schema = new Schema( schema );\n  }\n\n  // Создать пустой документ по схеме\n  if ( data instanceof Schema ){\n    schema = data;\n    data = null;\n\n    if ( schema.options._id ){\n      data = { _id: new ObjectId() };\n    }\n\n  } else {\n    // При создании EmbeddedDocument, в нём уже есть схема и ему не нужен _id\n    schema = this.schema || schema;\n    // Сгенерировать ObjectId, если он отсутствует, но его требует схема\n    if ( !this.schema && schema.options._id ){\n      data = data || {};\n\n      if ( data._id === undefined ){\n        data._id = new ObjectId();\n      }\n    }\n  }\n\n  if ( !schema ){\n    throw new StorageError.MissingSchemaError();\n  }\n\n  // Создать документ с флагом init\n  // new TestDocument({ test: 'boom' }, true);\n  if ( 'boolean' === typeof collectionName ){\n    init = collectionName;\n    collectionName = undefined;\n  }\n\n  // Создать документ с strict: true\n  // collection.add({...}, true);\n  if ('boolean' === typeof fields) {\n    this.$__.strictMode = fields;\n    fields = undefined;\n  } else {\n    this.$__.strictMode = schema.options && schema.options.strict;\n    this.$__.selected = fields;\n  }\n\n  this.schema = schema;\n  this.collection = window.storage[ collectionName ];\n  this.collectionName = collectionName;\n\n  if ( this.collection ){\n    if ( data == null || !data._id ){\n      throw new TypeError('Для помещения в коллекцию необходимо, чтобы у документа был _id');\n    }\n    // Поместить документ в коллекцию\n    this.collection.documents[ data._id ] = this;\n  }\n\n  var required = schema.requiredPaths();\n  for (var i = 0; i < required.length; ++i) {\n    this.$__.activePaths.require( required[i] );\n  }\n\n  this.$__setSchema( schema );\n\n  this._doc = this.$__buildDoc( data, init );\n\n  if ( init ){\n    this.init( data );\n  } else if ( data ) {\n    this.set( data, undefined, true );\n  }\n\n  // apply methods\n  for ( var m in schema.methods ){\n    this[ m ] = schema.methods[ m ];\n  }\n  // apply statics\n  for ( var s in schema.statics ){\n    this[ s ] = schema.statics[ s ];\n  }\n}",
    "ctx": {
      "type": "constructor",
      "name": "Document",
      "string": "Document()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Inherits from EventEmitter.</p>",
      "summary": "<p>Inherits from EventEmitter.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 125,
    "codeStart": 128,
    "code": "Document.prototype = Object.create( Events.prototype );\nDocument.prototype.constructor = Document;",
    "ctx": {
      "type": "property",
      "receiver": "Document",
      "name": "prototype",
      "value": "Object.create( Events.prototype )",
      "string": "Document.prototype"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      },
      {
        "type": "property",
        "types": [
          "schema"
        ],
        "name": "",
        "description": "",
        "optional": false
      }
    ],
    "description": {
      "full": "<p>The documents schema.</p>",
      "summary": "<p>The documents schema.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 131,
    "codeStart": 137,
    "code": "Document.prototype.schema;",
    "ctx": {
      "type": "property",
      "constructor": "Document",
      "cons": "Document",
      "name": "schema",
      "string": "Document.prototype.schema"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      },
      {
        "type": "property",
        "types": [
          "isNew"
        ],
        "name": "",
        "description": "",
        "optional": false
      }
    ],
    "description": {
      "full": "<p>Boolean flag specifying if the document is new.</p>",
      "summary": "<p>Boolean flag specifying if the document is new.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 139,
    "codeStart": 145,
    "code": "Document.prototype.isNew;",
    "ctx": {
      "type": "property",
      "constructor": "Document",
      "cons": "Document",
      "name": "isNew",
      "string": "Document.prototype.isNew"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      },
      {
        "type": "see",
        "local": "Schema options /docs/guide.html#options"
      },
      {
        "type": "property",
        "types": [
          "id"
        ],
        "name": "",
        "description": "",
        "optional": false
      }
    ],
    "description": {
      "full": "<p>The string version of this documents _id.</p><h4>Note:</h4>\n<p>This getter exists on all documents by default. The getter can be disabled by setting the <code>id</code> <a href=\"/docs/guide.html#id\">option</a> of its <code>Schema</code> to false at construction time.</p><pre><code>new Schema({ name: String }, { id: false });\n</code></pre>",
      "summary": "<p>The string version of this documents _id.</p>",
      "body": "<h4>Note:</h4>\n<p>This getter exists on all documents by default. The getter can be disabled by setting the <code>id</code> <a href=\"/docs/guide.html#id\">option</a> of its <code>Schema</code> to false at construction time.</p><pre><code>new Schema({ name: String }, { id: false });\n</code></pre>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 147,
    "codeStart": 160,
    "code": "Document.prototype.id;",
    "ctx": {
      "type": "property",
      "constructor": "Document",
      "cons": "Document",
      "name": "id",
      "string": "Document.prototype.id"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      },
      {
        "type": "property",
        "types": [
          "errors"
        ],
        "name": "",
        "description": "",
        "optional": false
      }
    ],
    "description": {
      "full": "<p>Hash containing current validation errors.</p>",
      "summary": "<p>Hash containing current validation errors.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 162,
    "codeStart": 168,
    "code": "Document.prototype.errors;\n\nDocument.prototype.adapterHooks = {\n  documentDefineProperty: $.noop,\n  documentSetInitialValue: $.noop,\n  documentGetValue: $.noop,\n  documentSetValue: $.noop\n};",
    "ctx": {
      "type": "property",
      "constructor": "Document",
      "cons": "Document",
      "name": "errors",
      "string": "Document.prototype.errors"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "obj",
        "description": "",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "Boolean"
        ],
        "name": "[skipId]",
        "description": "",
        "optional": true
      },
      {
        "type": "return",
        "types": [
          "Object"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "private"
      },
      {
        "type": "method",
        "string": "$__buildDoc"
      },
      {
        "type": "memberOf",
        "parent": "Document"
      }
    ],
    "description": {
      "full": "<p>Builds the default doc structure</p>",
      "summary": "<p>Builds the default doc structure</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": false,
    "line": 177,
    "codeStart": 187,
    "code": "Document.prototype.$__buildDoc = function ( obj, skipId ) {\n  var doc = {}\n    , self = this;\n\n  var paths = Object.keys( this.schema.paths )\n    , plen = paths.length\n    , ii = 0;\n\n  for ( ; ii < plen; ++ii ) {\n    var p = paths[ii];\n\n    if ( '_id' == p ) {\n      if ( skipId ) continue;\n      if ( obj && '_id' in obj ) continue;\n    }\n\n    var type = this.schema.paths[ p ]\n      , path = p.split('.')\n      , len = path.length\n      , last = len - 1\n      , doc_ = doc\n      , i = 0;\n\n    for ( ; i < len; ++i ) {\n      var piece = path[ i ]\n        , defaultVal;\n\n      if ( i === last ) {\n        defaultVal = type.getDefault( self, true );\n\n        if ('undefined' !== typeof defaultVal ) {\n          doc_[ piece ] = defaultVal;\n          self.$__.activePaths.default( p );\n        }\n      } else {\n        doc_ = doc_[ piece ] || ( doc_[ piece ] = {} );\n      }\n    }\n  }\n\n  return doc;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Document",
      "cons": "Document",
      "name": "$__buildDoc",
      "string": "Document.prototype.$__buildDoc()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "data",
        "description": "document returned by server",
        "optional": false
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Initializes the document without setters or marking anything modified.</p><p>Called internally after a document is returned from server.</p>",
      "summary": "<p>Initializes the document without setters or marking anything modified.</p>",
      "body": "<p>Called internally after a document is returned from server.</p>"
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": false,
    "line": 230,
    "codeStart": 238,
    "code": "Document.prototype.init = function ( data ) {\n  this.isNew = false;\n\n  //todo: сдесь всё изменится, смотреть коммент метода this.populated\n  // handle docs with populated paths",
    "ctx": {
      "type": "method",
      "constructor": "Document",
      "cons": "Document",
      "name": "init",
      "string": "Document.prototype.init()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>if ( doc._id &amp;&amp; opts &amp;&amp; opts.populated &amp;&amp; opts.populated.length ) {<br />    var id = String( doc._id );<br />    for (var i = 0; i &lt; opts.populated.length; ++i) {<br />      var item = opts.populated[ i ];<br />      this.populated( item.path, item._docs[id], item );<br />    }<br />  }</p>",
      "summary": "<p>if ( doc._id &amp;&amp; opts &amp;&amp; opts.populated &amp;&amp; opts.populated.length ) {<br />    var id = String( doc._id );<br />    for (var i = 0; i &lt; opts.populated.length; ++i) {<br />      var item = opts.populated[ i ];<br />      this.populated( item.path, item._docs[id], item );<br />    }<br />  }</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 243,
    "codeStart": 253,
    "code": "init( this, data, this._doc );\n\nreturn this;\n};"
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "self",
        "description": "document instance",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "obj",
        "description": "raw server doc",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "doc",
        "description": "object we are initializing",
        "optional": false
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Init helper.</p>",
      "summary": "<p>Init helper.</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": true,
    "line": 258,
    "codeStart": 266,
    "code": "function init (self, obj, doc, prefix) {\n  prefix = prefix || '';\n\n  var keys = Object.keys(obj)\n    , len = keys.length\n    , schema\n    , path\n    , i;\n\n  while (len--) {\n    i = keys[len];\n    path = prefix + i;\n    schema = self.schema.path(path);\n\n    if (!schema && _.isPlainObject( obj[ i ] ) &&\n        (!obj[i].constructor || 'Object' == utils.getFunctionName(obj[i].constructor))) {\n      // assume nested object\n      if (!doc[i]) doc[i] = {};\n      init(self, obj[i], doc[i], path + '.');\n    } else {\n      if (obj[i] === null) {\n        doc[i] = null;\n      } else if (obj[i] !== undefined) {\n        if (schema) {\n          self.$__try(function(){\n            doc[i] = schema.cast(obj[i], self, true);\n          });\n        } else {\n          doc[i] = obj[i];\n        }\n\n        self.adapterHooks.documentSetInitialValue.call( self, self, path, doc[i] );\n      }\n      // mark as hydrated\n      self.$__.activePaths.init(path);\n    }\n  }\n}",
    "ctx": {
      "type": "function",
      "name": "init",
      "string": "init()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String",
          "Object"
        ],
        "name": "path",
        "description": "path or object of key/vals to set",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "Mixed"
        ],
        "name": "val",
        "description": "the value to set",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "Schema",
          "String",
          "Number",
          "etc.."
        ],
        "name": "[type]",
        "description": "optionally specify a type for \"on-the-fly\" attributes",
        "optional": true
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "[options]",
        "description": "optionally specify options that modify the behavior of the set",
        "optional": true
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Sets the value of a path, or many paths.</p><h4>Example:</h4>\n<pre><code>// path, value\ndoc.set(path, value)\n\n// object\ndoc.set({\n    path  : value\n  , path2 : {\n       path  : value\n    }\n})\n\n// only-the-fly cast to number\ndoc.set(path, value, Number)\n\n// only-the-fly cast to string\ndoc.set(path, value, String)\n\n// changing strict mode behavior\ndoc.set(path, value, { strict: false });\n</code></pre>",
      "summary": "<p>Sets the value of a path, or many paths.</p>",
      "body": "<h4>Example:</h4>\n<pre><code>// path, value\ndoc.set(path, value)\n\n// object\ndoc.set({\n    path  : value\n  , path2 : {\n       path  : value\n    }\n})\n\n// only-the-fly cast to number\ndoc.set(path, value, Number)\n\n// only-the-fly cast to string\ndoc.set(path, value, String)\n\n// changing strict mode behavior\ndoc.set(path, value, { strict: false });\n</code></pre>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 305,
    "codeStart": 336,
    "code": "Document.prototype.set = function (path, val, type, options) {\n  if (type && 'Object' == utils.getFunctionName(type.constructor)) {\n    options = type;\n    type = undefined;\n  }\n\n  var merge = options && options.merge\n    , adhoc = type && true !== type\n    , constructing = true === type\n    , adhocs;\n\n  var strict = options && 'strict' in options\n    ? options.strict\n    : this.$__.strictMode;\n\n  if (adhoc) {\n    adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});\n    adhocs[path] = Schema.interpretAsType(path, type);\n  }\n\n  if ('string' !== typeof path) {\n    // new Document({ key: val })\n\n    if (null === path || undefined === path) {\n      var _temp = path;\n      path = val;\n      val = _temp;\n\n    } else {\n      var prefix = val\n        ? val + '.'\n        : '';\n\n      if (path instanceof Document) path = path._doc;\n\n      var keys = Object.keys(path)\n        , i = keys.length\n        , pathtype\n        , key;\n\n\n      while (i--) {\n        key = keys[i];\n        pathtype = this.schema.pathType(prefix + key);\n        if (null != path[key]\n            // need to know if plain object - no Buffer, ObjectId, ref, etc\n            && _.isPlainObject(path[key])\n            && ( !path[key].constructor || 'Object' == utils.getFunctionName(path[key].constructor) )\n            && 'virtual' != pathtype\n            && !( this.$__path( prefix + key ) instanceof MixedSchema )\n            && !( this.schema.paths[key] && this.schema.paths[key].options.ref )\n          ){\n\n          this.set(path[key], prefix + key, constructing);\n\n        } else if (strict) {\n          if ('real' === pathtype || 'virtual' === pathtype) {\n            this.set(prefix + key, path[key], constructing);\n\n          } else if ('throw' == strict) {\n            throw new Error(\"Field `\" + key + \"` is not in schema.\");\n          }\n\n        } else if (undefined !== path[key]) {\n          this.set(prefix + key, path[key], constructing);\n        }\n      }\n\n      return this;\n    }\n  }\n\n  // ensure _strict is honored for obj props\n  // docschema = new Schema({ path: { nest: 'string' }})\n  // doc.set('path', obj);\n  var pathType = this.schema.pathType(path);\n  if ('nested' == pathType && val && _.isPlainObject(val) &&\n      (!val.constructor || 'Object' == utils.getFunctionName(val.constructor))) {\n    if (!merge) this.setValue(path, null);\n    this.set(val, path, constructing);\n    return this;\n  }\n\n  var schema;\n  var parts = path.split('.');\n  var subpath;\n\n  if ('adhocOrUndefined' == pathType && strict) {\n\n    // check for roots that are Mixed types\n    var mixed;\n\n    for (var i = 0; i < parts.length; ++i) {\n      subpath = parts.slice(0, i+1).join('.');\n      schema = this.schema.path(subpath);\n      if (schema instanceof MixedSchema) {\n        // allow changes to sub paths of mixed types\n        mixed = true;\n        break;\n      }\n    }\n\n    if (!mixed) {\n      if ('throw' == strict) {\n        throw new Error(\"Field `\" + path + \"` is not in schema.\");\n      }\n      return this;\n    }\n\n  } else if ('virtual' == pathType) {\n    schema = this.schema.virtualpath(path);\n    schema.applySetters(val, this);\n    return this;\n  } else {\n    schema = this.$__path(path);\n  }\n\n  var pathToMark;\n\n  // When using the $set operator the path to the field must already exist.\n  // Else mongodb throws: \"LEFT_SUBFIELD only supports Object\"\n\n  if (parts.length <= 1) {\n    pathToMark = path;\n  } else {\n    for ( i = 0; i < parts.length; ++i ) {\n      subpath = parts.slice(0, i + 1).join('.');\n      if (this.isDirectModified(subpath) // earlier prefixes that are already\n                                         // marked as dirty have precedence\n          || this.get(subpath) === null) {\n        pathToMark = subpath;\n        break;\n      }\n    }\n\n    if (!pathToMark) pathToMark = path;\n  }\n\n  // if this doc is being constructed we should not trigger getters\n  var priorVal = constructing\n    ? undefined\n    : this.getValue(path);\n\n  if (!schema || undefined === val) {\n    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);\n    return this;\n  }\n\n  var self = this;\n  var shouldSet = this.$__try(function(){\n    val = schema.applySetters(val, self, false, priorVal);\n  });\n\n  if (shouldSet) {\n    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);\n  }\n\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Document",
      "cons": "Document",
      "name": "set",
      "string": "Document.prototype.set()"
    }
  },
  {
    "tags": [
      {
        "type": "return",
        "types": [
          "Boolean"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "private"
      },
      {
        "type": "method",
        "string": "$__shouldModify"
      },
      {
        "type": "memberOf",
        "parent": "Document"
      }
    ],
    "description": {
      "full": "<p>Determine if we should mark this change as modified.</p>",
      "summary": "<p>Determine if we should mark this change as modified.</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": false,
    "line": 496,
    "codeStart": 504,
    "code": "Document.prototype.$__shouldModify = function (\n    pathToMark, path, constructing, parts, schema, val, priorVal) {\n\n  if (this.isNew) return true;\n\n  if ( undefined === val && !this.isSelected(path) ) {\n    // when a path is not selected in a query, its initial\n    // value will be undefined.\n    return true;\n  }\n\n  if (undefined === val && path in this.$__.activePaths.states.default) {\n    // we're just unsetting the default value which was never saved\n    return false;\n  }\n\n  if (!utils.deepEqual(val, priorVal || this.get(path))) {\n    return true;\n  }\n\n  //тест не проходит из-за наличия лишнего поля в states.default (comments)\n  // На самом деле поле вроде и не лишнее\n  //console.info( path, path in this.$__.activePaths.states.default );\n  //console.log( this.$__.activePaths );\n\n  // Когда мы устанавливаем такое же значение как default\n  // Не понятно зачем мангуст его обновлял",
    "ctx": {
      "type": "method",
      "constructor": "Document",
      "cons": "Document",
      "name": "$__shouldModify",
      "string": "Document.prototype.$__shouldModify()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>if (!constructing &amp;&amp;<br />      null != val &amp;&amp;<br />      path in this.$__.activePaths.states.default &amp;&amp;<br />      utils.deepEqual(val, schema.getDefault(this, constructing)) ) {</p><pre><code>//console.log( pathToMark, this.$__.activePaths.states.modify );\n\n// a path with a default was $unset on the server\n// and the user is setting it to the same value again\nreturn true;\n</code></pre><p>  }</p>",
      "summary": "<p>if (!constructing &amp;&amp;<br />      null != val &amp;&amp;<br />      path in this.$__.activePaths.states.default &amp;&amp;<br />      utils.deepEqual(val, schema.getDefault(this, constructing)) ) {</p>",
      "body": "<pre><code>//console.log( pathToMark, this.$__.activePaths.states.modify );\n\n// a path with a default was $unset on the server\n// and the user is setting it to the same value again\nreturn true;\n</code></pre><p>  }</p>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 531,
    "codeStart": 545,
    "code": "return false;\n};"
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      },
      {
        "type": "method",
        "string": "$__set"
      },
      {
        "type": "memberOf",
        "parent": "Document"
      }
    ],
    "description": {
      "full": "<p>Handles the actual setting of the value and marking the path modified if appropriate.</p>",
      "summary": "<p>Handles the actual setting of the value and marking the path modified if appropriate.</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": false,
    "line": 548,
    "codeStart": 555,
    "code": "Document.prototype.$__set = function ( pathToMark, path, constructing, parts, schema, val, priorVal ) {\n  var shouldModify = this.$__shouldModify.apply(this, arguments);\n\n  if (shouldModify) {\n    this.markModified(pathToMark, val);\n  }\n\n  var obj = this._doc\n    , i = 0\n    , l = parts.length;\n\n  for (; i < l; i++) {\n    var next = i + 1\n      , last = next === l;\n\n    if ( last ) {\n      obj[parts[i]] = val;\n\n      this.adapterHooks.documentSetValue.call( this, this, path, val );\n\n    } else {\n      if (obj[parts[i]] && 'Object' === utils.getFunctionName(obj[parts[i]].constructor)) {\n        obj = obj[parts[i]];\n\n      } else if (obj[parts[i]] && 'EmbeddedDocument' === utils.getFunctionName(obj[parts[i]].constructor) ) {\n        obj = obj[parts[i]];\n\n      } else if (obj[parts[i]] && Array.isArray(obj[parts[i]])) {\n        obj = obj[parts[i]];\n\n      } else {\n        obj = obj[parts[i]] = {};\n      }\n    }\n  }\n};",
    "ctx": {
      "type": "method",
      "constructor": "Document",
      "cons": "Document",
      "name": "$__set",
      "string": "Document.prototype.$__set()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "path",
        "description": "",
        "optional": false
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Gets a raw value from a path (no getters)</p>",
      "summary": "<p>Gets a raw value from a path (no getters)</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": false,
    "line": 592,
    "codeStart": 598,
    "code": "Document.prototype.getValue = function (path) {\n  return utils.getValue(path, this._doc);\n};",
    "ctx": {
      "type": "method",
      "constructor": "Document",
      "cons": "Document",
      "name": "getValue",
      "string": "Document.prototype.getValue()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "path",
        "description": "",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "value",
        "description": "",
        "optional": false
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Sets a raw value for a path (no casting, setters, transformations)</p>",
      "summary": "<p>Sets a raw value for a path (no casting, setters, transformations)</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": false,
    "line": 602,
    "codeStart": 609,
    "code": "Document.prototype.setValue = function (path, value) {\n  utils.setValue(path, value, this._doc);\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Document",
      "cons": "Document",
      "name": "setValue",
      "string": "Document.prototype.setValue()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "path",
        "description": "",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "Schema",
          "String",
          "Number"
        ],
        "name": "[type]",
        "description": "optionally specify a type for on-the-fly attributes",
        "optional": true
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Returns the value of a path.</p><h4>Example</h4>\n<pre><code>// path\ndoc.get(&#39;age&#39;) // 47\n\n// dynamic casting to a string\ndoc.get(&#39;age&#39;, String) // &quot;47&quot;\n</code></pre>",
      "summary": "<p>Returns the value of a path.</p>",
      "body": "<h4>Example</h4>\n<pre><code>// path\ndoc.get(&#39;age&#39;) // 47\n\n// dynamic casting to a string\ndoc.get(&#39;age&#39;, String) // &quot;47&quot;\n</code></pre>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 614,
    "codeStart": 629,
    "code": "Document.prototype.get = function (path, type) {\n  var adhocs;\n  if (type) {\n    adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});\n    adhocs[path] = Schema.interpretAsType(path, type);\n  }\n\n  var schema = this.$__path(path) || this.schema.virtualpath(path)\n    , pieces = path.split('.')\n    , obj = this._doc;\n\n  for (var i = 0, l = pieces.length; i < l; i++) {\n    obj = undefined === obj || null === obj\n      ? undefined\n      : obj[pieces[i]];\n  }\n\n  if (schema) {\n    obj = schema.applyGetters(obj, this);\n  }\n\n  this.adapterHooks.documentGetValue.call( this, this, path );\n\n  return obj;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Document",
      "cons": "Document",
      "name": "get",
      "string": "Document.prototype.get()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "path",
        "description": "",
        "optional": false
      },
      {
        "type": "api",
        "visibility": "private"
      },
      {
        "type": "method",
        "string": "$__path"
      },
      {
        "type": "memberOf",
        "parent": "Document"
      }
    ],
    "description": {
      "full": "<p>Returns the schematype for the given <code>path</code>.</p>",
      "summary": "<p>Returns the schematype for the given <code>path</code>.</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": false,
    "line": 655,
    "codeStart": 663,
    "code": "Document.prototype.$__path = function (path) {\n  var adhocs = this.$__.adhocPaths\n    , adhocType = adhocs && adhocs[path];\n\n  if (adhocType) {\n    return adhocType;\n  } else {\n    return this.schema.path(path);\n  }\n};",
    "ctx": {
      "type": "method",
      "constructor": "Document",
      "cons": "Document",
      "name": "$__path",
      "string": "Document.prototype.$__path()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "path",
        "description": "the path to mark modified",
        "optional": false
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Marks the path as having pending changes to write to the db.</p><p><em>Very helpful when using <a href=\"./schematypes.html#mixed\">Mixed</a> types.</em></p><h4>Example:</h4>\n<pre><code>doc.mixed.type = &#39;changed&#39;;\ndoc.markModified(&#39;mixed.type&#39;);\ndoc.save() // changes to mixed.type are now persisted\n</code></pre>",
      "summary": "<p>Marks the path as having pending changes to write to the db.</p>",
      "body": "<p><em>Very helpful when using <a href=\"./schematypes.html#mixed\">Mixed</a> types.</em></p><h4>Example:</h4>\n<pre><code>doc.mixed.type = &#39;changed&#39;;\ndoc.markModified(&#39;mixed.type&#39;);\ndoc.save() // changes to mixed.type are now persisted\n</code></pre>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 674,
    "codeStart": 688,
    "code": "Document.prototype.markModified = function (path) {\n  this.$__.activePaths.modify(path);\n};",
    "ctx": {
      "type": "method",
      "constructor": "Document",
      "cons": "Document",
      "name": "markModified",
      "string": "Document.prototype.markModified()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "fn",
        "description": "function to execute",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "[scope]",
        "description": "the scope with which to call fn",
        "optional": true
      },
      {
        "type": "api",
        "visibility": "private"
      },
      {
        "type": "method",
        "string": "$__try"
      },
      {
        "type": "memberOf",
        "parent": "Document"
      }
    ],
    "description": {
      "full": "<p>Catches errors that occur during execution of <code>fn</code> and stores them to later be passed when <code>save()</code> is executed.</p>",
      "summary": "<p>Catches errors that occur during execution of <code>fn</code> and stores them to later be passed when <code>save()</code> is executed.</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": false,
    "line": 692,
    "codeStart": 701,
    "code": "Document.prototype.$__try = function (fn, scope) {\n  var res;\n  try {\n    fn.call(scope);\n    res = true;\n  } catch (e) {\n    this.$__error(e);\n    res = false;\n  }\n  return res;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Document",
      "cons": "Document",
      "name": "$__try",
      "string": "Document.prototype.$__try()"
    }
  },
  {
    "tags": [
      {
        "type": "return",
        "types": [
          "Array"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Returns the list of paths that have been modified.</p>",
      "summary": "<p>Returns the list of paths that have been modified.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 713,
    "codeStart": 719,
    "code": "Document.prototype.modifiedPaths = function () {\n  var directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);\n\n  return directModifiedPaths.reduce(function (list, path) {\n    var parts = path.split('.');\n    return list.concat(parts.reduce(function (chains, part, i) {\n      return chains.concat(parts.slice(0, i).concat(part).join('.'));\n    }, []));\n  }, []);\n};",
    "ctx": {
      "type": "method",
      "constructor": "Document",
      "cons": "Document",
      "name": "modifiedPaths",
      "string": "Document.prototype.modifiedPaths()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "[path]",
        "description": "optional",
        "optional": true
      },
      {
        "type": "return",
        "types": [
          "Boolean"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Returns true if this document was modified, else false.</p><p>If <code>path</code> is given, checks if a path or any full path containing <code>path</code> as part of its path chain has been modified.</p><h4>Example</h4>\n<pre><code>doc.set(&#39;documents.0.title&#39;, &#39;changed&#39;);\ndoc.isModified()                    // true\ndoc.isModified(&#39;documents&#39;)         // true\ndoc.isModified(&#39;documents.0.title&#39;) // true\ndoc.isDirectModified(&#39;documents&#39;)   // false\n</code></pre>",
      "summary": "<p>Returns true if this document was modified, else false.</p>",
      "body": "<p>If <code>path</code> is given, checks if a path or any full path containing <code>path</code> as part of its path chain has been modified.</p><h4>Example</h4>\n<pre><code>doc.set(&#39;documents.0.title&#39;, &#39;changed&#39;);\ndoc.isModified()                    // true\ndoc.isModified(&#39;documents&#39;)         // true\ndoc.isModified(&#39;documents.0.title&#39;) // true\ndoc.isDirectModified(&#39;documents&#39;)   // false\n</code></pre>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 730,
    "codeStart": 747,
    "code": "Document.prototype.isModified = function (path) {\n  return path\n    ? !!~this.modifiedPaths().indexOf(path)\n    : this.$__.activePaths.some('modify');\n};",
    "ctx": {
      "type": "method",
      "constructor": "Document",
      "cons": "Document",
      "name": "isModified",
      "string": "Document.prototype.isModified()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "path",
        "description": "",
        "optional": false
      },
      {
        "type": "return",
        "types": [
          "Boolean"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Returns true if <code>path</code> was directly set and modified, else false.</p><h4>Example</h4>\n<pre><code>doc.set(&#39;documents.0.title&#39;, &#39;changed&#39;);\ndoc.isDirectModified(&#39;documents.0.title&#39;) // true\ndoc.isDirectModified(&#39;documents&#39;) // false\n</code></pre>",
      "summary": "<p>Returns true if <code>path</code> was directly set and modified, else false.</p>",
      "body": "<h4>Example</h4>\n<pre><code>doc.set(&#39;documents.0.title&#39;, &#39;changed&#39;);\ndoc.isDirectModified(&#39;documents.0.title&#39;) // true\ndoc.isDirectModified(&#39;documents&#39;) // false\n</code></pre>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 753,
    "codeStart": 766,
    "code": "Document.prototype.isDirectModified = function (path) {\n  return (path in this.$__.activePaths.states.modify);\n};",
    "ctx": {
      "type": "method",
      "constructor": "Document",
      "cons": "Document",
      "name": "isDirectModified",
      "string": "Document.prototype.isDirectModified()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "path",
        "description": "",
        "optional": false
      },
      {
        "type": "return",
        "types": [
          "Boolean"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Checks if <code>path</code> was initialized.</p>",
      "summary": "<p>Checks if <code>path</code> was initialized.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 770,
    "codeStart": 777,
    "code": "Document.prototype.isInit = function (path) {\n  return (path in this.$__.activePaths.states.init);\n};",
    "ctx": {
      "type": "method",
      "constructor": "Document",
      "cons": "Document",
      "name": "isInit",
      "string": "Document.prototype.isInit()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "path",
        "description": "",
        "optional": false
      },
      {
        "type": "return",
        "types": [
          "Boolean"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Checks if <code>path</code> was selected in the source query which initialized this document.</p><h4>Example</h4>\n<pre><code>Thing.findOne().select(&#39;name&#39;).exec(function (err, doc) {\n   doc.isSelected(&#39;name&#39;) // true\n   doc.isSelected(&#39;age&#39;)  // false\n})\n</code></pre>",
      "summary": "<p>Checks if <code>path</code> was selected in the source query which initialized this document.</p>",
      "body": "<h4>Example</h4>\n<pre><code>Thing.findOne().select(&#39;name&#39;).exec(function (err, doc) {\n   doc.isSelected(&#39;name&#39;) // true\n   doc.isSelected(&#39;age&#39;)  // false\n})\n</code></pre>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 781,
    "codeStart": 796,
    "code": "Document.prototype.isSelected = function isSelected (path) {\n  if (this.$__.selected) {\n\n    if ('_id' === path) {\n      return 0 !== this.$__.selected._id;\n    }\n\n    var paths = Object.keys(this.$__.selected)\n      , i = paths.length\n      , inclusive = false\n      , cur;\n\n    if (1 === i && '_id' === paths[0]) {\n      // only _id was selected.\n      return 0 === this.$__.selected._id;\n    }\n\n    while (i--) {\n      cur = paths[i];\n      if ('_id' == cur) continue;\n      inclusive = !! this.$__.selected[cur];\n      break;\n    }\n\n    if (path in this.$__.selected) {\n      return inclusive;\n    }\n\n    i = paths.length;\n    var pathDot = path + '.';\n\n    while (i--) {\n      cur = paths[i];\n      if ('_id' == cur) continue;\n\n      if (0 === cur.indexOf(pathDot)) {\n        return inclusive;\n      }\n\n      if (0 === pathDot.indexOf(cur + '.')) {\n        return inclusive;\n      }\n    }\n\n    return ! inclusive;\n  }\n\n  return true;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Document",
      "cons": "Document",
      "name": "isSelected",
      "string": "Document.prototype.isSelected()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "cb",
        "description": "called after validation completes, passing an error if one occurred",
        "optional": false
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Executes registered validation rules for this document.</p><h4>Note:</h4>\n<p>This method is called <code>pre</code> save and if a validation rule is violated, <a href=\"#model_Model-save\">save</a> is aborted and the error is returned to your <code>callback</code>.</p><h4>Example:</h4>\n<pre><code>doc.validate(function (err) {\n  if (err) handleError(err);\n  else // validation passed\n});\n</code></pre>",
      "summary": "<p>Executes registered validation rules for this document.</p>",
      "body": "<h4>Note:</h4>\n<p>This method is called <code>pre</code> save and if a validation rule is violated, <a href=\"#model_Model-save\">save</a> is aborted and the error is returned to your <code>callback</code>.</p><h4>Example:</h4>\n<pre><code>doc.validate(function (err) {\n  if (err) handleError(err);\n  else // validation passed\n});\n</code></pre>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 846,
    "codeStart": 863,
    "code": "Document.prototype.validate = function (cb) {\n  var self = this;\n\n  // only validate required fields when necessary\n  var paths = Object.keys(this.$__.activePaths.states.require).filter(function (path) {\n    if (!self.isSelected(path) && !self.isModified(path)) return false;\n    return true;\n  });\n\n  paths = paths.concat(Object.keys(this.$__.activePaths.states.init));\n  paths = paths.concat(Object.keys(this.$__.activePaths.states.modify));\n  paths = paths.concat(Object.keys(this.$__.activePaths.states.default));\n\n  if (0 === paths.length) {\n    complete();\n    return this;\n  }\n\n  var validating = {}\n    , total = 0;\n\n  paths.forEach(validatePath);\n  return this;\n\n  function validatePath (path) {\n    if (validating[path]) return;\n\n    validating[path] = true;\n    total++;\n\n    utils.setImmediate(function(){\n      var p = self.schema.path(path);\n      if (!p) return --total || complete();\n\n      var val = self.getValue(path);\n      p.doValidate(val, function (err) {\n        if (err) {\n          self.invalidate(\n              path\n            , err\n            , undefined\n            //, true // embedded docs\n            );\n        }\n        --total || complete();\n      }, self);\n    });\n  }\n\n  function complete () {\n    var err = self.$__.validationError;\n    self.$__.validationError = undefined;\n    cb && cb(err);\n  }\n};",
    "ctx": {
      "type": "method",
      "constructor": "Document",
      "cons": "Document",
      "name": "validate",
      "string": "Document.prototype.validate()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "path",
        "description": "the field to invalidate",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "String",
          "Error"
        ],
        "name": "errorMsg",
        "description": "the error which states the reason `path` was invalid",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "Object",
          "String",
          "Number",
          "any"
        ],
        "name": "value",
        "description": "optional invalid value",
        "optional": false
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Marks a path as invalid, causing validation to fail.</p><p>The <code>errorMsg</code> argument will become the message of the <code>ValidationError</code>.</p><p>The <code>value</code> argument (if passed) will be available through the <code>ValidationError.value</code> property.</p><pre><code>doc.invalidate(&#39;size&#39;, &#39;must be less than 20&#39;, 14);\n\ndoc.validate(function (err) {\n  console.log(err)\n  // prints\n  { message: &#39;Validation failed&#39;,\n    name: &#39;ValidationError&#39;,\n    errors:\n     { size:\n        { message: &#39;must be less than 20&#39;,\n          name: &#39;ValidatorError&#39;,\n          path: &#39;size&#39;,\n          type: &#39;user defined&#39;,\n          value: 14 } } }\n})\n</code></pre>",
      "summary": "<p>Marks a path as invalid, causing validation to fail.</p>",
      "body": "<p>The <code>errorMsg</code> argument will become the message of the <code>ValidationError</code>.</p><p>The <code>value</code> argument (if passed) will be available through the <code>ValidationError.value</code> property.</p><pre><code>doc.invalidate(&#39;size&#39;, &#39;must be less than 20&#39;, 14);\n\ndoc.validate(function (err) {\n  console.log(err)\n  // prints\n  { message: &#39;Validation failed&#39;,\n    name: &#39;ValidationError&#39;,\n    errors:\n     { size:\n        { message: &#39;must be less than 20&#39;,\n          name: &#39;ValidatorError&#39;,\n          path: &#39;size&#39;,\n          type: &#39;user defined&#39;,\n          value: 14 } } }\n})\n</code></pre>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 919,
    "codeStart": 947,
    "code": "Document.prototype.invalidate = function (path, errorMsg, value) {\n  if (!this.$__.validationError) {\n    this.$__.validationError = new ValidationError(this);\n  }\n\n  if (!errorMsg || 'string' === typeof errorMsg) {\n    errorMsg = new ValidatorError(path, errorMsg, 'user defined', value);\n  }\n\n  if (this.$__.validationError == errorMsg) return;\n\n  this.$__.validationError.errors[path] = errorMsg;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Document",
      "cons": "Document",
      "name": "invalidate",
      "string": "Document.prototype.invalidate()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      },
      {
        "type": "return",
        "types": [
          "Document"
        ],
        "description": ""
      },
      {
        "type": "method",
        "string": "$__reset"
      },
      {
        "type": "memberOf",
        "parent": "Document"
      }
    ],
    "description": {
      "full": "<p>Resets the internal modified state of this document.</p>",
      "summary": "<p>Resets the internal modified state of this document.</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": false,
    "line": 961,
    "codeStart": 970,
    "code": "Document.prototype.$__reset = function reset () {\n  var self = this;\n\n  this.$__.activePaths\n  .map('init', 'modify', function (i) {\n    return self.getValue(i);\n  })\n  .filter(function (val) {\n    return val && val.isStorageDocumentArray && val.length;\n  })\n  .forEach(function (array) {\n    var i = array.length;\n    while (i--) {\n      var doc = array[i];\n      if (!doc) continue;\n      doc.$__reset();\n    }\n  });\n\n  // Clear 'modify'('dirty') cache\n  this.$__.activePaths.clear('modify');\n  this.$__.validationError = undefined;\n  this.errors = undefined;\n  //console.log( self.$__.activePaths.states.require );\n  //TODO: тут\n  this.schema.requiredPaths().forEach(function (path) {\n    self.$__.activePaths.require(path);\n  });\n\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Document",
      "cons": "Document",
      "name": "$__reset",
      "string": "Document.prototype.$__reset()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      },
      {
        "type": "method",
        "string": "$__dirty"
      },
      {
        "type": "memberOf",
        "parent": "Document"
      }
    ],
    "description": {
      "full": "<p>Returns this documents dirty paths / vals.</p>",
      "summary": "<p>Returns this documents dirty paths / vals.</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": false,
    "line": 1003,
    "codeStart": 1011,
    "code": "Document.prototype.$__dirty = function () {\n  var self = this;\n\n  var all = this.$__.activePaths.map('modify', function (path) {\n    return { path: path\n           , value: self.getValue( path )\n           , schema: self.$__path( path ) };\n  });\n\n  // Sort dirty paths in a flat hierarchy.\n  all.sort(function (a, b) {\n    return (a.path < b.path ? -1 : (a.path > b.path ? 1 : 0));\n  });\n\n  // Ignore \"foo.a\" if \"foo\" is dirty already.\n  var minimal = []\n    , lastPath\n    , top;\n\n  all.forEach(function( item ){\n    lastPath = item.path + '.';\n    minimal.push(item);\n    top = item;\n  });\n\n  top = lastPath = null;\n  return minimal;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Document",
      "cons": "Document",
      "name": "$__dirty",
      "string": "Document.prototype.$__dirty()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Compiles schemas.<br />(установить геттеры/сеттеры на поля документа)</p>",
      "summary": "<p>Compiles schemas.<br />(установить геттеры/сеттеры на поля документа)</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 1040,
    "codeStart": 1044,
    "code": "function compile (self, tree, proto, prefix) {\n  var keys = Object.keys(tree)\n    , i = keys.length\n    , limb\n    , key;\n\n  while (i--) {\n    key = keys[i];\n    limb = tree[key];\n\n    define(self\n        , key\n        , (('Object' === utils.getFunctionName(limb.constructor)\n               && Object.keys(limb).length)\n               && (!limb.type || limb.type.type)\n               ? limb\n               : null)\n        , proto\n        , prefix\n        , keys);\n  }\n}\n\n// gets descriptors for all properties of `object`\n// makes all properties non-enumerable to match previous behavior to #2211\nfunction getOwnPropertyDescriptors(object) {\n  var result = {};\n\n  Object.getOwnPropertyNames(object).forEach(function(key) {\n    result[key] = Object.getOwnPropertyDescriptor(object, key);\n    result[key].enumerable = false;\n  });\n\n  return result;\n}",
    "ctx": {
      "type": "function",
      "name": "compile",
      "string": "compile()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Defines the accessor named prop on the incoming prototype.<br />там же, поля документа сделаем наблюдаемыми</p>",
      "summary": "<p>Defines the accessor named prop on the incoming prototype.<br />там же, поля документа сделаем наблюдаемыми</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 1080,
    "codeStart": 1084,
    "code": "function define (self, prop, subprops, prototype, prefix, keys) {\n  prefix = prefix || '';\n  var path = (prefix ? prefix + '.' : '') + prop;\n\n  if (subprops) {\n    Object.defineProperty(prototype, prop, {\n        enumerable: true\n      , configurable: true\n      , get: function () {\n          if (!this.$__.getters)\n            this.$__.getters = {};\n\n          if (!this.$__.getters[path]) {\n            var nested = Object.create(Object.getPrototypeOf(this), getOwnPropertyDescriptors(this));\n\n            // save scope for nested getters/setters\n            if (!prefix) nested.$__.scope = this;\n\n            // shadow inherited getters from sub-objects so\n            // thing.nested.nested.nested... doesn't occur (gh-366)\n            var i = 0\n              , len = keys.length;\n\n            for (; i < len; ++i) {\n              // over-write the parents getter without triggering it\n              Object.defineProperty(nested, keys[i], {\n                  enumerable: false   // It doesn't show up.\n                , writable: true      // We can set it later.\n                , configurable: true  // We can Object.defineProperty again.\n                , value: undefined    // It shadows its parent.\n              });\n            }\n\n            nested.toObject = function () {\n              return this.get(path);\n            };\n\n            compile( self, subprops, nested, path );\n            this.$__.getters[path] = nested;\n          }\n\n          return this.$__.getters[path];\n        }\n      , set: function (v) {\n          if (v instanceof Document) v = v.toObject();\n          return (this.$__.scope || this).set( path, v );\n        }\n    });\n\n  } else {\n    Object.defineProperty( prototype, prop, {\n        enumerable: true\n      , configurable: true\n      , get: function ( ) { return this.get.call(this.$__.scope || this, path); }\n      , set: function (v) { return this.set.call(this.$__.scope || this, path, v); }\n    });\n  }\n\n  self.adapterHooks.documentDefineProperty.call( self, self, prototype, prop, prefix, path );\n  //self.adapterHooks.documentDefineProperty.call( self, self, path, prototype );\n}",
    "ctx": {
      "type": "function",
      "name": "define",
      "string": "define()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Schema"
        ],
        "name": "schema",
        "description": "",
        "optional": false
      },
      {
        "type": "api",
        "visibility": "private"
      },
      {
        "type": "method",
        "string": "$__setSchema"
      },
      {
        "type": "memberOf",
        "parent": "Document"
      }
    ],
    "description": {
      "full": "<p>Assigns/compiles <code>schema</code> into this documents prototype.</p>",
      "summary": "<p>Assigns/compiles <code>schema</code> into this documents prototype.</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": false,
    "line": 1146,
    "codeStart": 1154,
    "code": "Document.prototype.$__setSchema = function ( schema ) {\n  this.schema = schema;\n  compile( this, schema.tree, this );\n};",
    "ctx": {
      "type": "method",
      "constructor": "Document",
      "cons": "Document",
      "name": "$__setSchema",
      "string": "Document.prototype.$__setSchema()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      },
      {
        "type": "method",
        "string": "$__getAllSubdocs"
      },
      {
        "type": "memberOf",
        "parent": "Document"
      }
    ],
    "description": {
      "full": "<p>Get all subdocs (by bfs)</p>",
      "summary": "<p>Get all subdocs (by bfs)</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": false,
    "line": 1159,
    "codeStart": 1166,
    "code": "Document.prototype.$__getAllSubdocs = function () {\n  DocumentArray || (DocumentArray = require('./types/documentarray'));\n  Embedded = Embedded || require('./types/embedded');\n\n  function docReducer(seed, path) {\n    var val = this[path];\n    if (val instanceof Embedded) seed.push(val);\n    if (val instanceof DocumentArray)\n      val.forEach(function _docReduce(doc) {\n        if (!doc || !doc._doc) return;\n        if (doc instanceof Embedded) seed.push(doc);\n        seed = Object.keys(doc._doc).reduce(docReducer.bind(doc._doc), seed);\n      });\n    return seed;\n  }\n\n  return Object.keys(this._doc).reduce(docReducer.bind(this), []);\n};",
    "ctx": {
      "type": "method",
      "constructor": "Document",
      "cons": "Document",
      "name": "$__getAllSubdocs",
      "string": "Document.prototype.$__getAllSubdocs()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      },
      {
        "type": "method",
        "string": "$__presaveValidate"
      },
      {
        "type": "memberOf",
        "parent": "Document"
      }
    ],
    "description": {
      "full": "<p>Handle generic save stuff.<br />to solve #1446 use use hierarchy instead of hooks</p>",
      "summary": "<p>Handle generic save stuff.<br />to solve #1446 use use hierarchy instead of hooks</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": false,
    "line": 1185,
    "codeStart": 1193,
    "code": "Document.prototype.$__presaveValidate = function $__presaveValidate() {\n  // if any doc.set() calls failed\n\n  var docs = this.$__getArrayPathsToValidate();\n\n  var e2 = docs.map(function (doc) {\n    return doc.$__presaveValidate();\n  });\n  var e1 = [this.$__.saveError].concat(e2);\n  var err = e1.filter(function (x) {return x})[0];\n  this.$__.saveError = null;\n\n  return err;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Document",
      "cons": "Document",
      "name": "$__presaveValidate",
      "string": "Document.prototype.$__presaveValidate()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      },
      {
        "type": "method",
        "string": "$__getArrayPathsToValidate"
      },
      {
        "type": "memberOf",
        "parent": "Document"
      }
    ],
    "description": {
      "full": "<p>Get active path that were changed and are arrays</p>",
      "summary": "<p>Get active path that were changed and are arrays</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": false,
    "line": 1208,
    "codeStart": 1215,
    "code": "Document.prototype.$__getArrayPathsToValidate = function () {\n  DocumentArray || (DocumentArray = require('./types/documentarray'));\n\n  // validate all document arrays.\n  return this.$__.activePaths\n    .map('init', 'modify', function (i) {\n      return this.getValue(i);\n    }.bind(this))\n    .filter(function (val) {\n      return val && val instanceof DocumentArray && val.length;\n    }).reduce(function(seed, array) {\n      return seed.concat(array);\n    }, [])\n    .filter(function (doc) {return doc});\n};",
    "ctx": {
      "type": "method",
      "constructor": "Document",
      "cons": "Document",
      "name": "$__getArrayPathsToValidate",
      "string": "Document.prototype.$__getArrayPathsToValidate()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Error"
        ],
        "name": "err",
        "description": "",
        "optional": false
      },
      {
        "type": "api",
        "visibility": "private"
      },
      {
        "type": "method",
        "string": "$__error"
      },
      {
        "type": "memberOf",
        "parent": "Document"
      }
    ],
    "description": {
      "full": "<p>Registers an error</p>",
      "summary": "<p>Registers an error</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": false,
    "line": 1231,
    "codeStart": 1239,
    "code": "Document.prototype.$__error = function (err) {\n  this.$__.saveError = err;\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Document",
      "cons": "Document",
      "name": "$__error",
      "string": "Document.prototype.$__error()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      },
      {
        "type": "method",
        "string": "$__delta"
      },
      {
        "type": "memberOf",
        "parent": "Document"
      }
    ],
    "description": {
      "full": "<p>Produces a special query document of the modified properties used in updates.</p>",
      "summary": "<p>Produces a special query document of the modified properties used in updates.</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": false,
    "line": 1244,
    "codeStart": 1251,
    "code": "Document.prototype.$__delta = function () {\n  var dirty = this.$__dirty();\n\n  var delta = {}\n    , len = dirty.length\n    , d = 0;\n\n  for (; d < len; ++d) {\n    var data = dirty[ d ];\n    var value = data.value;\n\n    value = utils.clone(value, { depopulate: 1 });\n    delta[ data.path ] = value;\n  }\n\n  return delta;\n};\n\nDocument.prototype.$__handleSave = function(){\n  // Получаем ресурс коллекции, куда будем сохранять данные\n  var resource;\n  if ( this.collection ){\n    resource = this.collection.api;\n  }\n\n  var innerPromise = new $.Deferred();\n\n  if ( this.isNew ) {\n    // send entire doc\n    var obj = this.toObject({ depopulate: 1 });\n\n    if ( ( obj || {} ).hasOwnProperty('_id') === false ) {\n      // documents must have an _id else mongoose won't know\n      // what to update later if more changes are made. the user\n      // wouldn't know what _id was generated by mongodb either\n      // nor would the ObjectId generated my mongodb necessarily\n      // match the schema definition.\n      innerPromise.reject(new Error('document must have an _id before saving'));\n      return innerPromise;\n    }\n\n    // Проверка на окружение тестов\n    // Хотя можно таким образом просто делать валидацию, даже если нет коллекции или api\n    if ( !resource ){\n      innerPromise.resolve( this );\n    } else {\n      resource.create( obj ).always( innerPromise.resolve );\n    }\n\n    this.$__reset();\n    this.isNew = false;\n    this.trigger('isNew', false);\n    // Make it possible to retry the insert\n    this.$__.inserting = true;\n\n  } else {\n    // Make sure we don't treat it as a new object on error,\n    // since it already exists\n    this.$__.inserting = false;\n\n    var delta = this.$__delta();\n\n    if ( !_.isEmpty( delta ) ) {\n      this.$__reset();\n      // Проверка на окружение тестов\n      // Хотя можно таким образом просто делать валидацию, даже если нет коллекции или api\n      if ( !resource ){\n        innerPromise.resolve( this );\n      } else {\n        resource( this.id ).update( delta ).always( innerPromise.resolve );\n      }\n    } else {\n      this.$__reset();\n      innerPromise.resolve( this );\n    }\n\n    this.trigger('isNew', false);\n  }\n\n  return innerPromise;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Document",
      "cons": "Document",
      "name": "$__delta",
      "string": "Document.prototype.$__delta()"
    }
  },
  {
    "tags": [
      {
        "type": "description",
        "string": "Saves this document. "
      },
      {
        "type": "example:",
        "string": "\n    product.sold = Date.now();\n    product.save(function (err, product, numberAffected) {\n      if (err) ..\n    })\n"
      },
      {
        "type": "description",
        "string": "The callback will receive three parameters, `err` if an error occurred, `product` which is the saved `product`, and `numberAffected` which will be 1 when the document was found and updated in the database, otherwise 0. \nThe `fn` callback is optional. If no `fn` is passed and validation fails, the validation error will be emitted on the connection used to create this model."
      },
      {
        "type": "example:",
        "string": "    var db = mongoose.createConnection(..);\n    var schema = new Schema(..);\n    var Product = db.model('Product', schema);\n\n    db.on('error', handleError);\n"
      },
      {
        "type": "description",
        "string": "However, if you desire more local error handling you can add an `error` listener to the model and handle errors there instead."
      },
      {
        "type": "example:",
        "string": "    Product.on('error', handleError);\n"
      },
      {
        "type": "description",
        "string": "As an extra measure of flow control, save will return a Promise (bound to `fn` if passed) so it could be chained, or hook to recive errors"
      },
      {
        "type": "example:",
        "string": "    product.save().then(function (product, numberAffected) {\n       ...\n    }).onRejected(function (err) {\n       assert.ok(err)\n    })\n"
      },
      {
        "type": "param",
        "types": [
          "function(err",
          ""
        ],
        "name": "product,",
        "description": "Number)} [done] optional callback",
        "optional": false
      },
      {
        "type": "return",
        "types": [
          "Promise"
        ],
        "description": "Promise"
      },
      {
        "type": "api",
        "visibility": "public"
      },
      {
        "type": "see",
        "title": "middleware",
        "url": "http://mongoosejs.com/docs/middleware.html"
      }
    ],
    "description": {
      "full": "",
      "summary": "",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 1333,
    "codeStart": 1370,
    "code": "Document.prototype.save = function ( done ) {\n  var self = this;\n  var finalPromise = new $.Deferred().done( done );\n\n  // Сохранять документ можно только если он находится в коллекции\n  if ( !this.collection ){\n    finalPromise.reject( arguments );\n    console.error('Document.save api handle is not implemented.');\n    return finalPromise;\n  }\n\n  // Check for preSave errors (точо знаю, что она проверяет ошибки в массивах (CastError))\n  var preSaveErr = self.$__presaveValidate();\n  if ( preSaveErr ) {\n    finalPromise.reject( preSaveErr );\n    return finalPromise;\n  }\n\n  // Validate\n  var p0 = new $.Deferred();\n  self.validate(function( err ){\n    if ( err ){\n      p0.reject( err );\n      finalPromise.reject( err );\n    } else {\n      p0.resolve();\n    }\n  });\n\n  // Сначала надо сохранить все поддокументы и сделать resolve!!!\n  // Call save hooks on subdocs\n  var subDocs = self.$__getAllSubdocs();\n  var whenCond = subDocs.map(function (d) {return d.save();});\n  whenCond.push( p0 );\n\n  // Так мы передаём массив promise условий\n  var p1 = $.when.apply( $, whenCond );\n\n  // Handle save and results\n  p1\n    .then( this.$__handleSave.bind( this ) )\n    .then(function(){\n      return finalPromise.resolve( self );\n    }, function ( err ) {\n      // If the initial insert fails provide a second chance.\n      // (If we did this all the time we would break updates)\n      if (self.$__.inserting) {\n        self.isNew = true;\n        self.emit('isNew', true);\n      }\n      finalPromise.reject( err );\n    });\n\n  return finalPromise;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Document",
      "cons": "Document",
      "name": "save",
      "string": "Document.prototype.save()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "[options]",
        "description": "",
        "optional": true
      },
      {
        "type": "return",
        "types": [
          "Object"
        ],
        "description": "js object"
      },
      {
        "type": "see",
        "title": "mongodb.Binary",
        "url": "http://mongodb.github.com/node-mongodb-native/api-bson-generated/binary.html"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Converts this document into a plain javascript object, ready for storage in MongoDB.</p><p>Buffers are converted to instances of <a href=\"http://mongodb.github.com/node-mongodb-native/api-bson-generated/binary.html\">mongodb.Binary</a> for proper storage.</p><h4>Options:</h4>\n<ul>\n<li><code>getters</code> apply all getters (path and virtual getters)</li>\n<li><code>virtuals</code> apply virtual getters (can override <code>getters</code> option)</li>\n<li><code>minimize</code> remove empty objects (defaults to true)</li>\n<li><code>transform</code> a transform function to apply to the resulting document before returning</li>\n</ul>\n<h4>Getters/Virtuals</h4>\n<p>Example of only applying path getters</p><pre><code>doc.toObject({ getters: true, virtuals: false })\n</code></pre><p>Example of only applying virtual getters</p><pre><code>doc.toObject({ virtuals: true })\n</code></pre><p>Example of applying both path and virtual getters</p><pre><code>doc.toObject({ getters: true })\n</code></pre><p>To apply these options to every document of your schema by default, set your <a href=\"#schema_Schema\">schemas</a> <code>toObject</code> option to the same argument.</p><pre><code>schema.set(&#39;toObject&#39;, { virtuals: true })\n</code></pre><h4>Transform</h4>\n<p>We may need to perform a transformation of the resulting object based on some criteria, say to remove some sensitive information or return a custom object. In this case we set the optional <code>transform</code> function.</p><p>Transform functions receive three arguments</p><pre><code>function (doc, ret, options) {}\n</code></pre><ul>\n<li><code>doc</code> The mongoose document which is being converted</li>\n<li><code>ret</code> The plain object representation which has been converted</li>\n<li><code>options</code> The options in use (either schema options or the options passed inline)</li>\n</ul>\n<h4>Example</h4>\n<pre><code>// specify the transform schema option\nif (!schema.options.toObject) schema.options.toObject = {};\nschema.options.toObject.transform = function (doc, ret, options) {\n  // remove the _id of every document before returning the result\n  delete ret._id;\n}\n\n// without the transformation in the schema\ndoc.toObject(); // { _id: &#39;anId&#39;, name: &#39;Wreck-it Ralph&#39; }\n\n// with the transformation\ndoc.toObject(); // { name: &#39;Wreck-it Ralph&#39; }\n</code></pre><p>With transformations we can do a lot more than remove properties. We can even return completely new customized objects:</p><pre><code>if (!schema.options.toObject) schema.options.toObject = {};\nschema.options.toObject.transform = function (doc, ret, options) {\n  return { movie: ret.name }\n}\n\n// without the transformation in the schema\ndoc.toObject(); // { _id: &#39;anId&#39;, name: &#39;Wreck-it Ralph&#39; }\n\n// with the transformation\ndoc.toObject(); // { movie: &#39;Wreck-it Ralph&#39; }\n</code></pre><p><em>Note: if a transform function returns <code>undefined</code>, the return value will be ignored.</em></p><p>Transformations may also be applied inline, overridding any transform set in the options:</p><pre><code>function xform (doc, ret, options) {\n  return { inline: ret.name, custom: true }\n}\n\n// pass the transform as an inline option\ndoc.toObject({ transform: xform }); // { inline: &#39;Wreck-it Ralph&#39;, custom: true }\n</code></pre><p><em>Note: if you call <code>toObject</code> and pass any options, the transform declared in your schema options will <strong>not</strong> be applied. To force its application pass <code>transform: true</code></em></p><pre><code>if (!schema.options.toObject) schema.options.toObject = {};\nschema.options.toObject.hide = &#39;_id&#39;;\nschema.options.toObject.transform = function (doc, ret, options) {\n  if (options.hide) {\n    options.hide.split(&#39; &#39;).forEach(function (prop) {\n      delete ret[prop];\n    });\n  }\n}\n\nvar doc = new Doc({ _id: &#39;anId&#39;, secret: 47, name: &#39;Wreck-it Ralph&#39; });\ndoc.toObject();                                        // { secret: 47, name: &#39;Wreck-it Ralph&#39; }\ndoc.toObject({ hide: &#39;secret _id&#39; });                  // { _id: &#39;anId&#39;, secret: 47, name: &#39;Wreck-it Ralph&#39; }\ndoc.toObject({ hide: &#39;secret _id&#39;, transform: true }); // { name: &#39;Wreck-it Ralph&#39; }\n</code></pre><p>Transforms are applied to the document <em>and each of its sub-documents</em>. To determine whether or not you are currently operating on a sub-document you might use the following guard:</p><pre><code>if (&#39;function&#39; == typeof doc.ownerDocument) {\n  // working with a sub doc\n}\n</code></pre><p>Transforms, like all of these options, are also available for <code>toJSON</code>.</p><p>See <a href=\"/docs/guide.html#toObject\">schema options</a> for some more details.</p><p><em>During save, no custom options are applied to the document before being sent to the database.</em></p>",
      "summary": "<p>Converts this document into a plain javascript object, ready for storage in MongoDB.</p>",
      "body": "<p>Buffers are converted to instances of <a href=\"http://mongodb.github.com/node-mongodb-native/api-bson-generated/binary.html\">mongodb.Binary</a> for proper storage.</p><h4>Options:</h4>\n<ul>\n<li><code>getters</code> apply all getters (path and virtual getters)</li>\n<li><code>virtuals</code> apply virtual getters (can override <code>getters</code> option)</li>\n<li><code>minimize</code> remove empty objects (defaults to true)</li>\n<li><code>transform</code> a transform function to apply to the resulting document before returning</li>\n</ul>\n<h4>Getters/Virtuals</h4>\n<p>Example of only applying path getters</p><pre><code>doc.toObject({ getters: true, virtuals: false })\n</code></pre><p>Example of only applying virtual getters</p><pre><code>doc.toObject({ virtuals: true })\n</code></pre><p>Example of applying both path and virtual getters</p><pre><code>doc.toObject({ getters: true })\n</code></pre><p>To apply these options to every document of your schema by default, set your <a href=\"#schema_Schema\">schemas</a> <code>toObject</code> option to the same argument.</p><pre><code>schema.set(&#39;toObject&#39;, { virtuals: true })\n</code></pre><h4>Transform</h4>\n<p>We may need to perform a transformation of the resulting object based on some criteria, say to remove some sensitive information or return a custom object. In this case we set the optional <code>transform</code> function.</p><p>Transform functions receive three arguments</p><pre><code>function (doc, ret, options) {}\n</code></pre><ul>\n<li><code>doc</code> The mongoose document which is being converted</li>\n<li><code>ret</code> The plain object representation which has been converted</li>\n<li><code>options</code> The options in use (either schema options or the options passed inline)</li>\n</ul>\n<h4>Example</h4>\n<pre><code>// specify the transform schema option\nif (!schema.options.toObject) schema.options.toObject = {};\nschema.options.toObject.transform = function (doc, ret, options) {\n  // remove the _id of every document before returning the result\n  delete ret._id;\n}\n\n// without the transformation in the schema\ndoc.toObject(); // { _id: &#39;anId&#39;, name: &#39;Wreck-it Ralph&#39; }\n\n// with the transformation\ndoc.toObject(); // { name: &#39;Wreck-it Ralph&#39; }\n</code></pre><p>With transformations we can do a lot more than remove properties. We can even return completely new customized objects:</p><pre><code>if (!schema.options.toObject) schema.options.toObject = {};\nschema.options.toObject.transform = function (doc, ret, options) {\n  return { movie: ret.name }\n}\n\n// without the transformation in the schema\ndoc.toObject(); // { _id: &#39;anId&#39;, name: &#39;Wreck-it Ralph&#39; }\n\n// with the transformation\ndoc.toObject(); // { movie: &#39;Wreck-it Ralph&#39; }\n</code></pre><p><em>Note: if a transform function returns <code>undefined</code>, the return value will be ignored.</em></p><p>Transformations may also be applied inline, overridding any transform set in the options:</p><pre><code>function xform (doc, ret, options) {\n  return { inline: ret.name, custom: true }\n}\n\n// pass the transform as an inline option\ndoc.toObject({ transform: xform }); // { inline: &#39;Wreck-it Ralph&#39;, custom: true }\n</code></pre><p><em>Note: if you call <code>toObject</code> and pass any options, the transform declared in your schema options will <strong>not</strong> be applied. To force its application pass <code>transform: true</code></em></p><pre><code>if (!schema.options.toObject) schema.options.toObject = {};\nschema.options.toObject.hide = &#39;_id&#39;;\nschema.options.toObject.transform = function (doc, ret, options) {\n  if (options.hide) {\n    options.hide.split(&#39; &#39;).forEach(function (prop) {\n      delete ret[prop];\n    });\n  }\n}\n\nvar doc = new Doc({ _id: &#39;anId&#39;, secret: 47, name: &#39;Wreck-it Ralph&#39; });\ndoc.toObject();                                        // { secret: 47, name: &#39;Wreck-it Ralph&#39; }\ndoc.toObject({ hide: &#39;secret _id&#39; });                  // { _id: &#39;anId&#39;, secret: 47, name: &#39;Wreck-it Ralph&#39; }\ndoc.toObject({ hide: &#39;secret _id&#39;, transform: true }); // { name: &#39;Wreck-it Ralph&#39; }\n</code></pre><p>Transforms are applied to the document <em>and each of its sub-documents</em>. To determine whether or not you are currently operating on a sub-document you might use the following guard:</p><pre><code>if (&#39;function&#39; == typeof doc.ownerDocument) {\n  // working with a sub doc\n}\n</code></pre><p>Transforms, like all of these options, are also available for <code>toJSON</code>.</p><p>See <a href=\"/docs/guide.html#toObject\">schema options</a> for some more details.</p><p><em>During save, no custom options are applied to the document before being sent to the database.</em></p>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 1427,
    "codeStart": 1542,
    "code": "Document.prototype.toObject = function (options) {\n  if (options && options.depopulate && this.$__.wasPopulated) {\n    // populated paths that we set to a document\n    return utils.clone(this._id, options);\n  }\n\n  // When internally saving this document we always pass options,\n  // bypassing the custom schema options.\n  var optionsParameter = options;\n  if (!(options && 'Object' == utils.getFunctionName(options.constructor)) ||\n    (options && options._useSchemaOptions)) {\n    options = this.schema.options.toObject\n      ? clone(this.schema.options.toObject)\n      : {};\n  }\n\n  if ( options.minimize === undefined ){\n    options.minimize = this.schema.options.minimize;\n  }\n\n  if (!optionsParameter) {\n    options._useSchemaOptions = true;\n  }\n\n  var ret = utils.clone(this._doc, options);\n\n  if (options.virtuals || options.getters && false !== options.virtuals) {\n    applyGetters(this, ret, 'virtuals', options);\n  }\n\n  if (options.getters) {\n    applyGetters(this, ret, 'paths', options);\n    // applyGetters for paths will add nested empty objects;\n    // if minimize is set, we need to remove them.\n    if (options.minimize) {\n      ret = minimize(ret) || {};\n    }\n  }\n\n  // In the case where a subdocument has its own transform function, we need to\n  // check and see if the parent has a transform (options.transform) and if the\n  // child schema has a transform (this.schema.options.toObject) In this case,\n  // we need to adjust options.transform to be the child schema's transform and\n  // not the parent schema's\n  if (true === options.transform ||\n      (this.schema.options.toObject && options.transform)) {\n    var opts = options.json\n      ? this.schema.options.toJSON\n      : this.schema.options.toObject;\n    if (opts) {\n      options.transform = opts.transform;\n    }\n  }\n\n  if ('function' == typeof options.transform) {\n    var xformed = options.transform(this, ret, options);\n    if ('undefined' != typeof xformed) ret = xformed;\n  }\n\n  return ret;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Document",
      "cons": "Document",
      "name": "toObject",
      "string": "Document.prototype.toObject()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "object",
        "description": "to minimize",
        "optional": false
      },
      {
        "type": "return",
        "types": [
          "Object"
        ],
        "description": ""
      }
    ],
    "description": {
      "full": "<p>Minimizes an object, removing undefined values and empty objects</p>",
      "summary": "<p>Minimizes an object, removing undefined values and empty objects</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 1604,
    "codeStart": 1611,
    "code": "function minimize (obj) {\n  var keys = Object.keys(obj)\n    , i = keys.length\n    , hasKeys\n    , key\n    , val;\n\n  while (i--) {\n    key = keys[i];\n    val = obj[key];\n\n    if ( _.isPlainObject(val) ) {\n      obj[key] = minimize(val);\n    }\n\n    if (undefined === obj[key]) {\n      delete obj[key];\n      continue;\n    }\n\n    hasKeys = true;\n  }\n\n  return hasKeys\n    ? obj\n    : undefined;\n}",
    "ctx": {
      "type": "function",
      "name": "minimize",
      "string": "minimize()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Document"
        ],
        "name": "self",
        "description": "",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "json",
        "description": "",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "type",
        "description": "either `virtuals` or `paths`",
        "optional": false
      },
      {
        "type": "return",
        "types": [
          "Object"
        ],
        "description": "`json`"
      }
    ],
    "description": {
      "full": "<p>Applies virtuals properties to <code>json</code>.</p>",
      "summary": "<p>Applies virtuals properties to <code>json</code>.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 1639,
    "codeStart": 1648,
    "code": "function applyGetters (self, json, type, options) {\n  var schema = self.schema\n    , paths = Object.keys(schema[type])\n    , i = paths.length\n    , path;\n\n  while (i--) {\n    path = paths[i];\n\n    var parts = path.split('.')\n      , plen = parts.length\n      , last = plen - 1\n      , branch = json\n      , part;\n\n    for (var ii = 0; ii < plen; ++ii) {\n      part = parts[ii];\n      if (ii === last) {\n        branch[part] = utils.clone(self.get(path), options);\n      } else {\n        branch = branch[part] || (branch[part] = {});\n      }\n    }\n  }\n\n  return json;\n}",
    "ctx": {
      "type": "function",
      "name": "applyGetters",
      "string": "applyGetters()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "options",
        "description": "",
        "optional": false
      },
      {
        "type": "return",
        "types": [
          "Object"
        ],
        "description": ""
      },
      {
        "type": "see",
        "local": "Document#toObject #document_Document-toObject"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>The return value of this method is used in calls to JSON.stringify(doc).</p><p>This method accepts the same options as <a href=\"#document_Document-toObject\">Document#toObject</a>. To apply the options to every document of your schema by default, set your <a href=\"#schema_Schema\">schemas</a> <code>toJSON</code> option to the same argument.</p><pre><code>schema.set(&#39;toJSON&#39;, { virtuals: true })\n</code></pre><p>See <a href=\"/docs/guide.html#toJSON\">schema options</a> for details.</p>",
      "summary": "<p>The return value of this method is used in calls to JSON.stringify(doc).</p>",
      "body": "<p>This method accepts the same options as <a href=\"#document_Document-toObject\">Document#toObject</a>. To apply the options to every document of your schema by default, set your <a href=\"#schema_Schema\">schemas</a> <code>toJSON</code> option to the same argument.</p><pre><code>schema.set(&#39;toJSON&#39;, { virtuals: true })\n</code></pre><p>See <a href=\"/docs/guide.html#toJSON\">schema options</a> for details.</p>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 1676,
    "codeStart": 1691,
    "code": "Document.prototype.toJSON = function (options) {\n  // check for object type since an array of documents\n  // being stringified passes array indexes instead\n  // of options objects. JSON.stringify([doc, doc])\n  // The second check here is to make sure that populated documents (or\n  // subdocuments) use their own options for `.toJSON()` instead of their\n  // parent's\n  if (!(options && 'Object' == utils.getFunctionName(options.constructor))\n      || ((!options || options.json) && this.schema.options.toJSON)) {\n\n    options = this.schema.options.toJSON\n      ? utils.clone(this.schema.options.toJSON)\n      : {};\n  }\n  options.json = true;\n\n  return this.toObject(options);\n};",
    "ctx": {
      "type": "method",
      "constructor": "Document",
      "cons": "Document",
      "name": "toJSON",
      "string": "Document.prototype.toJSON()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Document"
        ],
        "name": "doc",
        "description": "a document to compare",
        "optional": false
      },
      {
        "type": "return",
        "types": [
          "Boolean"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Returns true if the Document stores the same data as doc.</p><p>Documents are considered equal when they have matching <code>_id</code>s, unless neither<br />document has an <code>_id</code>, in which case this function falls back to using<br /><code>deepEqual()</code>.</p>",
      "summary": "<p>Returns true if the Document stores the same data as doc.</p>",
      "body": "<p>Documents are considered equal when they have matching <code>_id</code>s, unless neither<br />document has an <code>_id</code>, in which case this function falls back to using<br /><code>deepEqual()</code>.</p>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 1710,
    "codeStart": 1722,
    "code": "Document.prototype.equals = function (doc) {\n  var tid = this.get('_id');\n  var docid = doc.get('_id');\n  if (!tid && !docid) {\n    return deepEqual(this, doc);\n  }\n  return tid && tid.equals\n    ? tid.equals(docid)\n    : tid === docid;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Document",
      "cons": "Document",
      "name": "equals",
      "string": "Document.prototype.equals()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "path",
        "description": "",
        "optional": false
      },
      {
        "type": "return",
        "types": [
          "Array",
          "ObjectId",
          "Number",
          "Buffer",
          "String",
          "undefined"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Gets _id(s) used during population of the given <code>path</code>.</p><h4>Example:</h4>\n<pre><code>Model.findOne().populate(&#39;author&#39;).exec(function (err, doc) {\n  console.log(doc.author.name)         // Dr.Seuss\n  console.log(doc.populated(&#39;author&#39;)) // &#39;5144cf8050f071d979c118a7&#39;\n})\n</code></pre><p>If the path was not populated, undefined is returned.</p>",
      "summary": "<p>Gets _id(s) used during population of the given <code>path</code>.</p>",
      "body": "<h4>Example:</h4>\n<pre><code>Model.findOne().populate(&#39;author&#39;).exec(function (err, doc) {\n  console.log(doc.author.name)         // Dr.Seuss\n  console.log(doc.populated(&#39;author&#39;)) // &#39;5144cf8050f071d979c118a7&#39;\n})\n</code></pre><p>If the path was not populated, undefined is returned.</p>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 1733,
    "codeStart": 1749,
    "code": "Document.prototype.populated = function (path, val, options) {\n  // val and options are internal\n\n  //TODO: доделать эту проверку, она должна опираться не на $__.populated, а на то, что наш объект имеет родителя\n  // и потом уже выставлять свойство populated == true\n  if (null == val) {\n    if (!this.$__.populated) return undefined;\n    var v = this.$__.populated[path];\n    if (v) return v.value;\n    return undefined;\n  }\n\n  // internal\n\n  if (true === val) {\n    if (!this.$__.populated) return undefined;\n    return this.$__.populated[path];\n  }\n\n  this.$__.populated || (this.$__.populated = {});\n  this.$__.populated[path] = { value: val, options: options };\n  return val;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Document",
      "cons": "Document",
      "name": "populated",
      "string": "Document.prototype.populated()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "[path]",
        "description": "",
        "optional": true
      },
      {
        "type": "return",
        "types": [
          "String"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "private"
      },
      {
        "type": "method",
        "string": "$__fullPath"
      },
      {
        "type": "memberOf",
        "parent": "Document"
      }
    ],
    "description": {
      "full": "<p>Returns the full path to this document.</p>",
      "summary": "<p>Returns the full path to this document.</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": false,
    "line": 1773,
    "codeStart": 1782,
    "code": "Document.prototype.$__fullPath = function (path) {\n  // overridden in SubDocuments\n  return path || '';\n};",
    "ctx": {
      "type": "method",
      "constructor": "Document",
      "cons": "Document",
      "name": "$__fullPath",
      "string": "Document.prototype.$__fullPath()"
    }
  },
  {
    "tags": [
      {
        "type": "example",
        "string": "storage.collection.document.remove();\ndocument.remove();\n"
      },
      {
        "type": "see",
        "local": "Collection.remove"
      },
      {
        "type": "returns",
        "types": [
          "boolean"
        ],
        "description": ""
      }
    ],
    "description": {
      "full": "<p>Удалить документ и вернуть коллекцию.</p>",
      "summary": "<p>Удалить документ и вернуть коллекцию.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 1787,
    "codeStart": 1797,
    "code": "Document.prototype.remove = function(){\n  if ( this.collection ){\n    return this.collection.remove( this );\n  }\n\n  return delete this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Document",
      "cons": "Document",
      "name": "remove",
      "string": "Document.prototype.remove()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Очищает документ (выставляет значение по умолчанию или undefined)</p>",
      "summary": "<p>Очищает документ (выставляет значение по умолчанию или undefined)</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 1806,
    "codeStart": 1809,
    "code": "Document.prototype.empty = function(){\n  var doc = this\n    , self = this\n    , paths = Object.keys( this.schema.paths )\n    , plen = paths.length\n    , ii = 0;\n\n  for ( ; ii < plen; ++ii ) {\n    var p = paths[ii];\n\n    if ( '_id' == p ) continue;\n\n    var type = this.schema.paths[ p ]\n      , path = p.split('.')\n      , len = path.length\n      , last = len - 1\n      , doc_ = doc\n      , i = 0;\n\n    for ( ; i < len; ++i ) {\n      var piece = path[ i ]\n        , defaultVal;\n\n      if ( i === last ) {\n        defaultVal = type.getDefault( self, true );\n\n        doc_[ piece ] = defaultVal || undefined;\n        self.$__.activePaths.default( p );\n      } else {\n        doc_ = doc_[ piece ] || ( doc_[ piece ] = {} );\n      }\n    }\n  }\n};",
    "ctx": {
      "type": "method",
      "constructor": "Document",
      "cons": "Document",
      "name": "empty",
      "string": "Document.prototype.empty()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Module exports.</p>",
      "summary": "<p>Module exports.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 1844,
    "codeStart": 1848,
    "code": "Document.ValidationError = ValidationError;\nmodule.exports = Document;",
    "ctx": {
      "type": "property",
      "receiver": "Document",
      "name": "ValidationError",
      "value": "ValidationError",
      "string": "Document.ValidationError"
    }
  }
]
### lib/error/cast.js
[
  {
    "tags": [],
    "description": {
      "full": "<p>Module dependencies.</p>",
      "summary": "<p>Module dependencies.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 1,
    "codeStart": 5,
    "code": "var StorageError = require('../error.js');",
    "ctx": {
      "type": "declaration",
      "name": "StorageError",
      "value": "require('../error.js')",
      "string": "StorageError"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "type",
        "description": "",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "value",
        "description": "",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "path",
        "description": "",
        "optional": false
      },
      {
        "type": "inherits",
        "string": "StorageError"
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Casting Error constructor.</p>",
      "summary": "<p>Casting Error constructor.</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": false,
    "line": 7,
    "codeStart": 17,
    "code": "function CastError (type, value, path) {\n  StorageError.call(this, 'Cast to ' + type + ' failed for value \"' + value + '\" at path \"' + path + '\"');\n  this.name = 'CastError';\n  this.type = type;\n  this.value = value;\n  this.path = path;\n}",
    "ctx": {
      "type": "function",
      "name": "CastError",
      "string": "CastError()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Inherits from StorageError.</p>",
      "summary": "<p>Inherits from StorageError.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 25,
    "codeStart": 28,
    "code": "CastError.prototype = Object.create( StorageError.prototype );\nCastError.prototype.constructor = CastError;",
    "ctx": {
      "type": "property",
      "receiver": "CastError",
      "name": "prototype",
      "value": "Object.create( StorageError.prototype )",
      "string": "CastError.prototype"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>exports</p>",
      "summary": "<p>exports</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 31,
    "codeStart": 35,
    "code": "module.exports = CastError;",
    "ctx": {
      "type": "property",
      "receiver": "module",
      "name": "exports",
      "value": "CastError",
      "string": "module.exports"
    }
  }
]
### lib/error/messages.js
[
  {
    "tags": [
      {
        "type": "property",
        "types": [
          "messages"
        ],
        "name": "",
        "description": "",
        "optional": false
      },
      {
        "type": "receiver",
        "string": "StorageError"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>The default built-in validator error messages. These may be customized.</p><pre><code>// customize within each schema or globally like so\nvar mongoose = require(&#39;mongoose&#39;);\nmongoose.Error.messages.String.enum  = &quot;Your custom message for {PATH}.&quot;;\n</code></pre><p>As you might have noticed, error messages support basic templating</p><ul>\n<li><code>{PATH}</code> is replaced with the invalid document path</li>\n<li><code>{VALUE}</code> is replaced with the invalid value</li>\n<li><code>{TYPE}</code> is replaced with the validator type such as &quot;regexp&quot;, &quot;min&quot;, or &quot;user defined&quot;</li>\n<li><code>{MIN}</code> is replaced with the declared min value for the Number.min validator</li>\n<li><code>{MAX}</code> is replaced with the declared max value for the Number.max validator</li>\n</ul>\n<p>Click the &quot;show code&quot; link below to see all defaults.</p>",
      "summary": "<p>The default built-in validator error messages. These may be customized.</p>",
      "body": "<pre><code>// customize within each schema or globally like so\nvar mongoose = require(&#39;mongoose&#39;);\nmongoose.Error.messages.String.enum  = &quot;Your custom message for {PATH}.&quot;;\n</code></pre><p>As you might have noticed, error messages support basic templating</p><ul>\n<li><code>{PATH}</code> is replaced with the invalid document path</li>\n<li><code>{VALUE}</code> is replaced with the invalid value</li>\n<li><code>{TYPE}</code> is replaced with the validator type such as &quot;regexp&quot;, &quot;min&quot;, or &quot;user defined&quot;</li>\n<li><code>{MIN}</code> is replaced with the declared min value for the Number.min validator</li>\n<li><code>{MAX}</code> is replaced with the declared max value for the Number.max validator</li>\n</ul>\n<p>Click the &quot;show code&quot; link below to see all defaults.</p>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 2,
    "codeStart": 24,
    "code": "var msg = module.exports = {};\n\nmsg.general = {};\nmsg.general.default = \"Validator failed for path `{PATH}` with value `{VALUE}`\";\nmsg.general.required = \"Path `{PATH}` is required.\";\n\nmsg.Number = {};\nmsg.Number.min = \"Path `{PATH}` ({VALUE}) is less than minimum allowed value ({MIN}).\";\nmsg.Number.max = \"Path `{PATH}` ({VALUE}) is more than maximum allowed value ({MAX}).\";\n\nmsg.String = {};\nmsg.String.enum = \"`{VALUE}` is not a valid enum value for path `{PATH}`.\";\nmsg.String.match = \"Path `{PATH}` is invalid ({VALUE}).\";",
    "ctx": {
      "type": "declaration",
      "name": "msg",
      "value": "module.exports = {}",
      "string": "msg"
    }
  }
]
### lib/error/missingSchema.js
[
  {
    "tags": [],
    "description": {
      "full": "<p>Module dependencies.</p>",
      "summary": "<p>Module dependencies.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 1,
    "codeStart": 5,
    "code": "var StorageError = require('../error.js');",
    "ctx": {
      "type": "declaration",
      "name": "StorageError",
      "value": "require('../error.js')",
      "string": "StorageError"
    }
  },
  {
    "tags": [
      {
        "type": "inherits",
        "string": "StorageError"
      }
    ],
    "description": {
      "full": "<p>MissingSchema Error constructor.</p>",
      "summary": "<p>MissingSchema Error constructor.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 7,
    "codeStart": 13,
    "code": "function MissingSchemaError(){\n  var msg = 'Schema hasn\\'t been registered for document.\\n'\n    + 'Use storage.Document(name, schema)';\n  StorageError.call(this, msg);\n\n  this.name = 'MissingSchemaError';\n}\n\n/*!\n * Inherits from StorageError.\n */\n\nMissingSchemaError.prototype = Object.create(StorageError.prototype);\nMissingSchemaError.prototype.constructor = StorageError;\n\n/*!\n * exports\n */\n\nmodule.exports = MissingSchemaError;",
    "ctx": {
      "type": "function",
      "name": "MissingSchemaError",
      "string": "MissingSchemaError()"
    }
  }
]
### lib/error/validation.js
[
  {
    "tags": [],
    "description": {
      "full": "<p>Module requirements</p>",
      "summary": "<p>Module requirements</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 2,
    "codeStart": 6,
    "code": "var StorageError = require('../error.js');",
    "ctx": {
      "type": "declaration",
      "name": "StorageError",
      "value": "require('../error.js')",
      "string": "StorageError"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      },
      {
        "type": "param",
        "types": [
          "Document"
        ],
        "name": "instance",
        "description": "",
        "optional": false
      },
      {
        "type": "inherits",
        "string": "StorageError"
      }
    ],
    "description": {
      "full": "<p>Document Validation Error</p>",
      "summary": "<p>Document Validation Error</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": false,
    "line": 8,
    "codeStart": 16,
    "code": "function ValidationError (instance) {\n  StorageError.call(this, \"Validation failed\");\n  this.name = 'ValidationError';\n  this.errors = instance.errors = {};\n}",
    "ctx": {
      "type": "function",
      "name": "ValidationError",
      "string": "ValidationError()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Inherits from StorageError.</p>",
      "summary": "<p>Inherits from StorageError.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 22,
    "codeStart": 25,
    "code": "ValidationError.prototype = Object.create( StorageError.prototype );\nValidationError.prototype.constructor = ValidationError;",
    "ctx": {
      "type": "property",
      "receiver": "ValidationError",
      "name": "prototype",
      "value": "Object.create( StorageError.prototype )",
      "string": "ValidationError.prototype"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Module exports</p>",
      "summary": "<p>Module exports</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 28,
    "codeStart": 32,
    "code": "module.exports = ValidationError;",
    "ctx": {
      "type": "property",
      "receiver": "module",
      "name": "exports",
      "value": "ValidationError",
      "string": "module.exports"
    }
  }
]
### lib/error/validator.js
[
  {
    "tags": [],
    "description": {
      "full": "<p>Module dependencies.</p>",
      "summary": "<p>Module dependencies.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 1,
    "codeStart": 5,
    "code": "var StorageError = require('../error.js');\nvar errorMessages = StorageError.messages;",
    "ctx": {
      "type": "declaration",
      "name": "StorageError",
      "value": "require('../error.js')",
      "string": "StorageError"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "path",
        "description": "",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "msg",
        "description": "",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "String",
          "Number",
          "any"
        ],
        "name": "val",
        "description": "",
        "optional": false
      },
      {
        "type": "inherits",
        "string": "StorageError"
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Schema validator error</p>",
      "summary": "<p>Schema validator error</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": false,
    "line": 8,
    "codeStart": 18,
    "code": "function ValidatorError (path, msg, type, val) {\n  if (!msg) msg = errorMessages.general.default;\n  var message = this.formatMessage(msg, path, type, val);\n  StorageError.call(this, message);\n  this.name = 'ValidatorError';\n  this.path = path;\n  this.type = type;\n  this.value = val;\n}",
    "ctx": {
      "type": "function",
      "name": "ValidatorError",
      "string": "ValidatorError()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>toString helper</p>",
      "summary": "<p>toString helper</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 28,
    "codeStart": 32,
    "code": "ValidatorError.prototype.toString = function () {\n  return this.message;\n}",
    "ctx": {
      "type": "method",
      "constructor": "ValidatorError",
      "cons": "ValidatorError",
      "name": "toString",
      "string": "ValidatorError.prototype.toString()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Inherits from StorageError</p>",
      "summary": "<p>Inherits from StorageError</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 36,
    "codeStart": 39,
    "code": "ValidatorError.prototype = Object.create( StorageError.prototype );\nValidatorError.prototype.constructor = ValidatorError;",
    "ctx": {
      "type": "property",
      "receiver": "ValidatorError",
      "name": "prototype",
      "value": "Object.create( StorageError.prototype )",
      "string": "ValidatorError.prototype"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>exports</p>",
      "summary": "<p>exports</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 42,
    "codeStart": 46,
    "code": "module.exports = ValidatorError;",
    "ctx": {
      "type": "property",
      "receiver": "module",
      "name": "exports",
      "value": "ValidatorError",
      "string": "module.exports"
    }
  }
]
### lib/error.js
[
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "msg",
        "description": "- Error message",
        "optional": false
      },
      {
        "type": "inherits",
        "string": "Error https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error http://stackoverflow.com/questions/783818/how-do-i-create-a-custom-error-in-javascript"
      }
    ],
    "description": {
      "full": "<p>StorageError constructor</p>",
      "summary": "<p>StorageError constructor</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 2,
    "codeStart": 9,
    "code": "function StorageError ( msg ) {\n  this.message = msg;\n  this.name = 'StorageError';\n}\nStorageError.prototype = new Error();",
    "ctx": {
      "type": "function",
      "name": "StorageError",
      "string": "StorageError()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Formats error messages</p>",
      "summary": "<p>Formats error messages</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 16,
    "codeStart": 19,
    "code": "StorageError.prototype.formatMessage = function (msg, path, type, val) {\n  if (!msg) throw new TypeError('message is required');\n\n  return msg.replace(/{PATH}/, path)\n            .replace(/{VALUE}/, String(val||''))\n            .replace(/{TYPE}/, type || 'declared type');\n};",
    "ctx": {
      "type": "method",
      "constructor": "StorageError",
      "cons": "StorageError",
      "name": "formatMessage",
      "string": "StorageError.prototype.formatMessage()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Module exports.</p>",
      "summary": "<p>Module exports.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 27,
    "codeStart": 31,
    "code": "module.exports = StorageError;",
    "ctx": {
      "type": "property",
      "receiver": "module",
      "name": "exports",
      "value": "StorageError",
      "string": "module.exports"
    }
  },
  {
    "tags": [
      {
        "type": "see",
        "local": "Error.messages #error_messages_StorageError-messages"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>The default built-in validator error messages.</p>",
      "summary": "<p>The default built-in validator error messages.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 33,
    "codeStart": 40,
    "code": "StorageError.messages = require('./error/messages');",
    "ctx": {
      "type": "property",
      "receiver": "StorageError",
      "name": "messages",
      "value": "require('./error/messages')",
      "string": "StorageError.messages"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Expose subclasses</p>",
      "summary": "<p>Expose subclasses</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 42,
    "codeStart": 46,
    "code": "StorageError.CastError = require('./error/cast');\nStorageError.ValidationError = require('./error/validation');\nStorageError.ValidatorError = require('./error/validator');\n//todo:\n//StorageError.VersionError = require('./error/version');\n//StorageError.OverwriteModelError = require('./error/overwriteModel');\nStorageError.MissingSchemaError = require('./error/missingSchema');\n//StorageError.DivergentArrayError = require('./error/divergentArray');",
    "ctx": {
      "type": "property",
      "receiver": "StorageError",
      "name": "CastError",
      "value": "require('./error/cast')",
      "string": "StorageError.CastError"
    }
  }
]
### lib/events.js
[
  {
    "tags": [],
    "description": {
      "full": "<p>Backbone.Events</p><p>A module that can be mixed in to <em>any object</em> in order to provide it with<br />custom events. You may bind with <code>on</code> or remove with <code>off</code> callback<br />functions to an event; <code>trigger</code>-ing an event fires all callbacks in<br />succession.</p><p>var object = {};<br />_.extend(object, Events.prototype);<br />object.on(&#39;expand&#39;, function(){ alert(&#39;expanded&#39;); });<br />object.trigger(&#39;expand&#39;);</p>",
      "summary": "<p>Backbone.Events</p>",
      "body": "<p>A module that can be mixed in to <em>any object</em> in order to provide it with<br />custom events. You may bind with <code>on</code> or remove with <code>off</code> callback<br />functions to an event; <code>trigger</code>-ing an event fires all callbacks in<br />succession.</p><p>var object = {};<br />_.extend(object, Events.prototype);<br />object.on(&#39;expand&#39;, function(){ alert(&#39;expanded&#39;); });<br />object.trigger(&#39;expand&#39;);</p>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 1,
    "codeStart": 15,
    "code": "function Events() {}\n\nEvents.prototype = {",
    "ctx": {
      "type": "function",
      "name": "Events",
      "string": "Events()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "name"
        ],
        "name": "",
        "description": "",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "callback"
        ],
        "name": "",
        "description": "",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "context"
        ],
        "name": "",
        "description": "",
        "optional": false
      },
      {
        "type": "returns",
        "types": [
          "Events"
        ],
        "description": ""
      }
    ],
    "description": {
      "full": "<p>Bind an event to a <code>callback</code> function. Passing <code>&quot;all&quot;</code> will bind<br />the callback to all events fired.</p>",
      "summary": "<p>Bind an event to a <code>callback</code> function. Passing <code>&quot;all&quot;</code> will bind<br />the callback to all events fired.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 18,
    "codeStart": 26,
    "code": "on: function(name, callback, context) {\n  if (!eventsApi(this, 'on', name, [callback, context]) || !callback) return this;\n  this._events || (this._events = {});\n  var events = this._events[name] || (this._events[name] = []);\n  events.push({callback: callback, context: context, ctx: context || this});\n  return this;\n},",
    "ctx": {
      "type": "method",
      "name": "on",
      "string": "on()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "name"
        ],
        "name": "",
        "description": "",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "callback"
        ],
        "name": "",
        "description": "",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "context"
        ],
        "name": "",
        "description": "",
        "optional": false
      },
      {
        "type": "returns",
        "types": [
          "Events"
        ],
        "description": ""
      }
    ],
    "description": {
      "full": "<p>Bind an event to only be triggered a single time. After the first time<br />the callback is invoked, it will be removed.</p>",
      "summary": "<p>Bind an event to only be triggered a single time. After the first time<br />the callback is invoked, it will be removed.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 34,
    "codeStart": 43,
    "code": "once: function(name, callback, context) {\n  if (!eventsApi(this, 'once', name, [callback, context]) || !callback) return this;\n  var self = this;\n  var once = _.once(function() {\n    self.off(name, once);\n    callback.apply(this, arguments);\n  });\n  once._callback = callback;\n  return this.on(name, once, context);\n},",
    "ctx": {
      "type": "method",
      "name": "once",
      "string": "once()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "name"
        ],
        "name": "",
        "description": "",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "callback"
        ],
        "name": "",
        "description": "",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "context"
        ],
        "name": "",
        "description": "",
        "optional": false
      },
      {
        "type": "returns",
        "types": [
          "Events"
        ],
        "description": ""
      }
    ],
    "description": {
      "full": "<p>Remove one or many callbacks. If <code>context</code> is null, removes all<br />callbacks with that function. If <code>callback</code> is null, removes all<br />callbacks for the event. If <code>name</code> is null, removes all bound<br />callbacks for all events.</p>",
      "summary": "<p>Remove one or many callbacks. If <code>context</code> is null, removes all<br />callbacks with that function. If <code>callback</code> is null, removes all<br />callbacks for the event. If <code>name</code> is null, removes all bound<br />callbacks for all events.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 54,
    "codeStart": 65,
    "code": "off: function(name, callback, context) {\n  var retain, ev, events, names, i, l, j, k;\n  if (!this._events || !eventsApi(this, 'off', name, [callback, context])) return this;\n  if (!name && !callback && !context) {\n    this._events = {};\n    return this;\n  }\n  names = name ? [name] : _.keys(this._events);\n  for (i = 0, l = names.length; i < l; i++) {\n    name = names[i];\n    if (events = this._events[name]) {\n      this._events[name] = retain = [];\n      if (callback || context) {\n        for (j = 0, k = events.length; j < k; j++) {\n          ev = events[j];\n          if ((callback && callback !== ev.callback && callback !== ev.callback._callback) ||\n            (context && context !== ev.context)) {\n            retain.push(ev);\n          }\n        }\n      }\n      if (!retain.length) delete this._events[name];\n    }\n  }\n\n  return this;\n},",
    "ctx": {
      "type": "method",
      "name": "off",
      "string": "off()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "name"
        ],
        "name": "",
        "description": "",
        "optional": false
      },
      {
        "type": "returns",
        "types": [
          "Events"
        ],
        "description": ""
      }
    ],
    "description": {
      "full": "<p>Trigger one or many events, firing all bound callbacks. Callbacks are<br />passed the same arguments as <code>trigger</code> is, apart from the event name<br />(unless you&#39;re listening on <code>&quot;all&quot;</code>, which will cause your callback to<br />receive the true name of the event as the first argument).</p>",
      "summary": "<p>Trigger one or many events, firing all bound callbacks. Callbacks are<br />passed the same arguments as <code>trigger</code> is, apart from the event name<br />(unless you&#39;re listening on <code>&quot;all&quot;</code>, which will cause your callback to<br />receive the true name of the event as the first argument).</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 93,
    "codeStart": 102,
    "code": "trigger: function(name) {\n  if (!this._events) return this;\n  var args = Array.prototype.slice.call(arguments, 1);\n  if (!eventsApi(this, 'trigger', name, args)) return this;\n  var events = this._events[name];\n  var allEvents = this._events.all;\n  if (events) triggerEvents(events, args);\n  if (allEvents) triggerEvents(allEvents, arguments);\n  return this;\n},",
    "ctx": {
      "type": "method",
      "name": "trigger",
      "string": "trigger()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "obj"
        ],
        "name": "",
        "description": "",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "name"
        ],
        "name": "",
        "description": "",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "callback"
        ],
        "name": "",
        "description": "",
        "optional": false
      },
      {
        "type": "returns",
        "types": [
          "Events"
        ],
        "description": ""
      }
    ],
    "description": {
      "full": "<p>Tell this object to stop listening to either specific events ... or<br />to every object it&#39;s currently listening to.</p>",
      "summary": "<p>Tell this object to stop listening to either specific events ... or<br />to every object it&#39;s currently listening to.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 113,
    "codeStart": 122,
    "code": "stopListening: function(obj, name, callback) {\n  var listeningTo = this._listeningTo;\n  if (!listeningTo) return this;\n  var remove = !name && !callback;\n  if (!callback && typeof name === 'object') callback = this;\n  if (obj) (listeningTo = {})[obj._listenId] = obj;\n  for (var id in listeningTo) {\n    obj = listeningTo[id];\n    obj.off(name, callback, this);\n    if (remove || _.isEmpty(obj._events)) delete this._listeningTo[id];\n  }\n  return this;\n}\n};\n\n// Regular expression used to split event strings.\nvar eventSplitter = /\\s+/;",
    "ctx": {
      "type": "method",
      "name": "stopListening",
      "string": "stopListening()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "obj"
        ],
        "name": "",
        "description": "",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "action"
        ],
        "name": "",
        "description": "",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "name"
        ],
        "name": "",
        "description": "",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "rest"
        ],
        "name": "",
        "description": "",
        "optional": false
      },
      {
        "type": "returns",
        "types": [
          "boolean"
        ],
        "description": ""
      }
    ],
    "description": {
      "full": "<p>Implement fancy features of the Events API such as multiple event<br />names <code>&quot;change blur&quot;</code> and jQuery-style event maps <code>{change: action}</code><br />in terms of the existing API.</p>",
      "summary": "<p>Implement fancy features of the Events API such as multiple event<br />names <code>&quot;change blur&quot;</code> and jQuery-style event maps <code>{change: action}</code><br />in terms of the existing API.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 140,
    "codeStart": 151,
    "code": "var eventsApi = function(obj, action, name, rest) {\n  if (!name) return true;\n\n  // Handle event maps.\n  if (typeof name === 'object') {\n    for (var key in name) {\n      obj[action].apply(obj, [key, name[key]].concat(rest));\n    }\n    return false;\n  }\n\n  // Handle space separated event names.\n  if (eventSplitter.test(name)) {\n    var names = name.split(eventSplitter);\n    for (var i = 0, l = names.length; i < l; i++) {\n      obj[action].apply(obj, [names[i]].concat(rest));\n    }\n    return false;\n  }\n\n  return true;\n};",
    "ctx": {
      "type": "function",
      "name": "eventsApi",
      "string": "eventsApi()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "events"
        ],
        "name": "",
        "description": "",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "args"
        ],
        "name": "",
        "description": "",
        "optional": false
      }
    ],
    "description": {
      "full": "<p>A difficult-to-believe, but optimized internal dispatch function for<br />triggering events. Tries to keep the usual cases speedy (most internal<br />Backbone events have 3 arguments).</p>",
      "summary": "<p>A difficult-to-believe, but optimized internal dispatch function for<br />triggering events. Tries to keep the usual cases speedy (most internal<br />Backbone events have 3 arguments).</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 174,
    "codeStart": 182,
    "code": "var triggerEvents = function(events, args) {\n  var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];\n  switch (args.length) {\n    case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;\n    case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;\n    case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;\n    case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;\n    default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args);\n  }\n};\n\nvar listenMethods = {listenTo: 'on', listenToOnce: 'once'};\n\n// Inversion-of-control versions of `on` and `once`. Tell *this* object to\n// listen to an event in another object ... keeping track of what it's\n// listening to.\n_.each(listenMethods, function(implementation, method) {\n  Events[method] = function(obj, name, callback) {\n    var listeningTo = this._listeningTo || (this._listeningTo = {});\n    var id = obj._listenId || (obj._listenId = _.uniqueId('l'));\n    listeningTo[id] = obj;\n    if (!callback && typeof name === 'object') callback = this;\n    obj[implementation](name, callback, this);\n    return this;\n  };\n});\n\nmodule.exports = Events;",
    "ctx": {
      "type": "function",
      "name": "triggerEvents",
      "string": "triggerEvents()"
    }
  }
]
### lib/index.js
[
  {
    "tags": [],
    "description": {
      "full": "<p>Storage documents using schema<br />inspired by mongoose 3.8.4 (fixed bugs for 3.8.15)</p><p>Storage implementation<br /><a href=\"http://docs.meteor.com/#selectors\">http://docs.meteor.com/#selectors</a><br /><a href=\"https://github.com/meteor/meteor/tree/master/packages/minimongo\">https://github.com/meteor/meteor/tree/master/packages/minimongo</a></p><p>browserify lib/ --standalone storage &gt; storage.js -d</p>",
      "summary": "<p>Storage documents using schema<br />inspired by mongoose 3.8.4 (fixed bugs for 3.8.15)</p>",
      "body": "<p>Storage implementation<br /><a href=\"http://docs.meteor.com/#selectors\">http://docs.meteor.com/#selectors</a><br /><a href=\"https://github.com/meteor/meteor/tree/master/packages/minimongo\">https://github.com/meteor/meteor/tree/master/packages/minimongo</a></p><p>browserify lib/ --standalone storage &gt; storage.js -d</p>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 1,
    "codeStart": 12,
    "code": "'use strict';"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Module dependencies.</p>",
      "summary": "<p>Module dependencies.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 14,
    "codeStart": 17,
    "code": "var Collection = require('./collection')\n  , Schema = require('./schema')\n  , SchemaType = require('./schematype')\n  , VirtualType = require('./virtualtype')\n  , Types = require('./types')\n  , Document = require('./document')\n  , utils = require('./utils')\n  , pkg = require('../package.json');",
    "ctx": {
      "type": "declaration",
      "name": "Collection",
      "value": "require('./collection')",
      "string": "Collection"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Storage constructor.</p><p>The exports object of the <code>storage</code> module is an instance of this class.<br />Most apps will only use this one instance.</p>",
      "summary": "<p>Storage constructor.</p>",
      "body": "<p>The exports object of the <code>storage</code> module is an instance of this class.<br />Most apps will only use this one instance.</p>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 27,
    "codeStart": 35,
    "code": "function Storage () {\n  this.collectionNames = [];\n}",
    "ctx": {
      "type": "function",
      "name": "Storage",
      "string": "Storage()"
    }
  },
  {
    "tags": [
      {
        "type": "example",
        "string": ""
      },
      {
        "type": "param",
        "types": [
          "string"
        ],
        "name": "name",
        "description": "",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "storage.Schema",
          "undefined"
        ],
        "name": "schema",
        "description": "",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "[api]",
        "description": "- ссылка на апи ресурс",
        "optional": true
      },
      {
        "type": "returns",
        "types": [
          "Collection",
          "undefined"
        ],
        "description": ""
      }
    ],
    "description": {
      "full": "<p>Create a collection and get it</p>",
      "summary": "<p>Create a collection and get it</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 39,
    "codeStart": 49,
    "code": "Storage.prototype.createCollection = function( name, schema, api ){\n  if ( this[ name ] ){\n    console.info('storage::collection: `' + name + '` already exist');\n    return this[ name ];\n  }\n\n  if ( 'Schema' !== utils.getFunctionName( schema.constructor ) ){\n    throw new TypeError('`schema` must be Schema instance');\n  }\n\n  this.collectionNames.push( name );\n\n  return this[ name ] = new Collection( name, schema, api );\n};",
    "ctx": {
      "type": "method",
      "constructor": "Storage",
      "cons": "Storage",
      "name": "createCollection",
      "string": "Storage.prototype.createCollection()"
    }
  },
  {
    "tags": [
      {
        "type": "returns",
        "types": [
          "Array.<string>"
        ],
        "description": "An array containing all collections in the storage."
      }
    ],
    "description": {
      "full": "<p>To obtain the names of the collections in an array</p>",
      "summary": "<p>To obtain the names of the collections in an array</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 64,
    "codeStart": 69,
    "code": "Storage.prototype.getCollectionNames = function(){\n  return this.collectionNames;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Storage",
      "cons": "Storage",
      "name": "getCollectionNames",
      "string": "Storage.prototype.getCollectionNames()"
    }
  },
  {
    "tags": [
      {
        "type": "method",
        "string": "Collection"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>The Storage Collection constructor</p>",
      "summary": "<p>The Storage Collection constructor</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 73,
    "codeStart": 79,
    "code": "Storage.prototype.Collection = Collection;",
    "ctx": {
      "type": "property",
      "constructor": "Storage",
      "cons": "Storage",
      "name": "Collection",
      "value": "Collection",
      "string": "Storage.prototype.Collection"
    }
  },
  {
    "tags": [
      {
        "type": "property",
        "types": [
          "version"
        ],
        "name": "",
        "description": "",
        "optional": false
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>The Storage version</p>",
      "summary": "<p>The Storage version</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 81,
    "codeStart": 87,
    "code": "Storage.prototype.version = pkg.version;",
    "ctx": {
      "type": "property",
      "constructor": "Storage",
      "cons": "Storage",
      "name": "version",
      "value": "pkg.version",
      "string": "Storage.prototype.version"
    }
  },
  {
    "tags": [
      {
        "type": "method",
        "string": "Schema"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>The Storage <a href=\"#schema_Schema\">Schema</a> constructor</p><h4>Example:</h4>\n<pre><code>var Schema = storage.Schema;\nvar CatSchema = new Schema(..);\n</code></pre>",
      "summary": "<p>The Storage <a href=\"#schema_Schema\">Schema</a> constructor</p>",
      "body": "<h4>Example:</h4>\n<pre><code>var Schema = storage.Schema;\nvar CatSchema = new Schema(..);\n</code></pre>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 89,
    "codeStart": 100,
    "code": "Storage.prototype.Schema = Schema;",
    "ctx": {
      "type": "property",
      "constructor": "Storage",
      "cons": "Storage",
      "name": "Schema",
      "value": "Schema",
      "string": "Storage.prototype.Schema"
    }
  },
  {
    "tags": [
      {
        "type": "method",
        "string": "SchemaType"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>The Storage <a href=\"#schematype_SchemaType\">SchemaType</a> constructor</p>",
      "summary": "<p>The Storage <a href=\"#schematype_SchemaType\">SchemaType</a> constructor</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 102,
    "codeStart": 108,
    "code": "Storage.prototype.SchemaType = SchemaType;",
    "ctx": {
      "type": "property",
      "constructor": "Storage",
      "cons": "Storage",
      "name": "SchemaType",
      "value": "SchemaType",
      "string": "Storage.prototype.SchemaType"
    }
  },
  {
    "tags": [
      {
        "type": "property",
        "types": [
          "SchemaTypes"
        ],
        "name": "",
        "description": "",
        "optional": false
      },
      {
        "type": "see",
        "local": "Schema.SchemaTypes #schema_Schema.Types"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>The various Storage SchemaTypes.</p><h4>Note:</h4>\n<p><em>Alias of storage.Schema.Types for backwards compatibility.</em></p>",
      "summary": "<p>The various Storage SchemaTypes.</p>",
      "body": "<h4>Note:</h4>\n<p><em>Alias of storage.Schema.Types for backwards compatibility.</em></p>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 110,
    "codeStart": 121,
    "code": "Storage.prototype.SchemaTypes = Schema.Types;",
    "ctx": {
      "type": "property",
      "constructor": "Storage",
      "cons": "Storage",
      "name": "SchemaTypes",
      "value": "Schema.Types",
      "string": "Storage.prototype.SchemaTypes"
    }
  },
  {
    "tags": [
      {
        "type": "method",
        "string": "VirtualType"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>The Storage <a href=\"#virtualtype_VirtualType\">VirtualType</a> constructor</p>",
      "summary": "<p>The Storage <a href=\"#virtualtype_VirtualType\">VirtualType</a> constructor</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 123,
    "codeStart": 129,
    "code": "Storage.prototype.VirtualType = VirtualType;",
    "ctx": {
      "type": "property",
      "constructor": "Storage",
      "cons": "Storage",
      "name": "VirtualType",
      "value": "VirtualType",
      "string": "Storage.prototype.VirtualType"
    }
  },
  {
    "tags": [
      {
        "type": "property",
        "types": [
          "Types"
        ],
        "name": "",
        "description": "",
        "optional": false
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>The various Storage Types.</p><h4>Example:</h4>\n<pre><code>var array = storage.Types.Array;\n</code></pre><h4>Types:</h4>\n<ul>\n<li><a href=\"#types-objectid-js\">ObjectId</a></li>\n<li><a href=\"#types-buffer-js\">Buffer</a></li>\n<li><a href=\"#types-embedded-js\">SubDocument</a></li>\n<li><a href=\"#types-array-js\">Array</a></li>\n<li><a href=\"#types-documentarray-js\">DocumentArray</a></li>\n</ul>\n<p>Using this exposed access to the <code>ObjectId</code> type, we can construct ids on demand.</p><pre><code>var ObjectId = storage.Types.ObjectId;\nvar id1 = new ObjectId;\n</code></pre>",
      "summary": "<p>The various Storage Types.</p>",
      "body": "<h4>Example:</h4>\n<pre><code>var array = storage.Types.Array;\n</code></pre><h4>Types:</h4>\n<ul>\n<li><a href=\"#types-objectid-js\">ObjectId</a></li>\n<li><a href=\"#types-buffer-js\">Buffer</a></li>\n<li><a href=\"#types-embedded-js\">SubDocument</a></li>\n<li><a href=\"#types-array-js\">Array</a></li>\n<li><a href=\"#types-documentarray-js\">DocumentArray</a></li>\n</ul>\n<p>Using this exposed access to the <code>ObjectId</code> type, we can construct ids on demand.</p><pre><code>var ObjectId = storage.Types.ObjectId;\nvar id1 = new ObjectId;\n</code></pre>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 131,
    "codeStart": 154,
    "code": "Storage.prototype.Types = Types;",
    "ctx": {
      "type": "property",
      "constructor": "Storage",
      "cons": "Storage",
      "name": "Types",
      "value": "Types",
      "string": "Storage.prototype.Types"
    }
  },
  {
    "tags": [
      {
        "type": "method",
        "string": "Document"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>The Storage <a href=\"#document-js\">Document</a> constructor.</p>",
      "summary": "<p>The Storage <a href=\"#document-js\">Document</a> constructor.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 156,
    "codeStart": 162,
    "code": "Storage.prototype.Document = Document;",
    "ctx": {
      "type": "property",
      "constructor": "Storage",
      "cons": "Storage",
      "name": "Document",
      "value": "Document",
      "string": "Storage.prototype.Document"
    }
  },
  {
    "tags": [
      {
        "type": "method",
        "string": "Error"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>The <a href=\"#error_StorageError\">StorageError</a> constructor.</p>",
      "summary": "<p>The <a href=\"#error_StorageError\">StorageError</a> constructor.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 164,
    "codeStart": 170,
    "code": "Storage.prototype.Error = require('./error');\n\n\n\nStorage.prototype.StateMachine = require('./statemachine');\nStorage.prototype.utils = utils;\nStorage.prototype.ObjectId = Types.ObjectId;\nStorage.prototype.schemas = Schema.schemas;\n\nStorage.prototype.setAdapter = function( adapterHooks ){\n  Document.prototype.adapterHooks = adapterHooks;\n};",
    "ctx": {
      "type": "property",
      "constructor": "Storage",
      "cons": "Storage",
      "name": "Error",
      "value": "require('./error')",
      "string": "Storage.prototype.Error"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>The exports object is an instance of Storage.</p>",
      "summary": "<p>The exports object is an instance of Storage.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 184,
    "codeStart": 189,
    "code": "module.exports = new Storage;\n\nwindow.Buffer = Buffer;",
    "ctx": {
      "type": "property",
      "receiver": "module",
      "name": "exports",
      "value": "new Storage",
      "string": "module.exports"
    }
  }
]
### lib/internal.js
[
  {
    "tags": [],
    "description": {
      "full": "<p>Dependencies</p>",
      "summary": "<p>Dependencies</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 5,
    "codeStart": 9,
    "code": "var StateMachine = require('./statemachine');\n\nvar ActiveRoster = StateMachine.ctor('require', 'modify', 'init', 'default');\n\nmodule.exports = InternalCache;\n\nfunction InternalCache () {\n  this.strictMode = undefined;\n  this.selected = undefined;\n  this.saveError = undefined;\n  this.validationError = undefined;\n  this.adhocPaths = undefined;\n  this.removing = undefined;\n  this.inserting = undefined;\n  this.version = undefined;\n  this.getters = {};\n  this._id = undefined;\n  this.populate = undefined; // what we want to populate in this doc\n  this.populated = undefined;// the _ids that have been populated\n  this.wasPopulated = false; // if this doc was the result of a population\n  this.scope = undefined;\n  this.activePaths = new ActiveRoster;\n\n  // embedded docs\n  this.ownerDocument = undefined;\n  this.fullPath = undefined;\n}",
    "ctx": {
      "type": "declaration",
      "name": "StateMachine",
      "value": "require('./statemachine')",
      "string": "StateMachine"
    }
  }
]
### lib/mpath.js
[
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "path",
        "description": "",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "o",
        "description": "",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "[special]",
        "description": "When this property name is present on any object in the path, walking will continue on the value of this property.",
        "optional": true
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "[map]",
        "description": "Optional function which receives each individual found value. The value returned from `map` is used in the original values place.",
        "optional": true
      }
    ],
    "description": {
      "full": "<p>Returns the value of object <code>o</code> at the given <code>path</code>.</p><h4>Example:</h4>\n<pre><code>var obj = {\n    comments: [\n        { title: &#39;exciting!&#39;, _doc: { title: &#39;great!&#39; }}\n      , { title: &#39;number dos&#39; }\n    ]\n}\n\nmpath.get(&#39;comments.0.title&#39;, o)         // &#39;exciting!&#39;\nmpath.get(&#39;comments.0.title&#39;, o, &#39;_doc&#39;) // &#39;great!&#39;\nmpath.get(&#39;comments.title&#39;, o)           // [&#39;exciting!&#39;, &#39;number dos&#39;]\n\n// summary\nmpath.get(path, o)\nmpath.get(path, o, special)\nmpath.get(path, o, map)\nmpath.get(path, o, special, map)\n</code></pre>",
      "summary": "<p>Returns the value of object <code>o</code> at the given <code>path</code>.</p>",
      "body": "<h4>Example:</h4>\n<pre><code>var obj = {\n    comments: [\n        { title: &#39;exciting!&#39;, _doc: { title: &#39;great!&#39; }}\n      , { title: &#39;number dos&#39; }\n    ]\n}\n\nmpath.get(&#39;comments.0.title&#39;, o)         // &#39;exciting!&#39;\nmpath.get(&#39;comments.0.title&#39;, o, &#39;_doc&#39;) // &#39;great!&#39;\nmpath.get(&#39;comments.title&#39;, o)           // [&#39;exciting!&#39;, &#39;number dos&#39;]\n\n// summary\nmpath.get(path, o)\nmpath.get(path, o, special)\nmpath.get(path, o, map)\nmpath.get(path, o, special, map)\n</code></pre>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 1,
    "codeStart": 29,
    "code": "exports.get = function (path, o, special, map) {\n  var lookup;\n\n  if ('function' == typeof special) {\n    if (special.length < 2) {\n      map = special;\n      special = undefined;\n    } else {\n      lookup = special;\n      special = undefined;\n    }\n  }\n\n  map || (map = K);\n\n  var parts = 'string' == typeof path\n    ? path.split('.')\n    : path;\n\n  if (!Array.isArray(parts)) {\n    throw new TypeError('Invalid `path`. Must be either string or array');\n  }\n\n  var obj = o\n    , part;\n\n  for (var i = 0; i < parts.length; ++i) {\n    part = parts[i];\n\n    if (Array.isArray(obj) && !/^\\d+$/.test(part)) {\n      // reading a property from the array items\n      var paths = parts.slice(i);\n\n      return obj.map(function (item) {\n        return item\n          ? exports.get(paths, item, special || lookup, map)\n          : map(undefined);\n      });\n    }\n\n    if (lookup) {\n      obj = lookup(obj, part);\n    } else {\n      obj = special && obj[special]\n        ? obj[special][part]\n        : obj[part];\n    }\n\n    if (!obj) return map(obj);\n  }\n\n  return map(obj);\n};",
    "ctx": {
      "type": "method",
      "receiver": "exports",
      "name": "get",
      "string": "exports.get()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "path",
        "description": "",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "*"
        ],
        "name": "val",
        "description": "",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "o",
        "description": "",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "[special]",
        "description": "When this property name is present on any object in the path, walking will continue on the value of this property.",
        "optional": true
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "[map]",
        "description": "Optional function which is passed each individual value before setting it. The value returned from `map` is used in the original values place.",
        "optional": true
      }
    ],
    "description": {
      "full": "<p>Sets the <code>val</code> at the given <code>path</code> of object <code>o</code>.</p>",
      "summary": "<p>Sets the <code>val</code> at the given <code>path</code> of object <code>o</code>.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 83,
    "codeStart": 93,
    "code": "exports.set = function (path, val, o, special, map, _copying) {\n  var lookup;\n\n  if ('function' == typeof special) {\n    if (special.length < 2) {\n      map = special;\n      special = undefined;\n    } else {\n      lookup = special;\n      special = undefined;\n    }\n  }\n\n  map || (map = K);\n\n  var parts = 'string' == typeof path\n    ? path.split('.')\n    : path;\n\n  if (!Array.isArray(parts)) {\n    throw new TypeError('Invalid `path`. Must be either string or array');\n  }\n\n  if (null == o) return;\n\n  // the existance of $ in a path tells us if the user desires\n  // the copying of an array instead of setting each value of\n  // the array to the one by one to matching positions of the\n  // current array.\n  var copy = _copying || /\\$/.test(path)\n    , obj = o\n    , part;\n\n  for (var i = 0, len = parts.length - 1; i < len; ++i) {\n    part = parts[i];\n\n    if ('$' == part) {\n      if (i == len - 1) {\n        break;\n      } else {\n        continue;\n      }\n    }\n\n    if (Array.isArray(obj) && !/^\\d+$/.test(part)) {\n      var paths = parts.slice(i);\n      if (!copy && Array.isArray(val)) {\n        for (var j = 0; j < obj.length && j < val.length; ++j) {\n          // assignment of single values of array\n          exports.set(paths, val[j], obj[j], special || lookup, map, copy);\n        }\n      } else {\n        for (var j = 0; j < obj.length; ++j) {\n          // assignment of entire value\n          exports.set(paths, val, obj[j], special || lookup, map, copy);\n        }\n      }\n      return;\n    }\n\n    if (lookup) {\n      obj = lookup(obj, part);\n    } else {\n      obj = special && obj[special]\n        ? obj[special][part]\n        : obj[part];\n    }\n\n    if (!obj) return;\n  }\n\n  // process the last property of the path\n\n  part = parts[len];\n\n  // use the special property if exists\n  if (special && obj[special]) {\n    obj = obj[special];\n  }\n\n  // set the value on the last branch\n  if (Array.isArray(obj) && !/^\\d+$/.test(part)) {\n    if (!copy && Array.isArray(val)) {\n      for (var item, j = 0; j < obj.length && j < val.length; ++j) {\n        item = obj[j];\n        if (item) {\n          if (lookup) {\n            lookup(item, part, map(val[j]));\n          } else {\n            if (item[special]) item = item[special];\n            item[part] = map(val[j]);\n          }\n        }\n      }\n    } else {\n      for (var j = 0; j < obj.length; ++j) {\n        item = obj[j];\n        if (item) {\n          if (lookup) {\n            lookup(item, part, map(val));\n          } else {\n            if (item[special]) item = item[special];\n            item[part] = map(val);\n          }\n        }\n      }\n    }\n  } else {\n    if (lookup) {\n      lookup(obj, part, map(val));\n    } else {\n      obj[part] = map(val);\n    }\n  }\n};",
    "ctx": {
      "type": "method",
      "receiver": "exports",
      "name": "set",
      "string": "exports.set()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Returns the value passed to it.</p>",
      "summary": "<p>Returns the value passed to it.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 209,
    "codeStart": 213,
    "code": "function K (v) {\n  return v;\n}",
    "ctx": {
      "type": "function",
      "name": "K",
      "string": "K()"
    }
  }
]
### lib/schema/array.js
[
  {
    "tags": [],
    "description": {
      "full": "<p>Module dependencies.</p>",
      "summary": "<p>Module dependencies.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 1,
    "codeStart": 5,
    "code": "var SchemaType = require('../schematype')\n  , CastError = SchemaType.CastError\n  , Types = {\n        Boolean: require('./boolean')\n      , Date: require('./date')\n      , Number: require('./number')\n      , String: require('./string')\n      , ObjectId: require('./objectid')\n      , Buffer: require('./buffer')\n    }\n  , StorageArray = require('../types/array')\n  , Mixed = require('./mixed')\n  , utils = require('../utils')\n  , EmbeddedDoc;",
    "ctx": {
      "type": "declaration",
      "name": "SchemaType",
      "value": "require('../schematype')",
      "string": "SchemaType"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "key",
        "description": "",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "SchemaType"
        ],
        "name": "cast",
        "description": "",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "options",
        "description": "",
        "optional": false
      },
      {
        "type": "inherits",
        "string": "SchemaType"
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Array SchemaType constructor</p>",
      "summary": "<p>Array SchemaType constructor</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": false,
    "line": 20,
    "codeStart": 29,
    "code": "function SchemaArray (key, cast, options) {\n  if (cast) {\n    var castOptions = {};\n\n    if ('Object' === utils.getFunctionName( cast.constructor ) ) {\n      if (cast.type) {\n        // support { type: Woot }\n        castOptions = _.clone( cast ); // do not alter user arguments\n        delete castOptions.type;\n        cast = cast.type;\n      } else {\n        cast = Mixed;\n      }\n    }\n\n    // support { type: 'String' }\n    var name = 'string' == typeof cast\n      ? cast\n      : utils.getFunctionName( cast );\n\n    var caster = name in Types\n      ? Types[name]\n      : cast;\n\n    this.casterConstructor = caster;\n    this.caster = new caster(null, castOptions);\n\n    // lazy load\n    EmbeddedDoc || (EmbeddedDoc = require('../types/embedded'));\n\n    if (!(this.caster instanceof EmbeddedDoc)) {\n      this.caster.path = key;\n    }\n  }\n\n  SchemaType.call(this, key, options);\n\n  var self = this\n    , defaultArr\n    , fn;\n\n  if (this.defaultValue) {\n    defaultArr = this.defaultValue;\n    fn = 'function' == typeof defaultArr;\n  }\n\n  this.default(function(){\n    var arr = fn ? defaultArr() : defaultArr || [];\n    return new StorageArray(arr, self.path, this);\n  });\n}",
    "ctx": {
      "type": "function",
      "name": "SchemaArray",
      "string": "SchemaArray()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Inherits from SchemaType.</p>",
      "summary": "<p>Inherits from SchemaType.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 82,
    "codeStart": 85,
    "code": "SchemaArray.prototype = Object.create( SchemaType.prototype );\nSchemaArray.prototype.constructor = SchemaArray;",
    "ctx": {
      "type": "property",
      "receiver": "SchemaArray",
      "name": "prototype",
      "value": "Object.create( SchemaType.prototype )",
      "string": "SchemaArray.prototype"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Array"
        ],
        "name": "value",
        "description": "",
        "optional": false
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Check required</p>",
      "summary": "<p>Check required</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": false,
    "line": 88,
    "codeStart": 94,
    "code": "SchemaArray.prototype.checkRequired = function (value) {\n  return !!(value && value.length);\n};",
    "ctx": {
      "type": "method",
      "constructor": "SchemaArray",
      "cons": "SchemaArray",
      "name": "checkRequired",
      "string": "SchemaArray.prototype.checkRequired()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "value",
        "description": "",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "scope",
        "description": "",
        "optional": false
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Overrides the getters application for the population special-case</p>",
      "summary": "<p>Overrides the getters application for the population special-case</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": false,
    "line": 98,
    "codeStart": 105,
    "code": "SchemaArray.prototype.applyGetters = function (value, scope) {\n  if (this.caster.options && this.caster.options.ref) {\n    // means the object id was populated\n    return value;\n  }\n\n  return SchemaType.prototype.applyGetters.call(this, value, scope);\n};",
    "ctx": {
      "type": "method",
      "constructor": "SchemaArray",
      "cons": "SchemaArray",
      "name": "applyGetters",
      "string": "SchemaArray.prototype.applyGetters()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "value",
        "description": "",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "Document"
        ],
        "name": "doc",
        "description": "document that triggers the casting",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "Boolean"
        ],
        "name": "init",
        "description": "whether this is an initialization cast",
        "optional": false
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Casts values for set().</p>",
      "summary": "<p>Casts values for set().</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": false,
    "line": 114,
    "codeStart": 122,
    "code": "SchemaArray.prototype.cast = function ( value, doc, init ) {\n  if (Array.isArray(value)) {\n    if (!(value.isStorageArray)) {\n      value = new StorageArray(value, this.path, doc);\n    }\n\n    if (this.caster) {\n      try {\n        for (var i = 0, l = value.length; i < l; i++) {\n          value[i] = this.caster.cast(value[i], doc, init);\n        }\n      } catch (e) {\n        // rethrow\n        throw new CastError(e.type, value, this.path);\n      }\n    }\n\n    return value;\n  } else {\n    return this.cast([value], doc, init);\n  }\n};",
    "ctx": {
      "type": "method",
      "constructor": "SchemaArray",
      "cons": "SchemaArray",
      "name": "cast",
      "string": "SchemaArray.prototype.cast()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Module exports.</p>",
      "summary": "<p>Module exports.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 145,
    "codeStart": 149,
    "code": "module.exports = SchemaArray;",
    "ctx": {
      "type": "property",
      "receiver": "module",
      "name": "exports",
      "value": "SchemaArray",
      "string": "module.exports"
    }
  }
]
### lib/schema/boolean.js
[
  {
    "tags": [],
    "description": {
      "full": "<p>Module dependencies.</p>",
      "summary": "<p>Module dependencies.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 1,
    "codeStart": 5,
    "code": "var SchemaType = require('../schematype');",
    "ctx": {
      "type": "declaration",
      "name": "SchemaType",
      "value": "require('../schematype')",
      "string": "SchemaType"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "path",
        "description": "",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "options",
        "description": "",
        "optional": false
      },
      {
        "type": "inherits",
        "string": "SchemaType"
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Boolean SchemaType constructor.</p>",
      "summary": "<p>Boolean SchemaType constructor.</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": false,
    "line": 7,
    "codeStart": 15,
    "code": "function BooleanSchema (path, options) {\n  SchemaType.call(this, path, options);\n}",
    "ctx": {
      "type": "function",
      "name": "BooleanSchema",
      "string": "BooleanSchema()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Inherits from SchemaType.</p>",
      "summary": "<p>Inherits from SchemaType.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 19,
    "codeStart": 22,
    "code": "BooleanSchema.prototype = Object.create( SchemaType.prototype );\nBooleanSchema.prototype.constructor = BooleanSchema;",
    "ctx": {
      "type": "property",
      "receiver": "BooleanSchema",
      "name": "prototype",
      "value": "Object.create( SchemaType.prototype )",
      "string": "BooleanSchema.prototype"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Required validator</p>",
      "summary": "<p>Required validator</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": false,
    "line": 25,
    "codeStart": 30,
    "code": "BooleanSchema.prototype.checkRequired = function (value) {\n  return value === true || value === false;\n};",
    "ctx": {
      "type": "method",
      "constructor": "BooleanSchema",
      "cons": "BooleanSchema",
      "name": "checkRequired",
      "string": "BooleanSchema.prototype.checkRequired()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "value",
        "description": "",
        "optional": false
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Casts to boolean</p>",
      "summary": "<p>Casts to boolean</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": false,
    "line": 34,
    "codeStart": 40,
    "code": "BooleanSchema.prototype.cast = function (value) {\n  if (null === value) return value;\n  if ('0' === value) return false;\n  if ('true' === value) return true;\n  if ('false' === value) return false;\n  return !! value;\n};",
    "ctx": {
      "type": "method",
      "constructor": "BooleanSchema",
      "cons": "BooleanSchema",
      "name": "cast",
      "string": "BooleanSchema.prototype.cast()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Module exports.</p>",
      "summary": "<p>Module exports.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 48,
    "codeStart": 52,
    "code": "module.exports = BooleanSchema;",
    "ctx": {
      "type": "property",
      "receiver": "module",
      "name": "exports",
      "value": "BooleanSchema",
      "string": "module.exports"
    }
  }
]
### lib/schema/buffer.js
[
  {
    "tags": [],
    "description": {
      "full": "<p>Module dependencies.</p>",
      "summary": "<p>Module dependencies.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 1,
    "codeStart": 5,
    "code": "var SchemaType = require('../schematype')\n  , CastError = SchemaType.CastError\n  , StorageBuffer = require('../types').Buffer\n  , Binary = StorageBuffer.Binary\n  , utils = require('../utils')\n  , Document;",
    "ctx": {
      "type": "declaration",
      "name": "SchemaType",
      "value": "require('../schematype')",
      "string": "SchemaType"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "key",
        "description": "",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "SchemaType"
        ],
        "name": "cast",
        "description": "",
        "optional": false
      },
      {
        "type": "inherits",
        "string": "SchemaType"
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Buffer SchemaType constructor</p>",
      "summary": "<p>Buffer SchemaType constructor</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": false,
    "line": 12,
    "codeStart": 21,
    "code": "function SchemaBuffer (key, options) {\n  SchemaType.call(this, key, options, 'Buffer');\n}",
    "ctx": {
      "type": "function",
      "name": "SchemaBuffer",
      "string": "SchemaBuffer()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Inherits from SchemaType.</p>",
      "summary": "<p>Inherits from SchemaType.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 25,
    "codeStart": 28,
    "code": "SchemaBuffer.prototype = Object.create( SchemaType.prototype );\nSchemaBuffer.prototype.constructor = SchemaBuffer;",
    "ctx": {
      "type": "property",
      "receiver": "SchemaBuffer",
      "name": "prototype",
      "value": "Object.create( SchemaType.prototype )",
      "string": "SchemaBuffer.prototype"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Check required</p>",
      "summary": "<p>Check required</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": false,
    "line": 31,
    "codeStart": 37,
    "code": "SchemaBuffer.prototype.checkRequired = function (value, doc) {\n  if (SchemaType._isRef(this, value, doc, true)) {\n    return null != value;\n  } else {\n    return !!(value && value.length);\n  }\n};",
    "ctx": {
      "type": "method",
      "constructor": "SchemaBuffer",
      "cons": "SchemaBuffer",
      "name": "checkRequired",
      "string": "SchemaBuffer.prototype.checkRequired()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "value",
        "description": "",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "Document"
        ],
        "name": "doc",
        "description": "document that triggers the casting",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "Boolean"
        ],
        "name": "init",
        "description": "",
        "optional": false
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Casts contents</p>",
      "summary": "<p>Casts contents</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": false,
    "line": 45,
    "codeStart": 54,
    "code": "SchemaBuffer.prototype.cast = function (value, doc, init) {\n  if (SchemaType._isRef(this, value, doc, init)) {\n    // wait! we may need to cast this to a document\n\n    if (null == value) {\n      return value;\n    }\n\n    // lazy load\n    Document || (Document = require('./../document'));\n\n    if (value instanceof Document) {\n      value.$__.wasPopulated = true;\n      return value;\n    }\n\n    // setting a populated path\n    if (Buffer.isBuffer(value)) {\n      return value;\n    } else if (!_.isObject(value)) {\n      throw new CastError('buffer', value, this.path);\n    }\n\n    // Handle the case where user directly sets a populated\n    // path to a plain object; cast to the Model used in\n    // the population query.\n    var path = doc.$__fullPath(this.path);\n    var owner = doc.ownerDocument ? doc.ownerDocument() : doc;\n    var pop = owner.populated(path, true);\n    var ret = new pop.options.model(value);\n    ret.$__.wasPopulated = true;\n    return ret;\n  }\n\n  // documents\n  if (value && value._id) {\n    value = value._id;\n  }\n\n  if (Buffer.isBuffer(value)) {\n    if (!value || !value.isStorageBuffer) {\n      value = new StorageBuffer(value, [this.path, doc]);\n    }\n\n    return value;\n  } else if (value instanceof Binary) {\n    var ret = new StorageBuffer(value.value(true), [this.path, doc]);\n    ret.subtype(value.sub_type);\n    // do not override Binary subtypes. users set this\n    // to whatever they want.\n    return ret;\n  }\n\n  if (null === value) return value;\n\n  var type = typeof value;\n  if ('string' == type || 'number' == type || Array.isArray(value)) {\n    var ret = new StorageBuffer(value, [this.path, doc]);\n    return ret;\n  }\n\n  throw new CastError('buffer', value, this.path);\n};",
    "ctx": {
      "type": "method",
      "constructor": "SchemaBuffer",
      "cons": "SchemaBuffer",
      "name": "cast",
      "string": "SchemaBuffer.prototype.cast()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Module exports.</p>",
      "summary": "<p>Module exports.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 118,
    "codeStart": 122,
    "code": "module.exports = SchemaBuffer;",
    "ctx": {
      "type": "property",
      "receiver": "module",
      "name": "exports",
      "value": "SchemaBuffer",
      "string": "module.exports"
    }
  }
]
### lib/schema/date.js
[
  {
    "tags": [],
    "description": {
      "full": "<p>Module requirements.</p>",
      "summary": "<p>Module requirements.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 1,
    "codeStart": 5,
    "code": "var SchemaType = require('../schematype');\nvar CastError = SchemaType.CastError;",
    "ctx": {
      "type": "declaration",
      "name": "SchemaType",
      "value": "require('../schematype')",
      "string": "SchemaType"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "key",
        "description": "",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "options",
        "description": "",
        "optional": false
      },
      {
        "type": "inherits",
        "string": "SchemaType"
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Date SchemaType constructor.</p>",
      "summary": "<p>Date SchemaType constructor.</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": false,
    "line": 8,
    "codeStart": 17,
    "code": "function DateSchema (key, options) {\n  SchemaType.call(this, key, options);\n}",
    "ctx": {
      "type": "function",
      "name": "DateSchema",
      "string": "DateSchema()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Inherits from SchemaType.</p>",
      "summary": "<p>Inherits from SchemaType.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 21,
    "codeStart": 24,
    "code": "DateSchema.prototype = Object.create( SchemaType.prototype );\nDateSchema.prototype.constructor = DateSchema;",
    "ctx": {
      "type": "property",
      "receiver": "DateSchema",
      "name": "prototype",
      "value": "Object.create( SchemaType.prototype )",
      "string": "DateSchema.prototype"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Required validator for date</p>",
      "summary": "<p>Required validator for date</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": false,
    "line": 27,
    "codeStart": 32,
    "code": "DateSchema.prototype.checkRequired = function (value) {\n  return value instanceof Date;\n};",
    "ctx": {
      "type": "method",
      "constructor": "DateSchema",
      "cons": "DateSchema",
      "name": "checkRequired",
      "string": "DateSchema.prototype.checkRequired()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "value",
        "description": "to cast",
        "optional": false
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Casts to date</p>",
      "summary": "<p>Casts to date</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": false,
    "line": 36,
    "codeStart": 42,
    "code": "DateSchema.prototype.cast = function (value) {\n  if (value === null || value === '')\n    return null;\n\n  if (value instanceof Date)\n    return value;\n\n  var date;\n\n  // support for timestamps\n  if (value instanceof Number || 'number' == typeof value\n      || String(value) == Number(value))\n    date = new Date(Number(value));\n\n  // support for date strings\n  else if (value.toString)\n    date = new Date(value.toString());\n\n  if (date.toString() != 'Invalid Date')\n    return date;\n\n  throw new CastError('date', value, this.path );\n};",
    "ctx": {
      "type": "method",
      "constructor": "DateSchema",
      "cons": "DateSchema",
      "name": "cast",
      "string": "DateSchema.prototype.cast()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Module exports.</p>",
      "summary": "<p>Module exports.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 66,
    "codeStart": 70,
    "code": "module.exports = DateSchema;",
    "ctx": {
      "type": "property",
      "receiver": "module",
      "name": "exports",
      "value": "DateSchema",
      "string": "module.exports"
    }
  }
]
### lib/schema/documentarray.js
[
  {
    "tags": [],
    "description": {
      "full": "<p>Module dependencies.</p>",
      "summary": "<p>Module dependencies.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 2,
    "codeStart": 6,
    "code": "var SchemaType = require('../schematype')\n  , ArrayType = require('./array')\n  , StorageDocumentArray = require('../types/documentarray')\n  , Subdocument = require('../types/embedded')\n  , Document = require('../document');",
    "ctx": {
      "type": "declaration",
      "name": "SchemaType",
      "value": "require('../schematype')",
      "string": "SchemaType"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "key",
        "description": "",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "Schema"
        ],
        "name": "schema",
        "description": "",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "options",
        "description": "",
        "optional": false
      },
      {
        "type": "inherits",
        "string": "SchemaArray"
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>SubdocsArray SchemaType constructor</p>",
      "summary": "<p>SubdocsArray SchemaType constructor</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": false,
    "line": 12,
    "codeStart": 21,
    "code": "function DocumentArray (key, schema, options) {\n\n  // compile an embedded document for this schema\n  function EmbeddedDocument () {\n    Subdocument.apply( this, arguments );\n  }\n\n  EmbeddedDocument.prototype = Object.create( Subdocument.prototype );\n  EmbeddedDocument.prototype.constructor = EmbeddedDocument;\n  EmbeddedDocument.prototype.$__setSchema( schema );\n\n  // apply methods\n  for (var i in schema.methods) {\n    EmbeddedDocument.prototype[i] = schema.methods[i];\n  }\n\n  // apply statics\n  for (var j in schema.statics) {\n    EmbeddedDocument[j] = schema.statics[j];\n  }\n\n  EmbeddedDocument.options = options;\n  this.schema = schema;\n\n  ArrayType.call(this, key, EmbeddedDocument, options);\n\n  this.schema = schema;\n  var path = this.path;\n  var fn = this.defaultValue;\n\n  this.default(function(){\n    var arr = fn.call(this);\n    if (!Array.isArray(arr)) arr = [arr];\n    return new StorageDocumentArray(arr, path, this);\n  });\n}",
    "ctx": {
      "type": "function",
      "name": "DocumentArray",
      "string": "DocumentArray()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Inherits from ArrayType.</p>",
      "summary": "<p>Inherits from ArrayType.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 58,
    "codeStart": 61,
    "code": "DocumentArray.prototype = Object.create( ArrayType.prototype );\nDocumentArray.prototype.constructor = DocumentArray;",
    "ctx": {
      "type": "property",
      "receiver": "DocumentArray",
      "name": "prototype",
      "value": "Object.create( ArrayType.prototype )",
      "string": "DocumentArray.prototype"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Performs local validations first, then validations on each embedded doc</p>",
      "summary": "<p>Performs local validations first, then validations on each embedded doc</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": false,
    "line": 64,
    "codeStart": 69,
    "code": "DocumentArray.prototype.doValidate = function (array, fn, scope) {\n  var self = this;\n\n  SchemaType.prototype.doValidate.call(this, array, function (err) {\n    if (err) return fn(err);\n\n    var count = array && array.length\n      , error;\n\n    if (!count) return fn();\n\n    // handle sparse arrays, do not use array.forEach which does not\n    // iterate over sparse elements yet reports array.length including\n    // them :(\n\n    for (var i = 0, len = count; i < len; ++i) {\n      // sidestep sparse entries\n      var doc = array[i];\n      if (!doc) {\n        --count || fn();\n        continue;\n      }\n\n      !(function (i) {\n        doc.validate(function (err) {\n          if (err && !error) {\n            // rewrite the key\n            err.key = self.key + '.' + i + '.' + err.key;\n            return fn(error = err);\n          }\n          --count || fn();\n        });\n      })(i);\n    }\n  }, scope);\n};",
    "ctx": {
      "type": "method",
      "constructor": "DocumentArray",
      "cons": "DocumentArray",
      "name": "doValidate",
      "string": "DocumentArray.prototype.doValidate()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "value",
        "description": "",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "Document"
        ],
        "name": "doc",
        "description": "that triggers the casting",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "Boolean"
        ],
        "name": "init",
        "description": "flag",
        "optional": false
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Casts contents</p>",
      "summary": "<p>Casts contents</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": false,
    "line": 106,
    "codeStart": 114,
    "code": "DocumentArray.prototype.cast = function (value, doc, init, prev) {\n  var selected\n    , subdoc\n    , i;\n\n  if (!Array.isArray(value)) {\n    return this.cast([value], doc, init, prev);\n  }\n\n  if (!(value.isStorageDocumentArray)) {\n    value = new StorageDocumentArray(value, this.path, doc);\n    if (prev && prev._handlers) {\n      for (var key in prev._handlers) {\n        doc.off(key, prev._handlers[key]);\n      }\n    }\n  }\n\n  i = value.length;\n\n  while (i--) {\n    if (!(value[i] instanceof Subdocument) && value[i]) {\n      if (init) {\n        selected || (selected = scopePaths(this, doc.$__.selected, init));\n        subdoc = new this.casterConstructor(null, value, true, selected);\n        value[i] = subdoc.init(value[i]);\n      } else {\n        try {\n          subdoc = prev.id(value[i]._id);\n        } catch(e) {}\n\n        if (prev && subdoc) {\n          // handle resetting doc with existing id but differing data\n          // doc.array = [{ doc: 'val' }]\n          subdoc.set(value[i]);\n        } else {\n          subdoc = new this.casterConstructor(value[i], value);\n        }\n\n        // if set() is hooked it will have no return value\n        // see gh-746\n        value[i] = subdoc;\n      }\n    }\n  }\n\n  return value;\n};",
    "ctx": {
      "type": "method",
      "constructor": "DocumentArray",
      "cons": "DocumentArray",
      "name": "cast",
      "string": "DocumentArray.prototype.cast()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "DocumentArray"
        ],
        "name": "array",
        "description": "- the array to scope `fields` paths",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "Object",
          "undefined"
        ],
        "name": "fields",
        "description": "- the root fields selected in the query",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "Boolean",
          "undefined"
        ],
        "name": "init",
        "description": "- if we are being created part of a query result",
        "optional": false
      }
    ],
    "description": {
      "full": "<p>Scopes paths selected in a query to this array.<br />Necessary for proper default application of subdocument values.</p>",
      "summary": "<p>Scopes paths selected in a query to this array.<br />Necessary for proper default application of subdocument values.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 163,
    "codeStart": 171,
    "code": "function scopePaths (array, fields, init) {\n  if (!(init && fields)) return undefined;\n\n  var path = array.path + '.'\n    , keys = Object.keys(fields)\n    , i = keys.length\n    , selected = {}\n    , hasKeys\n    , key;\n\n  while (i--) {\n    key = keys[i];\n    if (0 === key.indexOf(path)) {\n      hasKeys || (hasKeys = true);\n      selected[key.substring(path.length)] = fields[key];\n    }\n  }\n\n  return hasKeys && selected || undefined;\n}",
    "ctx": {
      "type": "function",
      "name": "scopePaths",
      "string": "scopePaths()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Module exports.</p>",
      "summary": "<p>Module exports.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 192,
    "codeStart": 196,
    "code": "module.exports = DocumentArray;",
    "ctx": {
      "type": "property",
      "receiver": "module",
      "name": "exports",
      "value": "DocumentArray",
      "string": "module.exports"
    }
  }
]
### lib/schema/index.js
[
  {
    "tags": [],
    "description": {
      "full": "<p>Module exports.</p>",
      "summary": "<p>Module exports.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 2,
    "codeStart": 6,
    "code": "exports.String = require('./string');\n\nexports.Number = require('./number');\n\nexports.Boolean = require('./boolean');\n\nexports.DocumentArray = require('./documentarray');\n\nexports.Array = require('./array');\n\nexports.Buffer = require('./buffer');\n\nexports.Date = require('./date');\n\nexports.ObjectId = require('./objectid');\n\nexports.Mixed = require('./mixed');\n\n// alias\n\nexports.Oid = exports.ObjectId;\nexports.Object = exports.Mixed;\nexports.Bool = exports.Boolean;",
    "ctx": {
      "type": "property",
      "receiver": "exports",
      "name": "String",
      "value": "require('./string')",
      "string": "exports.String"
    }
  }
]
### lib/schema/mixed.js
[
  {
    "tags": [],
    "description": {
      "full": "<p>Module dependencies.</p>",
      "summary": "<p>Module dependencies.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 1,
    "codeStart": 5,
    "code": "var SchemaType = require('../schematype');",
    "ctx": {
      "type": "declaration",
      "name": "SchemaType",
      "value": "require('../schematype')",
      "string": "SchemaType"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "path",
        "description": "",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "options",
        "description": "",
        "optional": false
      },
      {
        "type": "inherits",
        "string": "SchemaType"
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Mixed SchemaType constructor.</p>",
      "summary": "<p>Mixed SchemaType constructor.</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": false,
    "line": 7,
    "codeStart": 15,
    "code": "function Mixed (path, options) {\n  if (options && options.default) {\n    var def = options.default;\n    if (Array.isArray(def) && 0 === def.length) {\n      // make sure empty array defaults are handled\n      options.default = Array;\n    } else if (!options.shared &&\n               _.isPlainObject(def) &&\n               0 === Object.keys(def).length) {\n      // prevent odd \"shared\" objects between documents\n      options.default = function () {\n        return {}\n      }\n    }\n  }\n\n  SchemaType.call(this, path, options);\n}",
    "ctx": {
      "type": "function",
      "name": "Mixed",
      "string": "Mixed()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Inherits from SchemaType.</p>",
      "summary": "<p>Inherits from SchemaType.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 34,
    "codeStart": 37,
    "code": "Mixed.prototype = Object.create( SchemaType.prototype );\nMixed.prototype.constructor = Mixed;",
    "ctx": {
      "type": "property",
      "receiver": "Mixed",
      "name": "prototype",
      "value": "Object.create( SchemaType.prototype )",
      "string": "Mixed.prototype"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Required validator</p>",
      "summary": "<p>Required validator</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": false,
    "line": 40,
    "codeStart": 45,
    "code": "Mixed.prototype.checkRequired = function (val) {\n  return (val !== undefined) && (val !== null);\n};",
    "ctx": {
      "type": "method",
      "constructor": "Mixed",
      "cons": "Mixed",
      "name": "checkRequired",
      "string": "Mixed.prototype.checkRequired()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "value",
        "description": "to cast",
        "optional": false
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Casts <code>val</code> for Mixed.</p><p><em>this is a no-op</em></p>",
      "summary": "<p>Casts <code>val</code> for Mixed.</p>",
      "body": "<p><em>this is a no-op</em></p>"
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": false,
    "line": 49,
    "codeStart": 57,
    "code": "Mixed.prototype.cast = function (value) {\n  return value;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Mixed",
      "cons": "Mixed",
      "name": "cast",
      "string": "Mixed.prototype.cast()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Module exports.</p>",
      "summary": "<p>Module exports.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 61,
    "codeStart": 65,
    "code": "module.exports = Mixed;",
    "ctx": {
      "type": "property",
      "receiver": "module",
      "name": "exports",
      "value": "Mixed",
      "string": "module.exports"
    }
  }
]
### lib/schema/number.js
[
  {
    "tags": [],
    "description": {
      "full": "<p>Module requirements.</p>",
      "summary": "<p>Module requirements.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 1,
    "codeStart": 5,
    "code": "var SchemaType = require('../schematype')\n  , CastError = SchemaType.CastError\n  , errorMessages = require('../error').messages;",
    "ctx": {
      "type": "declaration",
      "name": "SchemaType",
      "value": "require('../schematype')",
      "string": "SchemaType"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "key",
        "description": "",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "options",
        "description": "",
        "optional": false
      },
      {
        "type": "inherits",
        "string": "SchemaType"
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Number SchemaType constructor.</p>",
      "summary": "<p>Number SchemaType constructor.</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": false,
    "line": 9,
    "codeStart": 17,
    "code": "function NumberSchema (key, options) {\n  SchemaType.call(this, key, options, 'Number');\n}",
    "ctx": {
      "type": "function",
      "name": "NumberSchema",
      "string": "NumberSchema()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Inherits from SchemaType.</p>",
      "summary": "<p>Inherits from SchemaType.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 21,
    "codeStart": 24,
    "code": "NumberSchema.prototype = Object.create( SchemaType.prototype );\nNumberSchema.prototype.constructor = NumberSchema;",
    "ctx": {
      "type": "property",
      "receiver": "NumberSchema",
      "name": "prototype",
      "value": "Object.create( SchemaType.prototype )",
      "string": "NumberSchema.prototype"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Required validator for number</p>",
      "summary": "<p>Required validator for number</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": false,
    "line": 27,
    "codeStart": 32,
    "code": "NumberSchema.prototype.checkRequired = function ( value ) {\n  if ( SchemaType._isRef( this, value ) ) {\n    return null != value;\n  } else {\n    return typeof value == 'number' || value instanceof Number;\n  }\n};",
    "ctx": {
      "type": "method",
      "constructor": "NumberSchema",
      "cons": "NumberSchema",
      "name": "checkRequired",
      "string": "NumberSchema.prototype.checkRequired()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Number"
        ],
        "name": "value",
        "description": "minimum number",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "[message]",
        "description": "optional custom error message",
        "optional": true
      },
      {
        "type": "return",
        "types": [
          "SchemaType"
        ],
        "description": "this"
      },
      {
        "type": "see",
        "local": "Customized Error Messages #error_messages_StorageError-messages"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Sets a minimum number validator.</p><h4>Example:</h4>\n<pre><code>var s = new Schema({ n: { type: Number, min: 10 })\nvar M = db.model(&#39;M&#39;, s)\nvar m = new M({ n: 9 })\nm.save(function (err) {\n  console.error(err) // validator error\n  m.n = 10;\n  m.save() // success\n})\n\n// custom error messages\n// We can also use the special {MIN} token which will be replaced with the invalid value\nvar min = [10, &#39;The value of path `{PATH}` ({VALUE}) is beneath the limit ({MIN}).&#39;];\nvar schema = new Schema({ n: { type: Number, min: min })\nvar M = mongoose.model(&#39;Measurement&#39;, schema);\nvar s= new M({ n: 4 });\ns.validate(function (err) {\n  console.log(String(err)) // ValidationError: The value of path `n` (4) is beneath the limit (10).\n})\n</code></pre>",
      "summary": "<p>Sets a minimum number validator.</p>",
      "body": "<h4>Example:</h4>\n<pre><code>var s = new Schema({ n: { type: Number, min: 10 })\nvar M = db.model(&#39;M&#39;, s)\nvar m = new M({ n: 9 })\nm.save(function (err) {\n  console.error(err) // validator error\n  m.n = 10;\n  m.save() // success\n})\n\n// custom error messages\n// We can also use the special {MIN} token which will be replaced with the invalid value\nvar min = [10, &#39;The value of path `{PATH}` ({VALUE}) is beneath the limit ({MIN}).&#39;];\nvar schema = new Schema({ n: { type: Number, min: min })\nvar M = mongoose.model(&#39;Measurement&#39;, schema);\nvar s= new M({ n: 4 });\ns.validate(function (err) {\n  console.log(String(err)) // ValidationError: The value of path `n` (4) is beneath the limit (10).\n})\n</code></pre>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 40,
    "codeStart": 70,
    "code": "NumberSchema.prototype.min = function (value, message) {\n  if (this.minValidator) {\n    this.validators = this.validators.filter(function (v) {\n      return v[0] != this.minValidator;\n    }, this);\n  }\n\n  if (null != value) {\n    var msg = message || errorMessages.Number.min;\n    msg = msg.replace(/{MIN}/, value);\n    this.validators.push([this.minValidator = function (v) {\n      return v === null || v >= value;\n    }, msg, 'min']);\n  }\n\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "NumberSchema",
      "cons": "NumberSchema",
      "name": "min",
      "string": "NumberSchema.prototype.min()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Number"
        ],
        "name": "value",
        "description": "maximum number",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "[message]",
        "description": "optional custom error message",
        "optional": true
      },
      {
        "type": "return",
        "types": [
          "SchemaType"
        ],
        "description": "this"
      },
      {
        "type": "see",
        "local": "Customized Error Messages #error_messages_StorageError-messages"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Sets a maximum number validator.</p><h4>Example:</h4>\n<pre><code>var s = new Schema({ n: { type: Number, max: 10 })\nvar M = db.model(&#39;M&#39;, s)\nvar m = new M({ n: 11 })\nm.save(function (err) {\n  console.error(err) // validator error\n  m.n = 10;\n  m.save() // success\n})\n\n// custom error messages\n// We can also use the special {MAX} token which will be replaced with the invalid value\nvar max = [10, &#39;The value of path `{PATH}` ({VALUE}) exceeds the limit ({MAX}).&#39;];\nvar schema = new Schema({ n: { type: Number, max: max })\nvar M = mongoose.model(&#39;Measurement&#39;, schema);\nvar s= new M({ n: 4 });\ns.validate(function (err) {\n  console.log(String(err)) // ValidationError: The value of path `n` (4) exceeds the limit (10).\n})\n</code></pre>",
      "summary": "<p>Sets a maximum number validator.</p>",
      "body": "<h4>Example:</h4>\n<pre><code>var s = new Schema({ n: { type: Number, max: 10 })\nvar M = db.model(&#39;M&#39;, s)\nvar m = new M({ n: 11 })\nm.save(function (err) {\n  console.error(err) // validator error\n  m.n = 10;\n  m.save() // success\n})\n\n// custom error messages\n// We can also use the special {MAX} token which will be replaced with the invalid value\nvar max = [10, &#39;The value of path `{PATH}` ({VALUE}) exceeds the limit ({MAX}).&#39;];\nvar schema = new Schema({ n: { type: Number, max: max })\nvar M = mongoose.model(&#39;Measurement&#39;, schema);\nvar s= new M({ n: 4 });\ns.validate(function (err) {\n  console.log(String(err)) // ValidationError: The value of path `n` (4) exceeds the limit (10).\n})\n</code></pre>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 88,
    "codeStart": 118,
    "code": "NumberSchema.prototype.max = function (value, message) {\n  if (this.maxValidator) {\n    this.validators = this.validators.filter(function(v){\n      return v[0] != this.maxValidator;\n    }, this);\n  }\n\n  if (null != value) {\n    var msg = message || errorMessages.Number.max;\n    msg = msg.replace(/{MAX}/, value);\n    this.validators.push([this.maxValidator = function(v){\n      return v === null || v <= value;\n    }, msg, 'max']);\n  }\n\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "NumberSchema",
      "cons": "NumberSchema",
      "name": "max",
      "string": "NumberSchema.prototype.max()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "value",
        "description": "value to cast",
        "optional": false
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Casts to number</p>",
      "summary": "<p>Casts to number</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": false,
    "line": 136,
    "codeStart": 142,
    "code": "NumberSchema.prototype.cast = function ( value ) {\n  var val = value && value._id\n    ? value._id // documents\n    : value;\n\n  if (!isNaN(val)){\n    if (null === val) return val;\n    if ('' === val) return null;\n    if ('string' == typeof val) val = Number(val);\n    if (val instanceof Number) return val;\n    if ('number' == typeof val) return val;\n    if (val.toString && !Array.isArray(val) &&\n        val.toString() == Number(val)) {\n      return new Number(val);\n    }\n  }\n\n  throw new CastError('number', value, this.path);\n};",
    "ctx": {
      "type": "method",
      "constructor": "NumberSchema",
      "cons": "NumberSchema",
      "name": "cast",
      "string": "NumberSchema.prototype.cast()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Module exports.</p>",
      "summary": "<p>Module exports.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 162,
    "codeStart": 166,
    "code": "module.exports = NumberSchema;",
    "ctx": {
      "type": "property",
      "receiver": "module",
      "name": "exports",
      "value": "NumberSchema",
      "string": "module.exports"
    }
  }
]
### lib/schema/objectid.js
[
  {
    "tags": [],
    "description": {
      "full": "<p>Module dependencies.</p>",
      "summary": "<p>Module dependencies.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 1,
    "codeStart": 5,
    "code": "var SchemaType = require('../schematype')\n  , CastError = SchemaType.CastError\n  , oid = require('../types/objectid')\n  , utils = require('../utils')\n  , Document;",
    "ctx": {
      "type": "declaration",
      "name": "SchemaType",
      "value": "require('../schematype')",
      "string": "SchemaType"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "key",
        "description": "",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "options",
        "description": "",
        "optional": false
      },
      {
        "type": "inherits",
        "string": "SchemaType"
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>ObjectId SchemaType constructor.</p>",
      "summary": "<p>ObjectId SchemaType constructor.</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": false,
    "line": 11,
    "codeStart": 20,
    "code": "function ObjectId (key, options) {\n  SchemaType.call(this, key, options, 'ObjectId');\n}",
    "ctx": {
      "type": "function",
      "name": "ObjectId",
      "string": "ObjectId()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Inherits from SchemaType.</p>",
      "summary": "<p>Inherits from SchemaType.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 24,
    "codeStart": 27,
    "code": "ObjectId.prototype = Object.create( SchemaType.prototype );\nObjectId.prototype.constructor = ObjectId;",
    "ctx": {
      "type": "property",
      "receiver": "ObjectId",
      "name": "prototype",
      "value": "Object.create( SchemaType.prototype )",
      "string": "ObjectId.prototype"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Boolean"
        ],
        "name": "turnOn",
        "description": "auto generated ObjectId defaults",
        "optional": false
      },
      {
        "type": "api",
        "visibility": "public"
      },
      {
        "type": "return",
        "types": [
          "SchemaType"
        ],
        "description": "this"
      }
    ],
    "description": {
      "full": "<p>Adds an auto-generated ObjectId default if turnOn is true.</p>",
      "summary": "<p>Adds an auto-generated ObjectId default if turnOn is true.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 30,
    "codeStart": 36,
    "code": "ObjectId.prototype.auto = function ( turnOn ) {\n  if ( turnOn ) {\n    this.default( defaultId );\n    this.set( resetId )\n  }\n\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "ObjectId",
      "cons": "ObjectId",
      "name": "auto",
      "string": "ObjectId.prototype.auto()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Check required</p>",
      "summary": "<p>Check required</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": false,
    "line": 45,
    "codeStart": 50,
    "code": "ObjectId.prototype.checkRequired = function ( value ) {\n  if (SchemaType._isRef( this, value )) {\n    return null != value;\n  } else {\n    return value instanceof oid;\n  }\n};",
    "ctx": {
      "type": "method",
      "constructor": "ObjectId",
      "cons": "ObjectId",
      "name": "checkRequired",
      "string": "ObjectId.prototype.checkRequired()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "value",
        "description": "",
        "optional": false
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Casts to ObjectId</p>",
      "summary": "<p>Casts to ObjectId</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": false,
    "line": 58,
    "codeStart": 64,
    "code": "ObjectId.prototype.cast = function ( value ) {\n  if ( SchemaType._isRef( this, value ) ) {\n    // wait! we may need to cast this to a document\n\n    if (null == value) {\n      return value;\n    }\n\n    // lazy load\n    Document || (Document = require('./../document'));\n\n    if (value instanceof Document) {\n      value.$__.wasPopulated = true;\n      return value;\n    }\n\n    // setting a populated path\n    if (value instanceof oid ) {\n      return value;\n    } else if ( !_.isPlainObject( value ) ) {\n      throw new CastError('ObjectId', value, this.path);\n    }\n\n    // Нужно создать документ по схеме, указанной в ссылке\n    var schema = this.options.ref;\n    if ( !schema ){\n      throw new TypeError('При ссылке (ref) на документ ' +\n        'нужно указывать схему, по которой этот документ создавать');\n    }\n\n    if ( !storage.schemas[ schema ] ){\n      throw new TypeError('При ссылке (ref) на документ ' +\n        'нужно указывать название схемы на которую ссылаемся при её создании ( new Schema(\"name\", schemaObject) )');\n    }\n\n    // init doc\n    var doc = new Document( value, undefined, storage.schemas[ schema ], undefined, true );\n    doc.$__.wasPopulated = true;\n\n    return doc;\n  }\n\n  if (value === null) return value;\n\n  if (value instanceof oid)\n    return value;\n\n  if ( value._id && value._id instanceof oid )\n    return value._id;\n\n  if (value.toString) {\n    try {\n      return oid.createFromHexString(value.toString());\n    } catch (err) {\n      throw new CastError('ObjectId', value, this.path);\n    }\n  }\n\n  throw new CastError('ObjectId', value, this.path);\n};",
    "ctx": {
      "type": "method",
      "constructor": "ObjectId",
      "cons": "ObjectId",
      "name": "cast",
      "string": "ObjectId.prototype.cast()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>ignore</p>",
      "summary": "<p>ignore</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 125,
    "codeStart": 128,
    "code": "function defaultId () {\n  return new oid();\n}\n\nfunction resetId (v) {\n  this.$__._id = null;\n  return v;\n}",
    "ctx": {
      "type": "function",
      "name": "defaultId",
      "string": "defaultId()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Module exports.</p>",
      "summary": "<p>Module exports.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 137,
    "codeStart": 141,
    "code": "module.exports = ObjectId;",
    "ctx": {
      "type": "property",
      "receiver": "module",
      "name": "exports",
      "value": "ObjectId",
      "string": "module.exports"
    }
  }
]
### lib/schema/string.js
[
  {
    "tags": [],
    "description": {
      "full": "<p>Module dependencies.</p>",
      "summary": "<p>Module dependencies.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 1,
    "codeStart": 5,
    "code": "var SchemaType = require('../schematype')\n  , CastError = SchemaType.CastError\n  , errorMessages = require('../error').messages;",
    "ctx": {
      "type": "declaration",
      "name": "SchemaType",
      "value": "require('../schematype')",
      "string": "SchemaType"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "key",
        "description": "",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "options",
        "description": "",
        "optional": false
      },
      {
        "type": "inherits",
        "string": "SchemaType"
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>String SchemaType constructor.</p>",
      "summary": "<p>String SchemaType constructor.</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": false,
    "line": 9,
    "codeStart": 18,
    "code": "function StringSchema (key, options) {\n  this.enumValues = [];\n  this.regExp = null;\n  SchemaType.call(this, key, options, 'String');\n}",
    "ctx": {
      "type": "function",
      "name": "StringSchema",
      "string": "StringSchema()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Inherits from SchemaType.</p>",
      "summary": "<p>Inherits from SchemaType.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 24,
    "codeStart": 27,
    "code": "StringSchema.prototype = Object.create( SchemaType.prototype );\nStringSchema.prototype.constructor = StringSchema;",
    "ctx": {
      "type": "property",
      "receiver": "StringSchema",
      "name": "prototype",
      "value": "Object.create( SchemaType.prototype )",
      "string": "StringSchema.prototype"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String",
          "Object"
        ],
        "name": "[args...]",
        "description": "enumeration values",
        "optional": true
      },
      {
        "type": "return",
        "types": [
          "SchemaType"
        ],
        "description": "this"
      },
      {
        "type": "see",
        "local": "Customized Error Messages #error_messages_StorageError-messages"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Adds an enum validator</p><h4>Example:</h4>\n<pre><code>var states = &#39;opening open closing closed&#39;.split(&#39; &#39;)\nvar s = new Schema({ state: { type: String, enum: states }})\nvar M = db.model(&#39;M&#39;, s)\nvar m = new M({ state: &#39;invalid&#39; })\nm.save(function (err) {\n  console.error(String(err)) // ValidationError: `invalid` is not a valid enum value for path `state`.\n  m.state = &#39;open&#39;\n  m.save(callback) // success\n})\n\n// or with custom error messages\nvar enu = {\n  values: &#39;opening open closing closed&#39;.split(&#39; &#39;),\n  message: &#39;enum validator failed for path `{PATH}` with value `{VALUE}`&#39;\n}\nvar s = new Schema({ state: { type: String, enum: enu })\nvar M = db.model(&#39;M&#39;, s)\nvar m = new M({ state: &#39;invalid&#39; })\nm.save(function (err) {\n  console.error(String(err)) // ValidationError: enum validator failed for path `state` with value `invalid`\n  m.state = &#39;open&#39;\n  m.save(callback) // success\n})\n</code></pre>",
      "summary": "<p>Adds an enum validator</p>",
      "body": "<h4>Example:</h4>\n<pre><code>var states = &#39;opening open closing closed&#39;.split(&#39; &#39;)\nvar s = new Schema({ state: { type: String, enum: states }})\nvar M = db.model(&#39;M&#39;, s)\nvar m = new M({ state: &#39;invalid&#39; })\nm.save(function (err) {\n  console.error(String(err)) // ValidationError: `invalid` is not a valid enum value for path `state`.\n  m.state = &#39;open&#39;\n  m.save(callback) // success\n})\n\n// or with custom error messages\nvar enu = {\n  values: &#39;opening open closing closed&#39;.split(&#39; &#39;),\n  message: &#39;enum validator failed for path `{PATH}` with value `{VALUE}`&#39;\n}\nvar s = new Schema({ state: { type: String, enum: enu })\nvar M = db.model(&#39;M&#39;, s)\nvar m = new M({ state: &#39;invalid&#39; })\nm.save(function (err) {\n  console.error(String(err)) // ValidationError: enum validator failed for path `state` with value `invalid`\n  m.state = &#39;open&#39;\n  m.save(callback) // success\n})\n</code></pre>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 30,
    "codeStart": 64,
    "code": "StringSchema.prototype.enum = function () {\n  if (this.enumValidator) {\n    this.validators = this.validators.filter(function(v){\n      return v[0] != this.enumValidator;\n    }, this);\n    this.enumValidator = false;\n  }\n\n  if (undefined === arguments[0] || false === arguments[0]) {\n    return this;\n  }\n\n  var values;\n  var errorMessage;\n\n  if (_.isPlainObject(arguments[0])) {\n    values = arguments[0].values;\n    errorMessage = arguments[0].message;\n  } else {\n    values = arguments;\n    errorMessage = errorMessages.String.enum;\n  }\n\n  for (var i = 0; i < values.length; i++) {\n    if (undefined !== values[i]) {\n      this.enumValues.push(this.cast(values[i]));\n    }\n  }\n\n  var vals = this.enumValues;\n  this.enumValidator = function (v) {\n    return undefined === v || ~vals.indexOf(v);\n  };\n  this.validators.push([this.enumValidator, errorMessage, 'enum']);\n\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "StringSchema",
      "cons": "StringSchema",
      "name": "enum",
      "string": "StringSchema.prototype.enum()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      },
      {
        "type": "return",
        "types": [
          "SchemaType"
        ],
        "description": "this"
      }
    ],
    "description": {
      "full": "<p>Adds a lowercase setter.</p><h4>Example:</h4>\n<pre><code>var s = new Schema({ email: { type: String, lowercase: true }})\nvar M = db.model(&#39;M&#39;, s);\nvar m = new M({ email: &#39;SomeEmail@example.COM&#39; });\nconsole.log(m.email) // someemail@example.com\n</code></pre>",
      "summary": "<p>Adds a lowercase setter.</p>",
      "body": "<h4>Example:</h4>\n<pre><code>var s = new Schema({ email: { type: String, lowercase: true }})\nvar M = db.model(&#39;M&#39;, s);\nvar m = new M({ email: &#39;SomeEmail@example.COM&#39; });\nconsole.log(m.email) // someemail@example.com\n</code></pre>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 102,
    "codeStart": 115,
    "code": "StringSchema.prototype.lowercase = function () {\n  return this.set(function (v, self) {\n    if ('string' != typeof v) v = self.cast(v);\n    if (v) return v.toLowerCase();\n    return v;\n  });\n};",
    "ctx": {
      "type": "method",
      "constructor": "StringSchema",
      "cons": "StringSchema",
      "name": "lowercase",
      "string": "StringSchema.prototype.lowercase()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      },
      {
        "type": "return",
        "types": [
          "SchemaType"
        ],
        "description": "this"
      }
    ],
    "description": {
      "full": "<p>Adds an uppercase setter.</p><h4>Example:</h4>\n<pre><code>var s = new Schema({ caps: { type: String, uppercase: true }})\nvar M = db.model(&#39;M&#39;, s);\nvar m = new M({ caps: &#39;an example&#39; });\nconsole.log(m.caps) // AN EXAMPLE\n</code></pre>",
      "summary": "<p>Adds an uppercase setter.</p>",
      "body": "<h4>Example:</h4>\n<pre><code>var s = new Schema({ caps: { type: String, uppercase: true }})\nvar M = db.model(&#39;M&#39;, s);\nvar m = new M({ caps: &#39;an example&#39; });\nconsole.log(m.caps) // AN EXAMPLE\n</code></pre>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 123,
    "codeStart": 136,
    "code": "StringSchema.prototype.uppercase = function () {\n  return this.set(function (v, self) {\n    if ('string' != typeof v) v = self.cast(v);\n    if (v) return v.toUpperCase();\n    return v;\n  });\n};",
    "ctx": {
      "type": "method",
      "constructor": "StringSchema",
      "cons": "StringSchema",
      "name": "uppercase",
      "string": "StringSchema.prototype.uppercase()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      },
      {
        "type": "return",
        "types": [
          "SchemaType"
        ],
        "description": "this"
      }
    ],
    "description": {
      "full": "<p>Adds a trim setter.</p><p>The string value will be trimmed when set.</p><h4>Example:</h4>\n<pre><code>var s = new Schema({ name: { type: String, trim: true }})\nvar M = db.model(&#39;M&#39;, s)\nvar string = &#39; some name &#39;\nconsole.log(string.length) // 11\nvar m = new M({ name: string })\nconsole.log(m.name.length) // 9\n</code></pre>",
      "summary": "<p>Adds a trim setter.</p>",
      "body": "<p>The string value will be trimmed when set.</p><h4>Example:</h4>\n<pre><code>var s = new Schema({ name: { type: String, trim: true }})\nvar M = db.model(&#39;M&#39;, s)\nvar string = &#39; some name &#39;\nconsole.log(string.length) // 11\nvar m = new M({ name: string })\nconsole.log(m.name.length) // 9\n</code></pre>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 144,
    "codeStart": 161,
    "code": "StringSchema.prototype.trim = function () {\n  return this.set(function (v, self) {\n    if ('string' != typeof v) v = self.cast(v);\n    if (v) return v.trim();\n    return v;\n  });\n};",
    "ctx": {
      "type": "method",
      "constructor": "StringSchema",
      "cons": "StringSchema",
      "name": "trim",
      "string": "StringSchema.prototype.trim()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "RegExp"
        ],
        "name": "regExp",
        "description": "regular expression to test against",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "[message]",
        "description": "optional custom error message",
        "optional": true
      },
      {
        "type": "return",
        "types": [
          "SchemaType"
        ],
        "description": "this"
      },
      {
        "type": "see",
        "local": "Customized Error Messages #error_messages_StorageError-messages"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Sets a regexp validator.</p><p>Any value that does not pass <code>regExp</code>.test(val) will fail validation.</p><h4>Example:</h4>\n<pre><code>var s = new Schema({ name: { type: String, match: /^a/ }})\nvar M = db.model(&#39;M&#39;, s)\nvar m = new M({ name: &#39;I am invalid&#39; })\nm.validate(function (err) {\n  console.error(String(err)) // &quot;ValidationError: Path `name` is invalid (I am invalid).&quot;\n  m.name = &#39;apples&#39;\n  m.validate(function (err) {\n    assert.ok(err) // success\n  })\n})\n\n// using a custom error message\nvar match = [ /\\.html$/, &quot;That file doesn&#39;t end in .html ({VALUE})&quot; ];\nvar s = new Schema({ file: { type: String, match: match }})\nvar M = db.model(&#39;M&#39;, s);\nvar m = new M({ file: &#39;invalid&#39; });\nm.validate(function (err) {\n  console.log(String(err)) // &quot;ValidationError: That file doesn&#39;t end in .html (invalid)&quot;\n})\n</code></pre><p>Empty strings, <code>undefined</code>, and <code>null</code> values always pass the match validator. If you require these values, enable the <code>required</code> validator also.</p><pre><code>var s = new Schema({ name: { type: String, match: /^a/, required: true }})\n</code></pre>",
      "summary": "<p>Sets a regexp validator.</p>",
      "body": "<p>Any value that does not pass <code>regExp</code>.test(val) will fail validation.</p><h4>Example:</h4>\n<pre><code>var s = new Schema({ name: { type: String, match: /^a/ }})\nvar M = db.model(&#39;M&#39;, s)\nvar m = new M({ name: &#39;I am invalid&#39; })\nm.validate(function (err) {\n  console.error(String(err)) // &quot;ValidationError: Path `name` is invalid (I am invalid).&quot;\n  m.name = &#39;apples&#39;\n  m.validate(function (err) {\n    assert.ok(err) // success\n  })\n})\n\n// using a custom error message\nvar match = [ /\\.html$/, &quot;That file doesn&#39;t end in .html ({VALUE})&quot; ];\nvar s = new Schema({ file: { type: String, match: match }})\nvar M = db.model(&#39;M&#39;, s);\nvar m = new M({ file: &#39;invalid&#39; });\nm.validate(function (err) {\n  console.log(String(err)) // &quot;ValidationError: That file doesn&#39;t end in .html (invalid)&quot;\n})\n</code></pre><p>Empty strings, <code>undefined</code>, and <code>null</code> values always pass the match validator. If you require these values, enable the <code>required</code> validator also.</p><pre><code>var s = new Schema({ name: { type: String, match: /^a/, required: true }})\n</code></pre>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 169,
    "codeStart": 206,
    "code": "StringSchema.prototype.match = function match (regExp, message) {\n  // yes, we allow multiple match validators\n\n  var msg = message || errorMessages.String.match;\n\n  function matchValidator (v){\n    return null != v && '' !== v\n      ? regExp.test(v)\n      : true\n  }\n\n  this.validators.push([matchValidator, msg, 'regexp']);\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "StringSchema",
      "cons": "StringSchema",
      "name": "match",
      "string": "StringSchema.prototype.match()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String",
          "null",
          "undefined"
        ],
        "name": "value",
        "description": "",
        "optional": false
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Check required</p>",
      "summary": "<p>Check required</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": false,
    "line": 221,
    "codeStart": 227,
    "code": "StringSchema.prototype.checkRequired = function checkRequired (value, doc) {\n  if (SchemaType._isRef(this, value, doc, true)) {\n    return null != value;\n  } else {\n    return (value instanceof String || typeof value == 'string') && value.length;\n  }\n};",
    "ctx": {
      "type": "method",
      "constructor": "StringSchema",
      "cons": "StringSchema",
      "name": "checkRequired",
      "string": "StringSchema.prototype.checkRequired()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Casts to String</p>",
      "summary": "<p>Casts to String</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": false,
    "line": 235,
    "codeStart": 240,
    "code": "StringSchema.prototype.cast = function ( value ) {\n  if ( value === null ) {\n    return value;\n  }\n\n  if ('undefined' !== typeof value) {\n    // handle documents being passed\n    if (value._id && 'string' == typeof value._id) {\n      return value._id;\n    }\n    if ( value.toString ) {\n      return value.toString();\n    }\n  }\n\n  throw new CastError('string', value, this.path);\n};",
    "ctx": {
      "type": "method",
      "constructor": "StringSchema",
      "cons": "StringSchema",
      "name": "cast",
      "string": "StringSchema.prototype.cast()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Module exports.</p>",
      "summary": "<p>Module exports.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 258,
    "codeStart": 262,
    "code": "module.exports = StringSchema;",
    "ctx": {
      "type": "property",
      "receiver": "module",
      "name": "exports",
      "value": "StringSchema",
      "string": "module.exports"
    }
  }
]
### lib/schema.js
[
  {
    "tags": [],
    "description": {
      "full": "<p>Module dependencies.</p>",
      "summary": "<p>Module dependencies.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 1,
    "codeStart": 5,
    "code": "var Events = require('./events')\n  , VirtualType = require('./virtualtype')\n  , utils = require('./utils')\n  , Types\n  , schemas;",
    "ctx": {
      "type": "declaration",
      "name": "Events",
      "value": "require('./events')",
      "string": "Events"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String",
          "undefined"
        ],
        "name": "[name]",
        "description": "Название схемы",
        "optional": true
      },
      {
        "type": "param",
        "types": [
          "Schema"
        ],
        "name": "[baseSchema]",
        "description": "Базовая схема при наследовании",
        "optional": true
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "obj",
        "description": "Схема",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "[options]",
        "description": "",
        "optional": true
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Schema constructor.</p><h4>Example:</h4>\n<pre><code>var child = new Schema({ name: String });\nvar schema = new Schema({ name: String, age: Number, children: [child] });\nvar Tree = mongoose.model(&#39;Tree&#39;, schema);\n\n// setting schema options\nnew Schema({ name: String }, { _id: false, autoIndex: false })\n</code></pre><h4>Options:</h4>\n<ul>\n<li><a href=\"/docs/guide.html#collection\">collection</a>: string - no default</li>\n<li><a href=\"/docs/guide.html#id\">id</a>: bool - defaults to true</li>\n<li><code>minimize</code>: bool - controls <a href=\"#document_Document-toObject\">document#toObject</a> behavior when called manually - defaults to true</li>\n<li><a href=\"/docs/guide.html#strict\">strict</a>: bool - defaults to true</li>\n<li><a href=\"/docs/guide.html#toJSON\">toJSON</a> - object - no default</li>\n<li><a href=\"/docs/guide.html#toObject\">toObject</a> - object - no default</li>\n<li><a href=\"/docs/guide.html#versionKey\">versionKey</a>: bool - defaults to &quot;__v&quot;</li>\n</ul>\n<h4>Note:</h4>\n<p><em>When nesting schemas, (<code>children</code> in the example above), always declare the child schema first before passing it into is parent.</em></p>",
      "summary": "<p>Schema constructor.</p>",
      "body": "<h4>Example:</h4>\n<pre><code>var child = new Schema({ name: String });\nvar schema = new Schema({ name: String, age: Number, children: [child] });\nvar Tree = mongoose.model(&#39;Tree&#39;, schema);\n\n// setting schema options\nnew Schema({ name: String }, { _id: false, autoIndex: false })\n</code></pre><h4>Options:</h4>\n<ul>\n<li><a href=\"/docs/guide.html#collection\">collection</a>: string - no default</li>\n<li><a href=\"/docs/guide.html#id\">id</a>: bool - defaults to true</li>\n<li><code>minimize</code>: bool - controls <a href=\"#document_Document-toObject\">document#toObject</a> behavior when called manually - defaults to true</li>\n<li><a href=\"/docs/guide.html#strict\">strict</a>: bool - defaults to true</li>\n<li><a href=\"/docs/guide.html#toJSON\">toJSON</a> - object - no default</li>\n<li><a href=\"/docs/guide.html#toObject\">toObject</a> - object - no default</li>\n<li><a href=\"/docs/guide.html#versionKey\">versionKey</a>: bool - defaults to &quot;__v&quot;</li>\n</ul>\n<h4>Note:</h4>\n<p><em>When nesting schemas, (<code>children</code> in the example above), always declare the child schema first before passing it into is parent.</em></p>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 11,
    "codeStart": 43,
    "code": "function Schema ( name, baseSchema, obj, options ) {\n  if ( !(this instanceof Schema) )\n    return new Schema( name, baseSchema, obj, options );\n\n  // Если это именованая схема\n  if ( typeof name === 'string' ){\n    this.name = name;\n    schemas[ name ] = this;\n  } else {\n    options = obj;\n    obj = baseSchema;\n    baseSchema = name;\n    name = undefined;\n  }\n\n  if ( !(baseSchema instanceof Schema) ){\n    options = obj;\n    obj = baseSchema;\n    baseSchema = undefined;\n  }\n\n  // Сохраним описание схемы для поддержки дискриминаторов\n  this.source = obj;\n\n  this.paths = {};\n  this.subpaths = {};\n  this.virtuals = {};\n  this.nested = {};\n  this.inherits = {};\n  this.callQueue = [];\n  this.methods = {};\n  this.statics = {};\n  this.tree = {};\n  this._requiredpaths = undefined;\n  this.discriminatorMapping = undefined;\n\n  this.options = this.defaultOptions( options );\n\n  if ( baseSchema instanceof Schema ){\n    baseSchema.discriminator( name, this );\n  }\n\n  // build paths\n  if ( obj ) {\n    this.add( obj );\n  }\n\n  // ensure the documents get an auto _id unless disabled\n  var auto_id = !this.paths['_id'] && (!this.options.noId && this.options._id);\n  if (auto_id) {\n    this.add({ _id: {type: Schema.ObjectId, auto: true} });\n  }\n\n  // ensure the documents receive an id getter unless disabled\n  var autoid = !this.paths['id'] && this.options.id;\n  if ( autoid ) {\n    this.virtual('id').get( idGetter );\n  }\n}",
    "ctx": {
      "type": "function",
      "name": "Schema",
      "string": "Schema()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Returns this documents _id cast to a string.</p>",
      "summary": "<p>Returns this documents _id cast to a string.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 103,
    "codeStart": 106,
    "code": "function idGetter () {\n  if (this.$__._id) {\n    return this.$__._id;\n  }\n\n  return this.$__._id = null == this._id\n    ? null\n    : String(this._id);\n}",
    "ctx": {
      "type": "function",
      "name": "idGetter",
      "string": "idGetter()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Inherit from EventEmitter.</p>",
      "summary": "<p>Inherit from EventEmitter.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 116,
    "codeStart": 119,
    "code": "Schema.prototype = Object.create( Events.prototype );\nSchema.prototype.constructor = Schema;",
    "ctx": {
      "type": "property",
      "receiver": "Schema",
      "name": "prototype",
      "value": "Object.create( Events.prototype )",
      "string": "Schema.prototype"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      },
      {
        "type": "property",
        "types": [
          "paths"
        ],
        "name": "",
        "description": "",
        "optional": false
      }
    ],
    "description": {
      "full": "<p>Schema as flat paths</p><h4>Example:</h4>\n<pre><code>{\n    &#39;_id&#39;        : SchemaType,\n  , &#39;nested.key&#39; : SchemaType,\n}\n</code></pre>",
      "summary": "<p>Schema as flat paths</p>",
      "body": "<h4>Example:</h4>\n<pre><code>{\n    &#39;_id&#39;        : SchemaType,\n  , &#39;nested.key&#39; : SchemaType,\n}\n</code></pre>"
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": false,
    "line": 122,
    "codeStart": 134,
    "code": "Schema.prototype.paths;",
    "ctx": {
      "type": "property",
      "constructor": "Schema",
      "cons": "Schema",
      "name": "paths",
      "string": "Schema.prototype.paths"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      },
      {
        "type": "property",
        "types": [
          "tree"
        ],
        "name": "",
        "description": "",
        "optional": false
      }
    ],
    "description": {
      "full": "<p>Schema as a tree</p><h4>Example:</h4>\n<pre><code>{\n    &#39;_id&#39;     : ObjectId\n  , &#39;nested&#39;  : {\n        &#39;key&#39; : String\n    }\n}\n</code></pre>",
      "summary": "<p>Schema as a tree</p>",
      "body": "<h4>Example:</h4>\n<pre><code>{\n    &#39;_id&#39;     : ObjectId\n  , &#39;nested&#39;  : {\n        &#39;key&#39; : String\n    }\n}\n</code></pre>"
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": false,
    "line": 136,
    "codeStart": 150,
    "code": "Schema.prototype.tree;",
    "ctx": {
      "type": "property",
      "constructor": "Schema",
      "cons": "Schema",
      "name": "tree",
      "string": "Schema.prototype.tree"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "options",
        "description": "",
        "optional": false
      },
      {
        "type": "return",
        "types": [
          "Object"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Returns default options for this schema, merged with <code>options</code>.</p>",
      "summary": "<p>Returns default options for this schema, merged with <code>options</code>.</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": false,
    "line": 152,
    "codeStart": 159,
    "code": "Schema.prototype.defaultOptions = function (options) {\n  options = $.extend({\n      strict: true\n    , versionKey: '__v'\n    , discriminatorKey: '__t'\n    , minimize: true\n    // the following are only applied at construction time\n    , _id: true\n    , id: true\n  }, options );\n\n  return options;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Schema",
      "cons": "Schema",
      "name": "defaultOptions",
      "string": "Schema.prototype.defaultOptions()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "obj",
        "description": "",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "prefix",
        "description": "",
        "optional": false
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Adds key path / schema type pairs to this schema.</p><h4>Example:</h4>\n<pre><code>var ToySchema = new Schema;\nToySchema.add({ name: &#39;string&#39;, color: &#39;string&#39;, price: &#39;number&#39; });\n</code></pre>",
      "summary": "<p>Adds key path / schema type pairs to this schema.</p>",
      "body": "<h4>Example:</h4>\n<pre><code>var ToySchema = new Schema;\nToySchema.add({ name: &#39;string&#39;, color: &#39;string&#39;, price: &#39;number&#39; });\n</code></pre>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 173,
    "codeStart": 185,
    "code": "Schema.prototype.add = function add ( obj, prefix ) {\n  prefix = prefix || '';\n  var keys = Object.keys( obj );\n\n  for (var i = 0; i < keys.length; ++i) {\n    var key = keys[i];\n\n    if (null == obj[ key ]) {\n      throw new TypeError('Invalid value for schema path `'+ prefix + key +'`');\n    }\n\n    if ( _.isPlainObject(obj[key] )\n      && ( !obj[ key ].constructor || 'Object' == utils.getFunctionName(obj[key].constructor) )\n      && ( !obj[ key ].type || obj[ key ].type.type ) ){\n\n      if ( Object.keys(obj[ key ]).length ) {\n        // nested object { last: { name: String }}\n        this.nested[ prefix + key ] = true;\n        this.add( obj[ key ], prefix + key + '.');\n\n      } else {\n        this.path( prefix + key, obj[ key ] ); // mixed type\n      }\n\n    } else {\n      this.path( prefix + key, obj[ key ] );\n    }\n  }\n};",
    "ctx": {
      "type": "method",
      "constructor": "Schema",
      "cons": "Schema",
      "name": "add",
      "string": "Schema.prototype.add()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Reserved document keys.</p><p>Keys in this object are names that are rejected in schema declarations b/c they conflict with mongoose functionality. Using these key name will throw an error.</p><pre><code> on, emit, _events, db, get, set, init, isNew, errors, schema, options, modelName, collection, _pres, _posts, toObject\n</code></pre><p><em>NOTE:</em> Use of these terms as method names is permitted, but play at your own risk, as they may be existing mongoose document methods you are stomping on.</p><pre><code> var schema = new Schema(..);\n schema.methods.init = function () {} // potentially breaking\n</code></pre>",
      "summary": "<p>Reserved document keys.</p>",
      "body": "<p>Keys in this object are names that are rejected in schema declarations b/c they conflict with mongoose functionality. Using these key name will throw an error.</p><pre><code> on, emit, _events, db, get, set, init, isNew, errors, schema, options, modelName, collection, _pres, _posts, toObject\n</code></pre><p><em>NOTE:</em> Use of these terms as method names is permitted, but play at your own risk, as they may be existing mongoose document methods you are stomping on.</p><pre><code> var schema = new Schema(..);\n schema.methods.init = function () {} // potentially breaking\n</code></pre>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 215,
    "codeStart": 227,
    "code": "Schema.reserved = Object.create( null );\nvar reserved = Schema.reserved;\nreserved.on =\nreserved.db =\nreserved.get =\nreserved.set =\nreserved.init =\nreserved.isNew =\nreserved.errors =\nreserved.schema =\nreserved.options =\nreserved.modelName =\nreserved.collection =\nreserved.toObject =\nreserved.domain =\nreserved.emit =    // EventEmitter\nreserved._events = // EventEmitter\nreserved._pres = reserved._posts = 1; // hooks.js",
    "ctx": {
      "type": "property",
      "receiver": "Schema",
      "name": "reserved",
      "value": "Object.create( null )",
      "string": "Schema.reserved"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "path",
        "description": "",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "constructor",
        "description": "",
        "optional": false
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Gets/sets schema paths.</p><p>Sets a path (if arity 2)<br />Gets a path (if arity 1)</p><h4>Example</h4>\n<pre><code>schema.path(&#39;name&#39;) // returns a SchemaType\nschema.path(&#39;name&#39;, Number) // changes the schemaType of `name` to Number\n</code></pre>",
      "summary": "<p>Gets/sets schema paths.</p>",
      "body": "<p>Sets a path (if arity 2)<br />Gets a path (if arity 1)</p><h4>Example</h4>\n<pre><code>schema.path(&#39;name&#39;) // returns a SchemaType\nschema.path(&#39;name&#39;, Number) // changes the schemaType of `name` to Number\n</code></pre>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 246,
    "codeStart": 261,
    "code": "Schema.prototype.path = function (path, obj) {\n  if (obj == undefined) {\n    if (this.paths[path]) return this.paths[path];\n    if (this.subpaths[path]) return this.subpaths[path];\n\n    // subpaths?\n    return /\\.\\d+\\.?.*$/.test(path)\n      ? getPositionalPath(this, path)\n      : undefined;\n  }\n\n  // some path names conflict with document methods\n  if (reserved[path]) {\n    throw new Error(\"`\" + path + \"` may not be used as a schema pathname\");\n  }\n\n  // update the tree\n  var subpaths = path.split(/\\./)\n    , last = subpaths.pop()\n    , branch = this.tree;\n\n  subpaths.forEach(function(sub, i) {\n    if (!branch[sub]) branch[sub] = {};\n    if ('object' != typeof branch[sub]) {\n      var msg = 'Cannot set nested path `' + path + '`. '\n              + 'Parent path `'\n              + subpaths.slice(0, i).concat([sub]).join('.')\n              + '` already set to type ' + branch[sub].name\n              + '.';\n      throw new Error(msg);\n    }\n    branch = branch[sub];\n  });\n\n  branch[last] = utils.clone(obj);\n\n  this.paths[path] = Schema.interpretAsType(path, obj);\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Schema",
      "cons": "Schema",
      "name": "path",
      "string": "Schema.prototype.path()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "path",
        "description": "",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "obj",
        "description": "constructor",
        "optional": false
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Converts type arguments into Schema Types.</p>",
      "summary": "<p>Converts type arguments into Schema Types.</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": false,
    "line": 301,
    "codeStart": 308,
    "code": "Schema.interpretAsType = function (path, obj) {\n  var constructorName = utils.getFunctionName(obj.constructor);\n  if (constructorName != 'Object'){\n    obj = { type: obj };\n  }\n\n  // Get the type making sure to allow keys named \"type\"\n  // and default to mixed if not specified.\n  // { type: { type: String, default: 'freshcut' } }\n  var type = obj.type && !obj.type.type\n    ? obj.type\n    : {};\n\n  if ('Object' == utils.getFunctionName(type.constructor) || 'mixed' == type) {\n    return new Types.Mixed(path, obj);\n  }\n\n  if (Array.isArray(type) || Array == type || 'array' == type) {\n    // if it was specified through { type } look for `cast`\n    var cast = (Array == type || 'array' == type)\n      ? obj.cast\n      : type[0];\n\n    if (cast instanceof Schema) {\n      return new Types.DocumentArray(path, cast, obj);\n    }\n\n    if ('string' == typeof cast) {\n      cast = Types[cast.charAt(0).toUpperCase() + cast.substring(1)];\n    } else if (cast && (!cast.type || cast.type.type)\n                    && 'Object' == utils.getFunctionName(cast.constructor)\n                    && Object.keys(cast).length) {\n      return new Types.DocumentArray(path, new Schema(cast), obj);\n    }\n\n    return new Types.Array(path, cast || Types.Mixed, obj);\n  }\n\n  var name = 'string' == typeof type\n    ? type\n    // If not string, `type` is a function. Outside of IE, function.name\n    // gives you the function name. In IE, you need to compute it\n    : utils.getFunctionName(type);\n\n  if (name) {\n    name = name.charAt(0).toUpperCase() + name.substring(1);\n  }\n\n  if (undefined == Types[name]) {\n    throw new TypeError('Undefined type at `' + path +\n        '`\\n  Did you try nesting Schemas? ' +\n        'You can only nest using refs or arrays.');\n  }\n\n  return new Types[name](path, obj);\n};",
    "ctx": {
      "type": "method",
      "receiver": "Schema",
      "name": "interpretAsType",
      "string": "Schema.interpretAsType()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "fn",
        "description": "callback function",
        "optional": false
      },
      {
        "type": "return",
        "types": [
          "Schema"
        ],
        "description": "this"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Iterates the schemas paths similar to Array#forEach.</p><p>The callback is passed the pathname and schemaType as arguments on each iteration.</p>",
      "summary": "<p>Iterates the schemas paths similar to Array#forEach.</p>",
      "body": "<p>The callback is passed the pathname and schemaType as arguments on each iteration.</p>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 365,
    "codeStart": 374,
    "code": "Schema.prototype.eachPath = function (fn) {\n  var keys = Object.keys(this.paths)\n    , len = keys.length;\n\n  for (var i = 0; i < len; ++i) {\n    fn(keys[i], this.paths[keys[i]]);\n  }\n\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Schema",
      "cons": "Schema",
      "name": "eachPath",
      "string": "Schema.prototype.eachPath()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      },
      {
        "type": "return",
        "types": [
          "Array"
        ],
        "description": ""
      }
    ],
    "description": {
      "full": "<p>Returns an Array of path strings that are required by this schema.</p>",
      "summary": "<p>Returns an Array of path strings that are required by this schema.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 385,
    "codeStart": 391,
    "code": "Schema.prototype.requiredPaths = function requiredPaths () {\n  if (this._requiredpaths) return this._requiredpaths;\n\n  var paths = Object.keys(this.paths)\n    , i = paths.length\n    , ret = [];\n\n  while (i--) {\n    var path = paths[i];\n    if (this.paths[path].isRequired) ret.push(path);\n  }\n\n  return this._requiredpaths = ret;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Schema",
      "cons": "Schema",
      "name": "requiredPaths",
      "string": "Schema.prototype.requiredPaths()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "path",
        "description": "",
        "optional": false
      },
      {
        "type": "return",
        "types": [
          "String"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Returns the pathType of <code>path</code> for this schema.</p><p>Given a path, returns whether it is a real, virtual, nested, or ad-hoc/undefined path.</p>",
      "summary": "<p>Returns the pathType of <code>path</code> for this schema.</p>",
      "body": "<p>Given a path, returns whether it is a real, virtual, nested, or ad-hoc/undefined path.</p>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 406,
    "codeStart": 415,
    "code": "Schema.prototype.pathType = function (path) {\n  if (path in this.paths) return 'real';\n  if (path in this.virtuals) return 'virtual';\n  if (path in this.nested) return 'nested';\n  if (path in this.subpaths) return 'real';\n\n  if (/\\.\\d+\\.|\\.\\d+$/.test(path) && getPositionalPath(this, path)) {\n    return 'real';\n  } else {\n    return 'adhocOrUndefined'\n  }\n};",
    "ctx": {
      "type": "method",
      "constructor": "Schema",
      "cons": "Schema",
      "name": "pathType",
      "string": "Schema.prototype.pathType()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>ignore</p>",
      "summary": "<p>ignore</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 428,
    "codeStart": 431,
    "code": "function getPositionalPath (self, path) {\n  var subpaths = path.split(/\\.(\\d+)\\.|\\.(\\d+)$/).filter(Boolean);\n  if (subpaths.length < 2) {\n    return self.paths[subpaths[0]];\n  }\n\n  var val = self.path(subpaths[0]);\n  if (!val) return val;\n\n  var last = subpaths.length - 1\n    , subpath\n    , i = 1;\n\n  for (; i < subpaths.length; ++i) {\n    subpath = subpaths[i];\n\n    if (i === last && val && !val.schema && !/\\D/.test(subpath)) {\n      if (val instanceof Types.Array) {\n        // StringSchema, NumberSchema, etc\n        val = val.caster;\n      } else {\n        val = undefined;\n      }\n      break;\n    }\n\n    // ignore if its just a position segment: path.0.subpath\n    if (!/\\D/.test(subpath)) continue;\n\n    if (!(val && val.schema)) {\n      val = undefined;\n      break;\n    }\n\n    val = val.schema.path(subpath);\n  }\n\n  return self.subpaths[path] = val;\n}",
    "ctx": {
      "type": "function",
      "name": "getPositionalPath",
      "string": "getPositionalPath()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "name",
        "description": "name of the document method to call later",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "Array"
        ],
        "name": "args",
        "description": "arguments to pass to the method",
        "optional": false
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Adds a method call to the queue.</p>",
      "summary": "<p>Adds a method call to the queue.</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": false,
    "line": 471,
    "codeStart": 478,
    "code": "Schema.prototype.queue = function(name, args){\n  this.callQueue.push([name, args]);\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Schema",
      "cons": "Schema",
      "name": "queue",
      "string": "Schema.prototype.queue()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "method",
        "description": "",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "callback",
        "description": "",
        "optional": false
      },
      {
        "type": "see",
        "title": "hooks.js",
        "url": "https://github.com/bnoguchi/hooks-js/tree/31ec571cef0332e21121ee7157e0cf9728572cc3"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Defines a pre hook for the document.</p><h4>Example</h4>\n<pre><code>var toySchema = new Schema(..);\n\ntoySchema.pre(&#39;save&#39;, function (next) {\n  if (!this.created) this.created = new Date;\n  next();\n})\n\ntoySchema.pre(&#39;validate&#39;, function (next) {\n  if (this.name != &#39;Woody&#39;) this.name = &#39;Woody&#39;;\n  next();\n})\n</code></pre>",
      "summary": "<p>Defines a pre hook for the document.</p>",
      "body": "<h4>Example</h4>\n<pre><code>var toySchema = new Schema(..);\n\ntoySchema.pre(&#39;save&#39;, function (next) {\n  if (!this.created) this.created = new Date;\n  next();\n})\n\ntoySchema.pre(&#39;validate&#39;, function (next) {\n  if (this.name != &#39;Woody&#39;) this.name = &#39;Woody&#39;;\n  next();\n})\n</code></pre>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 483,
    "codeStart": 505,
    "code": "Schema.prototype.pre = function(){\n  return this.queue('pre', arguments);\n};",
    "ctx": {
      "type": "method",
      "constructor": "Schema",
      "cons": "Schema",
      "name": "pre",
      "string": "Schema.prototype.pre()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "method",
        "description": "name of the method to hook",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "fn",
        "description": "callback",
        "optional": false
      },
      {
        "type": "see",
        "title": "hooks.js",
        "url": "https://github.com/bnoguchi/hooks-js/tree/31ec571cef0332e21121ee7157e0cf9728572cc3"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Defines a post for the document</p><p>Post hooks fire <code>on</code> the event emitted from document instances of Models compiled from this schema.</p><pre><code>var schema = new Schema(..);\nschema.post(&#39;save&#39;, function (doc) {\n  console.log(&#39;this fired after a document was saved&#39;);\n});\n\nvar Model = mongoose.model(&#39;Model&#39;, schema);\n\nvar m = new Model(..);\nm.save(function (err) {\n  console.log(&#39;this fires after the `post` hook&#39;);\n});\n</code></pre>",
      "summary": "<p>Defines a post for the document</p>",
      "body": "<p>Post hooks fire <code>on</code> the event emitted from document instances of Models compiled from this schema.</p><pre><code>var schema = new Schema(..);\nschema.post(&#39;save&#39;, function (doc) {\n  console.log(&#39;this fired after a document was saved&#39;);\n});\n\nvar Model = mongoose.model(&#39;Model&#39;, schema);\n\nvar m = new Model(..);\nm.save(function (err) {\n  console.log(&#39;this fires after the `post` hook&#39;);\n});\n</code></pre>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 509,
    "codeStart": 531,
    "code": "Schema.prototype.post = function(method, fn){\n  return this.queue('on', arguments);\n};",
    "ctx": {
      "type": "method",
      "constructor": "Schema",
      "cons": "Schema",
      "name": "post",
      "string": "Schema.prototype.post()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "plugin",
        "description": "callback",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "opts",
        "description": "",
        "optional": false
      },
      {
        "type": "see",
        "local": "plugins"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Registers a plugin for this schema.</p>",
      "summary": "<p>Registers a plugin for this schema.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 535,
    "codeStart": 543,
    "code": "Schema.prototype.plugin = function (fn, opts) {\n  fn(this, opts);\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Schema",
      "cons": "Schema",
      "name": "plugin",
      "string": "Schema.prototype.plugin()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String",
          "Object"
        ],
        "name": "method",
        "description": "name",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "[fn]",
        "description": "",
        "optional": true
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Adds an instance method to documents constructed from Models compiled from this schema.</p><h4>Example</h4>\n<pre><code>var schema = kittySchema = new Schema(..);\n\nschema.method(&#39;meow&#39;, function () {\n  console.log(&#39;meeeeeoooooooooooow&#39;);\n})\n\nvar Kitty = mongoose.model(&#39;Kitty&#39;, schema);\n\nvar fizz = new Kitty;\nfizz.meow(); // meeeeeooooooooooooow\n</code></pre><p>If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as methods.</p><pre><code>schema.method({\n    purr: function () {}\n  , scratch: function () {}\n});\n\n// later\nfizz.purr();\nfizz.scratch();\n</code></pre>",
      "summary": "<p>Adds an instance method to documents constructed from Models compiled from this schema.</p>",
      "body": "<h4>Example</h4>\n<pre><code>var schema = kittySchema = new Schema(..);\n\nschema.method(&#39;meow&#39;, function () {\n  console.log(&#39;meeeeeoooooooooooow&#39;);\n})\n\nvar Kitty = mongoose.model(&#39;Kitty&#39;, schema);\n\nvar fizz = new Kitty;\nfizz.meow(); // meeeeeooooooooooooow\n</code></pre><p>If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as methods.</p><pre><code>schema.method({\n    purr: function () {}\n  , scratch: function () {}\n});\n\n// later\nfizz.purr();\nfizz.scratch();\n</code></pre>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 548,
    "codeStart": 579,
    "code": "Schema.prototype.method = function (name, fn) {\n  if ('string' != typeof name)\n    for (var i in name)\n      this.methods[i] = name[i];\n  else\n    this.methods[name] = fn;\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Schema",
      "cons": "Schema",
      "name": "method",
      "string": "Schema.prototype.method()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "name",
        "description": "",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "fn",
        "description": "",
        "optional": false
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Adds static &quot;class&quot; methods to Models compiled from this schema.</p><h4>Example</h4>\n<pre><code>var schema = new Schema(..);\nschema.static(&#39;findByName&#39;, function (name, callback) {\n  return this.find({ name: name }, callback);\n});\n\nvar Drink = mongoose.model(&#39;Drink&#39;, schema);\nDrink.findByName(&#39;sanpellegrino&#39;, function (err, drinks) {\n  //\n});\n</code></pre><p>If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as statics.</p>",
      "summary": "<p>Adds static &quot;class&quot; methods to Models compiled from this schema.</p>",
      "body": "<h4>Example</h4>\n<pre><code>var schema = new Schema(..);\nschema.static(&#39;findByName&#39;, function (name, callback) {\n  return this.find({ name: name }, callback);\n});\n\nvar Drink = mongoose.model(&#39;Drink&#39;, schema);\nDrink.findByName(&#39;sanpellegrino&#39;, function (err, drinks) {\n  //\n});\n</code></pre><p>If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as statics.</p>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 588,
    "codeStart": 609,
    "code": "Schema.prototype.static = function(name, fn) {\n  if ('string' != typeof name)\n    for (var i in name)\n      this.statics[i] = name[i];\n  else\n    this.statics[name] = fn;\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Schema",
      "cons": "Schema",
      "name": "static",
      "string": "Schema.prototype.static()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "key",
        "description": "option name",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "[value]",
        "description": "if not passed, the current option value is returned",
        "optional": true
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Sets/gets a schema option.</p>",
      "summary": "<p>Sets/gets a schema option.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 618,
    "codeStart": 625,
    "code": "Schema.prototype.set = function (key, value) {\n  if (1 === arguments.length) {\n    return this.options[key];\n  }\n\n  this.options[key] = value;\n\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Schema",
      "cons": "Schema",
      "name": "set",
      "string": "Schema.prototype.set()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "key",
        "description": "option name",
        "optional": false
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Gets a schema option.</p>",
      "summary": "<p>Gets a schema option.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 635,
    "codeStart": 642,
    "code": "Schema.prototype.get = function (key) {\n  return this.options[key];\n};",
    "ctx": {
      "type": "method",
      "constructor": "Schema",
      "cons": "Schema",
      "name": "get",
      "string": "Schema.prototype.get()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "name",
        "description": "",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "[options]",
        "description": "",
        "optional": true
      },
      {
        "type": "return",
        "types": [
          "VirtualType"
        ],
        "description": ""
      }
    ],
    "description": {
      "full": "<p>Creates a virtual type with the given name.</p>",
      "summary": "<p>Creates a virtual type with the given name.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 646,
    "codeStart": 654,
    "code": "Schema.prototype.virtual = function (name, options) {\n  var virtuals = this.virtuals;\n  var parts = name.split('.');\n  return virtuals[name] = parts.reduce(function (mem, part, i) {\n    mem[part] || (mem[part] = (i === parts.length-1)\n                            ? new VirtualType(options, name)\n                            : {});\n    return mem[part];\n  }, this.tree);\n};",
    "ctx": {
      "type": "method",
      "constructor": "Schema",
      "cons": "Schema",
      "name": "virtual",
      "string": "Schema.prototype.virtual()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "name",
        "description": "",
        "optional": false
      },
      {
        "type": "return",
        "types": [
          "VirtualType"
        ],
        "description": ""
      }
    ],
    "description": {
      "full": "<p>Returns the virtual type with the given <code>name</code>.</p>",
      "summary": "<p>Returns the virtual type with the given <code>name</code>.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 665,
    "codeStart": 672,
    "code": "Schema.prototype.virtualpath = function (name) {\n  return this.virtuals[name];\n};",
    "ctx": {
      "type": "method",
      "constructor": "Schema",
      "cons": "Schema",
      "name": "virtualpath",
      "string": "Schema.prototype.virtualpath()"
    }
  },
  {
    "tags": [
      {
        "type": "property",
        "types": [
          "discriminators"
        ],
        "name": "",
        "description": "",
        "optional": false
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Registered discriminators for this schema.</p>",
      "summary": "<p>Registered discriminators for this schema.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 676,
    "codeStart": 682,
    "code": "Schema.discriminators;"
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "name",
        "description": "discriminator name",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "Schema"
        ],
        "name": "schema",
        "description": "discriminator schema",
        "optional": false
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Наследование от схемы.<br />this - базовая схема!!!</p><h4>Example:</h4>\n<pre><code>var PersonSchema = new Schema(&#39;Person&#39;, {\n  name: String,\n  createdAt: Date\n});\n\nvar BossSchema = new Schema(&#39;Boss&#39;, PersonSchema, { department: String });\n</code></pre>",
      "summary": "<p>Наследование от схемы.<br />this - базовая схема!!!</p>",
      "body": "<h4>Example:</h4>\n<pre><code>var PersonSchema = new Schema(&#39;Person&#39;, {\n  name: String,\n  createdAt: Date\n});\n\nvar BossSchema = new Schema(&#39;Boss&#39;, PersonSchema, { department: String });\n</code></pre>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 684,
    "codeStart": 700,
    "code": "Schema.prototype.discriminator = function discriminator (name, schema) {\n  if (!(schema instanceof Schema)) {\n    throw new Error(\"You must pass a valid discriminator Schema\");\n  }\n\n  if ( this.discriminatorMapping && !this.discriminatorMapping.isRoot ) {\n    throw new Error(\"Discriminator \\\"\" + name + \"\\\" can only be a discriminator of the root model\");\n  }\n\n  var key = this.options.discriminatorKey;\n  if ( schema.path(key) ) {\n    throw new Error(\"Discriminator \\\"\" + name + \"\\\" cannot have field with name \\\"\" + key + \"\\\"\");\n  }\n\n  // merges base schema into new discriminator schema and sets new type field.\n  (function mergeSchemas(schema, baseSchema) {\n    utils.merge(schema, baseSchema);\n\n    var obj = {};\n    obj[key] = { type: String, default: name };\n    schema.add(obj);\n    schema.discriminatorMapping = { key: key, value: name, isRoot: false };\n\n    if (baseSchema.options.collection) {\n      schema.options.collection = baseSchema.options.collection;\n    }\n\n      // throws error if options are invalid\n    (function validateOptions(a, b) {\n      a = utils.clone(a);\n      b = utils.clone(b);\n      delete a.toJSON;\n      delete a.toObject;\n      delete b.toJSON;\n      delete b.toObject;\n\n      if (!utils.deepEqual(a, b)) {\n        throw new Error(\"Discriminator options are not customizable (except toJSON & toObject)\");\n      }\n    })(schema.options, baseSchema.options);\n\n    var toJSON = schema.options.toJSON\n      , toObject = schema.options.toObject;\n\n    schema.options = utils.clone(baseSchema.options);\n    if (toJSON)   schema.options.toJSON = toJSON;\n    if (toObject) schema.options.toObject = toObject;\n\n    //schema.callQueue = baseSchema.callQueue.concat(schema.callQueue);\n    schema._requiredpaths = undefined; // reset just in case Schema#requiredPaths() was called on either schema\n  })(schema, this);\n\n  if (!this.discriminators) {\n    this.discriminators = {};\n  }\n\n  if (!this.discriminatorMapping) {\n    this.discriminatorMapping = { key: key, value: null, isRoot: true };\n  }\n\n  if (this.discriminators[name]) {\n    throw new Error(\"Discriminator with name \\\"\" + name + \"\\\" already exists\");\n  }\n\n  this.discriminators[name] = schema;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Schema",
      "cons": "Schema",
      "name": "discriminator",
      "string": "Schema.prototype.discriminator()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>exports</p>",
      "summary": "<p>exports</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 767,
    "codeStart": 771,
    "code": "module.exports = Schema;\nwindow.Schema = Schema;\n\n// require down here because of reference issues",
    "ctx": {
      "type": "property",
      "receiver": "module",
      "name": "exports",
      "value": "Schema",
      "string": "module.exports"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>The various built-in Storage Schema Types.</p><h4>Example:</h4>\n<pre><code>var mongoose = require(&#39;mongoose&#39;);\nvar ObjectId = mongoose.Schema.Types.ObjectId;\n</code></pre><h4>Types:</h4>\n<ul>\n<li><a href=\"#schema-string-js\">String</a></li>\n<li><a href=\"#schema-number-js\">Number</a></li>\n<li><a href=\"#schema-boolean-js\">Boolean</a> | Bool</li>\n<li><a href=\"#schema-array-js\">Array</a></li>\n<li><a href=\"#schema-date-js\">Date</a></li>\n<li><a href=\"#schema-objectid-js\">ObjectId</a> | Oid</li>\n<li><a href=\"#schema-mixed-js\">Mixed</a> | Object</li>\n</ul>\n<p>Using this exposed access to the <code>Mixed</code> SchemaType, we can use them in our schema.</p><pre><code>var Mixed = mongoose.Schema.Types.Mixed;\nnew mongoose.Schema({ _user: Mixed })\n</code></pre>",
      "summary": "<p>The various built-in Storage Schema Types.</p>",
      "body": "<h4>Example:</h4>\n<pre><code>var mongoose = require(&#39;mongoose&#39;);\nvar ObjectId = mongoose.Schema.Types.ObjectId;\n</code></pre><h4>Types:</h4>\n<ul>\n<li><a href=\"#schema-string-js\">String</a></li>\n<li><a href=\"#schema-number-js\">Number</a></li>\n<li><a href=\"#schema-boolean-js\">Boolean</a> | Bool</li>\n<li><a href=\"#schema-array-js\">Array</a></li>\n<li><a href=\"#schema-date-js\">Date</a></li>\n<li><a href=\"#schema-objectid-js\">ObjectId</a> | Oid</li>\n<li><a href=\"#schema-mixed-js\">Mixed</a> | Object</li>\n</ul>\n<p>Using this exposed access to the <code>Mixed</code> SchemaType, we can use them in our schema.</p><pre><code>var Mixed = mongoose.Schema.Types.Mixed;\nnew mongoose.Schema({ _user: Mixed })\n</code></pre>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 776,
    "codeStart": 801,
    "code": "Schema.Types = require('./schema/index');\n\n// Хранилище схем\nSchema.schemas = schemas = {};",
    "ctx": {
      "type": "property",
      "receiver": "Schema",
      "name": "Types",
      "value": "require('./schema/index')",
      "string": "Schema.Types"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>ignore</p>",
      "summary": "<p>ignore</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 807,
    "codeStart": 811,
    "code": "Types = Schema.Types;\nvar ObjectId = Schema.ObjectId = Types.ObjectId;"
  }
]
### lib/schematype.js
[
  {
    "tags": [],
    "description": {
      "full": "<p>Module dependencies.</p>",
      "summary": "<p>Module dependencies.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 1,
    "codeStart": 5,
    "code": "var error = require('./error')\n  , utils = require('./utils');\n\nvar errorMessages = error.messages;\nvar CastError = error.CastError;\nvar ValidatorError = error.ValidatorError;",
    "ctx": {
      "type": "declaration",
      "name": "error",
      "value": "require('./error')",
      "string": "error"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "path",
        "description": "",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "[options]",
        "description": "",
        "optional": true
      },
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "[instance]",
        "description": "",
        "optional": true
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>SchemaType constructor</p>",
      "summary": "<p>SchemaType constructor</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 12,
    "codeStart": 21,
    "code": "function SchemaType (path, options, instance) {\n  this.path = path;\n  this.instance = instance;\n  this.validators = [];\n  this.setters = [];\n  this.getters = [];\n  this.options = options;\n\n  for (var i in options) if (this[i] && 'function' == typeof this[i]) {\n    var opts = Array.isArray(options[i])\n      ? options[i]\n      : [options[i]];\n\n    this[i].apply(this, opts);\n  }\n}",
    "ctx": {
      "type": "function",
      "name": "SchemaType",
      "string": "SchemaType()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Function",
          "any"
        ],
        "name": "val",
        "description": "the default value",
        "optional": false
      },
      {
        "type": "return",
        "types": [
          "defaultValue"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Sets a default value for this SchemaType.</p><h4>Example:</h4>\n<pre><code>var schema = new Schema({ n: { type: Number, default: 10 })\nvar M = db.model(&#39;M&#39;, schema)\nvar m = new M;\nconsole.log(m.n) // 10\n</code></pre><p>Defaults can be either <code>functions</code> which return the value to use as the default or the literal value itself. Either way, the value will be cast based on its schema type before being set during document creation.</p><h4>Example:</h4>\n<pre><code>// values are cast:\nvar schema = new Schema({ aNumber: Number, default: &quot;4.815162342&quot; })\nvar M = db.model(&#39;M&#39;, schema)\nvar m = new M;\nconsole.log(m.aNumber) // 4.815162342\n\n// default unique objects for Mixed types:\nvar schema = new Schema({ mixed: Schema.Types.Mixed });\nschema.path(&#39;mixed&#39;).default(function () {\n  return {};\n});\n\n// if we don&#39;t use a function to return object literals for Mixed defaults,\n// each document will receive a reference to the same object literal creating\n// a &quot;shared&quot; object instance:\nvar schema = new Schema({ mixed: Schema.Types.Mixed });\nschema.path(&#39;mixed&#39;).default({});\nvar M = db.model(&#39;M&#39;, schema);\nvar m1 = new M;\nm1.mixed.added = 1;\nconsole.log(m1.mixed); // { added: 1 }\nvar m2 = new M;\nconsole.log(m2.mixed); // { added: 1 }\n</code></pre>",
      "summary": "<p>Sets a default value for this SchemaType.</p>",
      "body": "<h4>Example:</h4>\n<pre><code>var schema = new Schema({ n: { type: Number, default: 10 })\nvar M = db.model(&#39;M&#39;, schema)\nvar m = new M;\nconsole.log(m.n) // 10\n</code></pre><p>Defaults can be either <code>functions</code> which return the value to use as the default or the literal value itself. Either way, the value will be cast based on its schema type before being set during document creation.</p><h4>Example:</h4>\n<pre><code>// values are cast:\nvar schema = new Schema({ aNumber: Number, default: &quot;4.815162342&quot; })\nvar M = db.model(&#39;M&#39;, schema)\nvar m = new M;\nconsole.log(m.aNumber) // 4.815162342\n\n// default unique objects for Mixed types:\nvar schema = new Schema({ mixed: Schema.Types.Mixed });\nschema.path(&#39;mixed&#39;).default(function () {\n  return {};\n});\n\n// if we don&#39;t use a function to return object literals for Mixed defaults,\n// each document will receive a reference to the same object literal creating\n// a &quot;shared&quot; object instance:\nvar schema = new Schema({ mixed: Schema.Types.Mixed });\nschema.path(&#39;mixed&#39;).default({});\nvar M = db.model(&#39;M&#39;, schema);\nvar m1 = new M;\nm1.mixed.added = 1;\nconsole.log(m1.mixed); // { added: 1 }\nvar m2 = new M;\nconsole.log(m2.mixed); // { added: 1 }\n</code></pre>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 38,
    "codeStart": 80,
    "code": "SchemaType.prototype.default = function (val) {\n  if (1 === arguments.length) {\n    this.defaultValue = typeof val === 'function'\n      ? val\n      : this.cast( val );\n\n    return this;\n\n  } else if ( arguments.length > 1 ) {\n    this.defaultValue = _.toArray( arguments );\n  }\n  return this.defaultValue;\n};",
    "ctx": {
      "type": "method",
      "constructor": "SchemaType",
      "cons": "SchemaType",
      "name": "default",
      "string": "SchemaType.prototype.default()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "fn",
        "description": "",
        "optional": false
      },
      {
        "type": "return",
        "types": [
          "SchemaType"
        ],
        "description": "this"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Adds a setter to this schematype.</p><h4>Example:</h4>\n<pre><code>function capitalize (val) {\n  if (&#39;string&#39; != typeof val) val = &#39;&#39;;\n  return val.charAt(0).toUpperCase() + val.substring(1);\n}\n\n// defining within the schema\nvar s = new Schema({ name: { type: String, set: capitalize }})\n\n// or by retreiving its SchemaType\nvar s = new Schema({ name: String })\ns.path(&#39;name&#39;).set(capitalize)\n</code></pre><p>Setters allow you to transform the data before it gets to the raw mongodb document and is set as a value on an actual key.</p><p>Suppose you are implementing user registration for a website. Users provide an email and password, which gets saved to mongodb. The email is a string that you will want to normalize to lower case, in order to avoid one email having more than one account -- e.g., otherwise, avenue@q.com can be registered for 2 accounts via avenue@q.com and AvEnUe@Q.CoM.</p><p>You can set up email lower case normalization easily via a Storage setter.</p><pre><code>function toLower (v) {\n  return v.toLowerCase();\n}\n\nvar UserSchema = new Schema({\n  email: { type: String, set: toLower }\n})\n\nvar User = db.model(&#39;User&#39;, UserSchema)\n\nvar user = new User({email: &#39;AVENUE@Q.COM&#39;})\nconsole.log(user.email); // &#39;avenue@q.com&#39;\n\n// or\nvar user = new User\nuser.email = &#39;Avenue@Q.com&#39;\nconsole.log(user.email) // &#39;avenue@q.com&#39;\n</code></pre><p>As you can see above, setters allow you to transform the data before it gets to the raw mongodb document and is set as a value on an actual key.</p><p><em>NOTE: we could have also just used the built-in <code>lowercase: true</code> SchemaType option instead of defining our own function.</em></p><pre><code>new Schema({ email: { type: String, lowercase: true }})\n</code></pre><p>Setters are also passed a second argument, the schematype on which the setter was defined. This allows for tailored behavior based on options passed in the schema.</p><pre><code>function inspector (val, schematype) {\n  if (schematype.options.required) {\n    return schematype.path + &#39; is required&#39;;\n  } else {\n    return val;\n  }\n}\n\nvar VirusSchema = new Schema({\n  name: { type: String, required: true, set: inspector },\n  taxonomy: { type: String, set: inspector }\n})\n\nvar Virus = db.model(&#39;Virus&#39;, VirusSchema);\nvar v = new Virus({ name: &#39;Parvoviridae&#39;, taxonomy: &#39;Parvovirinae&#39; });\n\nconsole.log(v.name);     // name is required\nconsole.log(v.taxonomy); // Parvovirinae\n</code></pre>",
      "summary": "<p>Adds a setter to this schematype.</p>",
      "body": "<h4>Example:</h4>\n<pre><code>function capitalize (val) {\n  if (&#39;string&#39; != typeof val) val = &#39;&#39;;\n  return val.charAt(0).toUpperCase() + val.substring(1);\n}\n\n// defining within the schema\nvar s = new Schema({ name: { type: String, set: capitalize }})\n\n// or by retreiving its SchemaType\nvar s = new Schema({ name: String })\ns.path(&#39;name&#39;).set(capitalize)\n</code></pre><p>Setters allow you to transform the data before it gets to the raw mongodb document and is set as a value on an actual key.</p><p>Suppose you are implementing user registration for a website. Users provide an email and password, which gets saved to mongodb. The email is a string that you will want to normalize to lower case, in order to avoid one email having more than one account -- e.g., otherwise, avenue@q.com can be registered for 2 accounts via avenue@q.com and AvEnUe@Q.CoM.</p><p>You can set up email lower case normalization easily via a Storage setter.</p><pre><code>function toLower (v) {\n  return v.toLowerCase();\n}\n\nvar UserSchema = new Schema({\n  email: { type: String, set: toLower }\n})\n\nvar User = db.model(&#39;User&#39;, UserSchema)\n\nvar user = new User({email: &#39;AVENUE@Q.COM&#39;})\nconsole.log(user.email); // &#39;avenue@q.com&#39;\n\n// or\nvar user = new User\nuser.email = &#39;Avenue@Q.com&#39;\nconsole.log(user.email) // &#39;avenue@q.com&#39;\n</code></pre><p>As you can see above, setters allow you to transform the data before it gets to the raw mongodb document and is set as a value on an actual key.</p><p><em>NOTE: we could have also just used the built-in <code>lowercase: true</code> SchemaType option instead of defining our own function.</em></p><pre><code>new Schema({ email: { type: String, lowercase: true }})\n</code></pre><p>Setters are also passed a second argument, the schematype on which the setter was defined. This allows for tailored behavior based on options passed in the schema.</p><pre><code>function inspector (val, schematype) {\n  if (schematype.options.required) {\n    return schematype.path + &#39; is required&#39;;\n  } else {\n    return val;\n  }\n}\n\nvar VirusSchema = new Schema({\n  name: { type: String, required: true, set: inspector },\n  taxonomy: { type: String, set: inspector }\n})\n\nvar Virus = db.model(&#39;Virus&#39;, VirusSchema);\nvar v = new Virus({ name: &#39;Parvoviridae&#39;, taxonomy: &#39;Parvovirinae&#39; });\n\nconsole.log(v.name);     // name is required\nconsole.log(v.taxonomy); // Parvovirinae\n</code></pre>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 94,
    "codeStart": 166,
    "code": "SchemaType.prototype.set = function (fn) {\n  if ('function' != typeof fn)\n    throw new TypeError('A setter must be a function.');\n  this.setters.push(fn);\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "SchemaType",
      "cons": "SchemaType",
      "name": "set",
      "string": "SchemaType.prototype.set()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "fn",
        "description": "",
        "optional": false
      },
      {
        "type": "return",
        "types": [
          "SchemaType"
        ],
        "description": "this"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Adds a getter to this schematype.</p><h4>Example:</h4>\n<pre><code>function dob (val) {\n  if (!val) return val;\n  return (val.getMonth() + 1) + &quot;/&quot; + val.getDate() + &quot;/&quot; + val.getFullYear();\n}\n\n// defining within the schema\nvar s = new Schema({ born: { type: Date, get: dob })\n\n// or by retreiving its SchemaType\nvar s = new Schema({ born: Date })\ns.path(&#39;born&#39;).get(dob)\n</code></pre><p>Getters allow you to transform the representation of the data as it travels from the raw mongodb document to the value that you see.</p><p>Suppose you are storing credit card numbers and you want to hide everything except the last 4 digits to the mongoose user. You can do so by defining a getter in the following way:</p><pre><code>function obfuscate (cc) {\n  return &#39;****-****-****-&#39; + cc.slice(cc.length-4, cc.length);\n}\n\nvar AccountSchema = new Schema({\n  creditCardNumber: { type: String, get: obfuscate }\n});\n\nvar Account = db.model(&#39;Account&#39;, AccountSchema);\n\nAccount.findById(id, function (err, found) {\n  console.log(found.creditCardNumber); // &#39;****-****-****-1234&#39;\n});\n</code></pre><p>Getters are also passed a second argument, the schematype on which the getter was defined. This allows for tailored behavior based on options passed in the schema.</p><pre><code>function inspector (val, schematype) {\n  if (schematype.options.required) {\n    return schematype.path + &#39; is required&#39;;\n  } else {\n    return schematype.path + &#39; is not&#39;;\n  }\n}\n\nvar VirusSchema = new Schema({\n  name: { type: String, required: true, get: inspector },\n  taxonomy: { type: String, get: inspector }\n})\n\nvar Virus = db.model(&#39;Virus&#39;, VirusSchema);\n\nVirus.findById(id, function (err, virus) {\n  console.log(virus.name);     // name is required\n  console.log(virus.taxonomy); // taxonomy is not\n})\n</code></pre>",
      "summary": "<p>Adds a getter to this schematype.</p>",
      "body": "<h4>Example:</h4>\n<pre><code>function dob (val) {\n  if (!val) return val;\n  return (val.getMonth() + 1) + &quot;/&quot; + val.getDate() + &quot;/&quot; + val.getFullYear();\n}\n\n// defining within the schema\nvar s = new Schema({ born: { type: Date, get: dob })\n\n// or by retreiving its SchemaType\nvar s = new Schema({ born: Date })\ns.path(&#39;born&#39;).get(dob)\n</code></pre><p>Getters allow you to transform the representation of the data as it travels from the raw mongodb document to the value that you see.</p><p>Suppose you are storing credit card numbers and you want to hide everything except the last 4 digits to the mongoose user. You can do so by defining a getter in the following way:</p><pre><code>function obfuscate (cc) {\n  return &#39;****-****-****-&#39; + cc.slice(cc.length-4, cc.length);\n}\n\nvar AccountSchema = new Schema({\n  creditCardNumber: { type: String, get: obfuscate }\n});\n\nvar Account = db.model(&#39;Account&#39;, AccountSchema);\n\nAccount.findById(id, function (err, found) {\n  console.log(found.creditCardNumber); // &#39;****-****-****-1234&#39;\n});\n</code></pre><p>Getters are also passed a second argument, the schematype on which the getter was defined. This allows for tailored behavior based on options passed in the schema.</p><pre><code>function inspector (val, schematype) {\n  if (schematype.options.required) {\n    return schematype.path + &#39; is required&#39;;\n  } else {\n    return schematype.path + &#39; is not&#39;;\n  }\n}\n\nvar VirusSchema = new Schema({\n  name: { type: String, required: true, get: inspector },\n  taxonomy: { type: String, get: inspector }\n})\n\nvar Virus = db.model(&#39;Virus&#39;, VirusSchema);\n\nVirus.findById(id, function (err, virus) {\n  console.log(virus.name);     // name is required\n  console.log(virus.taxonomy); // taxonomy is not\n})\n</code></pre>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 173,
    "codeStart": 234,
    "code": "SchemaType.prototype.get = function (fn) {\n  if ('function' != typeof fn)\n    throw new TypeError('A getter must be a function.');\n  this.getters.push(fn);\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "SchemaType",
      "cons": "SchemaType",
      "name": "get",
      "string": "SchemaType.prototype.get()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "RegExp",
          "Function",
          "Object"
        ],
        "name": "obj",
        "description": "validator",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "[message]",
        "description": "optional error message",
        "optional": true
      },
      {
        "type": "return",
        "types": [
          "SchemaType"
        ],
        "description": "this"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Adds validator(s) for this document path.</p><p>Validators always receive the value to validate as their first argument and must return <code>Boolean</code>. Returning <code>false</code> means validation failed.</p><p>The error message argument is optional. If not passed, the <a href=\"#error_messages_StorageError-messages\">default generic error message template</a> will be used.</p><h4>Examples:</h4>\n<pre><code>// make sure every value is equal to &quot;something&quot;\nfunction validator (val) {\n  return val == &#39;something&#39;;\n}\nnew Schema({ name: { type: String, validate: validator }});\n\n// with a custom error message\n\nvar custom = [validator, &#39;Uh oh, {PATH} does not equal &quot;something&quot;.&#39;]\nnew Schema({ name: { type: String, validate: custom }});\n\n// adding many validators at a time\n\nvar many = [\n    { validator: validator, msg: &#39;uh oh&#39; }\n  , { validator: anotherValidator, msg: &#39;failed&#39; }\n]\nnew Schema({ name: { type: String, validate: many }});\n\n// or utilizing SchemaType methods directly:\n\nvar schema = new Schema({ name: &#39;string&#39; });\nschema.path(&#39;name&#39;).validate(validator, &#39;validation of `{PATH}` failed with value `{VALUE}`&#39;);\n</code></pre><h4>Error message templates:</h4>\n<p>From the examples above, you may have noticed that error messages support baseic templating. There are a few other template keywords besides <code>{PATH}</code> and <code>{VALUE}</code> too. To find out more, details are available <a href=\"#error_messages_StorageError-messages\">here</a></p><h4>Asynchronous validation:</h4>\n<p>Passing a validator function that receives two arguments tells mongoose that the validator is an asynchronous validator. The first argument passed to the validator function is the value being validated. The second argument is a callback function that must called when you finish validating the value and passed either <code>true</code> or <code>false</code> to communicate either success or failure respectively.</p><pre><code>schema.path(&#39;name&#39;).validate(function (value, respond) {\n  doStuff(value, function () {\n    ...\n    respond(false); // validation failed\n  })\n }, &#39;{PATH} failed validation.&#39;);\n</code></pre><p>You might use asynchronous validators to retreive other documents from the database to validate against or to meet other I/O bound validation needs.</p><p>Validation occurs <code>pre(&#39;save&#39;)</code> or whenever you manually execute <a href=\"#document_Document-validate\">document#validate</a>.</p><p>If validation fails during <code>pre(&#39;save&#39;)</code> and no callback was passed to receive the error, an <code>error</code> event will be emitted on your Models associated db <a href=\"#connection_Connection\">connection</a>, passing the validation error object along.</p><pre><code>var conn = mongoose.createConnection(..);\nconn.on(&#39;error&#39;, handleError);\n\nvar Product = conn.model(&#39;Product&#39;, yourSchema);\nvar dvd = new Product(..);\ndvd.save(); // emits error on the `conn` above\n</code></pre><p>If you desire handling these errors at the Model level, attach an <code>error</code> listener to your Model and the event will instead be emitted there.</p><pre><code>// registering an error listener on the Model lets us handle errors more locally\nProduct.on(&#39;error&#39;, handleError);\n</code></pre>",
      "summary": "<p>Adds validator(s) for this document path.</p>",
      "body": "<p>Validators always receive the value to validate as their first argument and must return <code>Boolean</code>. Returning <code>false</code> means validation failed.</p><p>The error message argument is optional. If not passed, the <a href=\"#error_messages_StorageError-messages\">default generic error message template</a> will be used.</p><h4>Examples:</h4>\n<pre><code>// make sure every value is equal to &quot;something&quot;\nfunction validator (val) {\n  return val == &#39;something&#39;;\n}\nnew Schema({ name: { type: String, validate: validator }});\n\n// with a custom error message\n\nvar custom = [validator, &#39;Uh oh, {PATH} does not equal &quot;something&quot;.&#39;]\nnew Schema({ name: { type: String, validate: custom }});\n\n// adding many validators at a time\n\nvar many = [\n    { validator: validator, msg: &#39;uh oh&#39; }\n  , { validator: anotherValidator, msg: &#39;failed&#39; }\n]\nnew Schema({ name: { type: String, validate: many }});\n\n// or utilizing SchemaType methods directly:\n\nvar schema = new Schema({ name: &#39;string&#39; });\nschema.path(&#39;name&#39;).validate(validator, &#39;validation of `{PATH}` failed with value `{VALUE}`&#39;);\n</code></pre><h4>Error message templates:</h4>\n<p>From the examples above, you may have noticed that error messages support baseic templating. There are a few other template keywords besides <code>{PATH}</code> and <code>{VALUE}</code> too. To find out more, details are available <a href=\"#error_messages_StorageError-messages\">here</a></p><h4>Asynchronous validation:</h4>\n<p>Passing a validator function that receives two arguments tells mongoose that the validator is an asynchronous validator. The first argument passed to the validator function is the value being validated. The second argument is a callback function that must called when you finish validating the value and passed either <code>true</code> or <code>false</code> to communicate either success or failure respectively.</p><pre><code>schema.path(&#39;name&#39;).validate(function (value, respond) {\n  doStuff(value, function () {\n    ...\n    respond(false); // validation failed\n  })\n }, &#39;{PATH} failed validation.&#39;);\n</code></pre><p>You might use asynchronous validators to retreive other documents from the database to validate against or to meet other I/O bound validation needs.</p><p>Validation occurs <code>pre(&#39;save&#39;)</code> or whenever you manually execute <a href=\"#document_Document-validate\">document#validate</a>.</p><p>If validation fails during <code>pre(&#39;save&#39;)</code> and no callback was passed to receive the error, an <code>error</code> event will be emitted on your Models associated db <a href=\"#connection_Connection\">connection</a>, passing the validation error object along.</p><pre><code>var conn = mongoose.createConnection(..);\nconn.on(&#39;error&#39;, handleError);\n\nvar Product = conn.model(&#39;Product&#39;, yourSchema);\nvar dvd = new Product(..);\ndvd.save(); // emits error on the `conn` above\n</code></pre><p>If you desire handling these errors at the Model level, attach an <code>error</code> listener to your Model and the event will instead be emitted there.</p><pre><code>// registering an error listener on the Model lets us handle errors more locally\nProduct.on(&#39;error&#39;, handleError);\n</code></pre>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 241,
    "codeStart": 312,
    "code": "SchemaType.prototype.validate = function (obj, message, type) {\n  if ('function' == typeof obj || obj && 'RegExp' === utils.getFunctionName( obj.constructor )) {\n    if (!message) message = errorMessages.general.default;\n    if (!type) type = 'user defined';\n    this.validators.push([obj, message, type]);\n    return this;\n  }\n\n  var i = arguments.length\n    , arg;\n\n  while (i--) {\n    arg = arguments[i];\n    if (!(arg && 'Object' == utils.getFunctionName( arg.constructor ) )) {\n      var msg = 'Invalid validator. Received (' + typeof arg + ') '\n        + arg\n        + '. See http://mongoosejs.com/docs/api.html#schematype_SchemaType-validate';\n\n      throw new Error(msg);\n    }\n    this.validate(arg.validator, arg.msg, arg.type);\n  }\n\n  return this;\n};\n\n/**\n * Adds a required validator to this schematype.\n *\n * ####Example:\n *\n *     var s = new Schema({ born: { type: Date, required: true })\n *\n *     // or with custom error message\n *\n *     var s = new Schema({ born: { type: Date, required: '{PATH} is required!' })\n *\n *     // or through the path API\n *\n *     Schema.path('name').required(true);\n *\n *     // with custom error messaging\n *\n *     Schema.path('name').required(true, 'grrr :( ');\n *\n *\n * @param {Boolean} required enable/disable the validator\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages #error_messages_StorageError-messages\n * @api public\n */\nSchemaType.prototype.required = function (required, message) {\n  if (false === required) {\n    this.validators = this.validators.filter(function (v) {\n      return v[0] != this.requiredValidator;\n    }, this);\n\n    this.isRequired = false;\n    return this;\n  }\n\n  var self = this;\n  this.isRequired = true;\n\n  this.requiredValidator = function (v) {\n    // in here, `this` refers to the validating document.\n    // no validation when this path wasn't selected in the query.\n    if (this !== undefined && // специальная проверка из-за strict mode и особенности .call(undefined)\n        'isSelected' in this &&\n        !this.isSelected(self.path) &&\n        !this.isModified(self.path)) return true;\n\n    return self.checkRequired(v, this);\n  };\n\n  if ('string' == typeof required) {\n    message = required;\n    required = undefined;\n  }\n\n  var msg = message || errorMessages.general.required;\n  this.validators.push([this.requiredValidator, msg, 'required']);\n\n  return this;\n};\n\n\n/**\n * Gets the default value\n *\n * @param {Object} scope the scope which callback are executed\n * @param {Boolean} init\n * @api private\n */\nSchemaType.prototype.getDefault = function (scope, init) {\n  var ret = 'function' === typeof this.defaultValue\n    ? this.defaultValue.call(scope)\n    : this.defaultValue;\n\n  if (null !== ret && undefined !== ret) {\n    return this.cast(ret, scope, init);\n  } else {\n    return ret;\n  }\n};\n\n/**\n * Applies setters\n *\n * @param {Object} value\n * @param {Object} scope\n * @param {Boolean} init\n * @api private\n */\n\nSchemaType.prototype.applySetters = function (value, scope, init, priorVal) {\n  if (SchemaType._isRef( this, value )) {\n    return init\n      ? value\n      : this.cast(value, scope, init, priorVal);\n  }\n\n  var v = value\n    , setters = this.setters\n    , len = setters.length\n    , caster = this.caster;\n\n  if (Array.isArray(v) && caster && caster.setters) {\n    for (var i = 0; i < v.length; i++) {\n      v[i] = caster.applySetters(v[i], scope, init, priorVal);\n    }\n  }\n\n  if (!len) {\n    if (null === v || undefined === v) return v;\n    return this.cast(v, scope, init, priorVal);\n  }\n\n  while (len--) {\n    v = setters[len].call(scope, v, this);\n  }\n\n  if (null === v || undefined === v) return v;\n\n  // do not cast until all setters are applied #665\n  v = this.cast(v, scope, init, priorVal);\n\n  return v;\n};\n\n/**\n * Applies getters to a value\n *\n * @param {Object} value\n * @param {Object} scope\n * @api private\n */\nSchemaType.prototype.applyGetters = function( value, scope ){\n  if ( SchemaType._isRef( this, value ) ) return value;\n\n  var v = value\n    , getters = this.getters\n    , len = getters.length;\n\n  if ( !len ) {\n    return v;\n  }\n\n  while ( len-- ) {\n    v = getters[ len ].call(scope, v, this);\n  }\n\n  return v;\n};\n\n/**\n * Performs a validation of `value` using the validators declared for this SchemaType.\n *\n * @param {*} value\n * @param {Function} callback\n * @param {Object} scope\n * @api private\n */\nSchemaType.prototype.doValidate = function (value, callback, scope) {\n  var err = false\n    , path = this.path\n    , count = this.validators.length;\n\n  if (!count) return callback(null);\n\n  function validate (ok, message, type, val) {\n    if (err) return;\n    if (ok === undefined || ok) {\n      --count || callback(null);\n    } else {\n      callback(err = new ValidatorError(path, message, type, val));\n    }\n  }\n\n  this.validators.forEach(function (v) {\n    var validator = v[0]\n      , message = v[1]\n      , type = v[2];\n\n    if (validator instanceof RegExp) {\n      validate(validator.test(value), message, type, value);\n    } else if ('function' === typeof validator) {\n      if (2 === validator.length) {\n        validator.call(scope, value, function (ok) {\n          validate(ok, message, type, value);\n        });\n      } else {\n        validate(validator.call(scope, value), message, type, value);\n      }\n    }\n  });\n};\n\n/**\n * Determines if value is a valid Reference.\n *\n * На клиенте в качестве ссылки можно хранить как id, так и полные документы\n *\n * @param {SchemaType} self\n * @param {Object} value\n * @return {Boolean}\n * @api private\n */\nSchemaType._isRef = function( self, value ){\n  // fast path\n  var ref = self.options && self.options.ref;\n\n  if ( ref ) {\n    if ( null == value ) return true;\n    if ( _.isObject( value ) ) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaType;\n\nSchemaType.CastError = CastError;\n\nSchemaType.ValidatorError = ValidatorError;",
    "ctx": {
      "type": "method",
      "constructor": "SchemaType",
      "cons": "SchemaType",
      "name": "validate",
      "string": "SchemaType.prototype.validate()"
    }
  }
]
### lib/statemachine.js
[
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>StateMachine represents a minimal <code>interface</code> for the<br />constructors it builds via StateMachine.ctor(...).</p>",
      "summary": "<p>StateMachine represents a minimal <code>interface</code> for the<br />constructors it builds via StateMachine.ctor(...).</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": true,
    "line": 1,
    "codeStart": 8,
    "code": "var StateMachine = module.exports = function StateMachine () {\n  this.paths = {};\n  this.states = {};\n};",
    "ctx": {
      "type": "declaration",
      "name": "StateMachine",
      "value": "module.exports = function StateMachine () {",
      "string": "StateMachine"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "state",
        "description": "",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "[state]",
        "description": "",
        "optional": true
      },
      {
        "type": "return",
        "types": [
          "Function"
        ],
        "description": "subclass constructor"
      },
      {
        "type": "private",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>StateMachine.ctor(&#39;state1&#39;, &#39;state2&#39;, ...)<br />A factory method for subclassing StateMachine.<br />The arguments are a list of states. For each state,<br />the constructor&#39;s prototype gets state transition<br />methods named after each state. These transition methods<br />place their path argument into the given state.</p>",
      "summary": "<p>StateMachine.ctor(&#39;state1&#39;, &#39;state2&#39;, ...)<br />A factory method for subclassing StateMachine.<br />The arguments are a list of states. For each state,<br />the constructor&#39;s prototype gets state transition<br />methods named after each state. These transition methods<br />place their path argument into the given state.</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": true,
    "line": 13,
    "codeStart": 27,
    "code": "StateMachine.ctor = function () {\n  var states = _.toArray(arguments);\n\n  var ctor = function () {\n    StateMachine.apply(this, arguments);\n    this.stateNames = states;\n\n    var i = states.length\n      , state;\n\n    while (i--) {\n      state = states[i];\n      this.states[state] = {};\n    }\n  };\n\n  ctor.prototype = Object.create( StateMachine.prototype );\n  ctor.prototype.constructor = ctor;\n\n  states.forEach(function (state) {\n    // Changes the `path`'s state to `state`.\n    ctor.prototype[state] = function (path) {\n      this._changeState(path, state);\n    }\n  });\n\n  return ctor;\n};",
    "ctx": {
      "type": "method",
      "receiver": "StateMachine",
      "name": "ctor",
      "string": "StateMachine.ctor()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>This function is wrapped by the state change functions:</p><ul>\n<li><code>require(path)</code></li>\n<li><code>modify(path)</code></li>\n<li><code>init(path)</code></li>\n</ul>\n",
      "summary": "<p>This function is wrapped by the state change functions:</p>",
      "body": "<ul>\n<li><code>require(path)</code></li>\n<li><code>modify(path)</code></li>\n<li><code>init(path)</code></li>\n</ul>\n"
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": true,
    "line": 56,
    "codeStart": 66,
    "code": "StateMachine.prototype._changeState = function _changeState (path, nextState) {\n  var prevBucket = this.states[this.paths[path]];\n  if (prevBucket) delete prevBucket[path];\n\n  this.paths[path] = nextState;\n  this.states[nextState][path] = true;\n};",
    "ctx": {
      "type": "method",
      "constructor": "StateMachine",
      "cons": "StateMachine",
      "name": "_changeState",
      "string": "StateMachine.prototype._changeState()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>ignore</p>",
      "summary": "<p>ignore</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 74,
    "codeStart": 78,
    "code": "StateMachine.prototype.clear = function clear (state) {\n  var keys = Object.keys(this.states[state])\n    , i = keys.length\n    , path;\n\n  while (i--) {\n    path = keys[i];\n    delete this.states[state][path];\n    delete this.paths[path];\n  }\n};",
    "ctx": {
      "type": "method",
      "constructor": "StateMachine",
      "cons": "StateMachine",
      "name": "clear",
      "string": "StateMachine.prototype.clear()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "state",
        "description": "that we want to check for.",
        "optional": false
      },
      {
        "type": "private",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Checks to see if at least one path is in the states passed in via <code>arguments</code><br />e.g., this.some(&#39;required&#39;, &#39;inited&#39;)</p>",
      "summary": "<p>Checks to see if at least one path is in the states passed in via <code>arguments</code><br />e.g., this.some(&#39;required&#39;, &#39;inited&#39;)</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": true,
    "line": 90,
    "codeStart": 98,
    "code": "StateMachine.prototype.some = function some () {\n  var self = this;\n  var what = arguments.length ? arguments : this.stateNames;\n  return Array.prototype.some.call(what, function (state) {\n    return Object.keys(self.states[state]).length;\n  });\n};",
    "ctx": {
      "type": "method",
      "constructor": "StateMachine",
      "cons": "StateMachine",
      "name": "some",
      "string": "StateMachine.prototype.some()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "iterMethod",
        "description": "is either 'forEach' or 'map'",
        "optional": false
      },
      {
        "type": "return",
        "types": [
          "Function"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>This function builds the functions that get assigned to <code>forEach</code> and <code>map</code>,<br />since both of those methods share a lot of the same logic.</p>",
      "summary": "<p>This function builds the functions that get assigned to <code>forEach</code> and <code>map</code>,<br />since both of those methods share a lot of the same logic.</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": true,
    "line": 106,
    "codeStart": 115,
    "code": "StateMachine.prototype._iter = function _iter (iterMethod) {\n  return function () {\n    var numArgs = arguments.length\n      , states = _.toArray(arguments).slice(0, numArgs-1)\n      , callback = arguments[numArgs-1];\n\n    if (!states.length) states = this.stateNames;\n\n    var self = this;\n\n    var paths = states.reduce(function (paths, state) {\n      return paths.concat(Object.keys(self.states[state]));\n    }, []);\n\n    return paths[iterMethod](function (path, i, paths) {\n      return callback(path, i, paths);\n    });\n  };\n};",
    "ctx": {
      "type": "method",
      "constructor": "StateMachine",
      "cons": "StateMachine",
      "name": "_iter",
      "string": "StateMachine.prototype._iter()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "[state]",
        "description": "",
        "optional": true
      },
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "[state]",
        "description": "",
        "optional": true
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "callback",
        "description": "",
        "optional": false
      },
      {
        "type": "private",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Iterates over the paths that belong to one of the parameter states.</p><p>The function profile can look like:<br />this.forEach(state1, fn);         // iterates over all paths in state1<br />this.forEach(state1, state2, fn); // iterates over all paths in state1 or state2<br />this.forEach(fn);                 // iterates over all paths in all states</p>",
      "summary": "<p>Iterates over the paths that belong to one of the parameter states.</p>",
      "body": "<p>The function profile can look like:<br />this.forEach(state1, fn);         // iterates over all paths in state1<br />this.forEach(state1, state2, fn); // iterates over all paths in state1 or state2<br />this.forEach(fn);                 // iterates over all paths in all states</p>"
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": true,
    "line": 135,
    "codeStart": 149,
    "code": "StateMachine.prototype.forEach = function forEach () {\n  this.forEach = this._iter('forEach');\n  return this.forEach.apply(this, arguments);\n};",
    "ctx": {
      "type": "method",
      "constructor": "StateMachine",
      "cons": "StateMachine",
      "name": "forEach",
      "string": "StateMachine.prototype.forEach()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "[state]",
        "description": "",
        "optional": true
      },
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "[state]",
        "description": "",
        "optional": true
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "callback",
        "description": "",
        "optional": false
      },
      {
        "type": "return",
        "types": [
          "Array"
        ],
        "description": ""
      },
      {
        "type": "private",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Maps over the paths that belong to one of the parameter states.</p><p>The function profile can look like:<br />this.forEach(state1, fn);         // iterates over all paths in state1<br />this.forEach(state1, state2, fn); // iterates over all paths in state1 or state2<br />this.forEach(fn);                 // iterates over all paths in all states</p>",
      "summary": "<p>Maps over the paths that belong to one of the parameter states.</p>",
      "body": "<p>The function profile can look like:<br />this.forEach(state1, fn);         // iterates over all paths in state1<br />this.forEach(state1, state2, fn); // iterates over all paths in state1 or state2<br />this.forEach(fn);                 // iterates over all paths in all states</p>"
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": true,
    "line": 154,
    "codeStart": 169,
    "code": "StateMachine.prototype.map = function map () {\n  this.map = this._iter('map');\n  return this.map.apply(this, arguments);\n};",
    "ctx": {
      "type": "method",
      "constructor": "StateMachine",
      "cons": "StateMachine",
      "name": "map",
      "string": "StateMachine.prototype.map()"
    }
  }
]
### lib/types/array.js
[
  {
    "tags": [],
    "description": {
      "full": "<p>Module dependencies.</p>",
      "summary": "<p>Module dependencies.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 3,
    "codeStart": 7,
    "code": "var EmbeddedDocument = require('./embedded');\nvar Document = require('../document');\nvar ObjectId = require('./objectid');\nvar utils = require('../utils');",
    "ctx": {
      "type": "declaration",
      "name": "EmbeddedDocument",
      "value": "require('./embedded')",
      "string": "EmbeddedDocument"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Array"
        ],
        "name": "values",
        "description": "",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "path",
        "description": "",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "Document"
        ],
        "name": "doc",
        "description": "parent document",
        "optional": false
      },
      {
        "type": "api",
        "visibility": "private"
      },
      {
        "type": "inherits",
        "string": "Array"
      }
    ],
    "description": {
      "full": "<p>Storage Array constructor.</p><h4>NOTE:</h4>\n<p><em>Values always have to be passed to the constructor to initialize, otherwise <code>StorageArray#push</code> will mark the array as modified.</em></p>",
      "summary": "<p>Storage Array constructor.</p>",
      "body": "<h4>NOTE:</h4>\n<p><em>Values always have to be passed to the constructor to initialize, otherwise <code>StorageArray#push</code> will mark the array as modified.</em></p>"
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": false,
    "line": 12,
    "codeStart": 25,
    "code": "function StorageArray (values, path, doc) {\n  var arr = [];\n  arr.push.apply(arr, values);\n  _.mixin( arr, StorageArray.mixin );\n\n  arr.validators = [];\n  arr._path = path;\n  arr.isStorageArray = true;\n\n  if (doc) {\n    arr._parent = doc;\n    arr._schema = doc.schema.path(path);\n  }\n\n  return arr;\n}\n\nStorageArray.mixin = {",
    "ctx": {
      "type": "function",
      "name": "StorageArray",
      "string": "StorageArray()"
    }
  },
  {
    "tags": [
      {
        "type": "property",
        "types": [
          "_parent"
        ],
        "name": "",
        "description": "",
        "optional": false
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Parent owner document</p>",
      "summary": "<p>Parent owner document</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": false,
    "line": 43,
    "codeStart": 49,
    "code": "_parent: undefined,",
    "ctx": {
      "type": "property",
      "name": "_parent",
      "value": "undefined,",
      "string": "_parent"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "*"
        ],
        "name": "value",
        "description": "",
        "optional": false
      },
      {
        "type": "return",
        "types": [
          "value"
        ],
        "description": "the casted value"
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Casts a member based on this arrays schema.</p>",
      "summary": "<p>Casts a member based on this arrays schema.</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": false,
    "line": 51,
    "codeStart": 58,
    "code": "_cast: function ( value ) {\n  var owner = this._owner;\n  var populated = false;\n\n  if (this._parent) {\n    // if a populated array, we must cast to the same model\n    // instance as specified in the original query.\n    if (!owner) {\n      owner = this._owner = this._parent.ownerDocument\n        ? this._parent.ownerDocument()\n        : this._parent;\n    }\n\n    populated = owner.populated(this._path, true);\n  }\n\n  if (populated && null != value) {\n    // cast to the populated Models schema\n    var Model = populated.options.model;\n\n    // only objects are permitted so we can safely assume that\n    // non-objects are to be interpreted as _id\n    if ( value instanceof ObjectId || !_.isObject(value) ) {\n      value = { _id: value };\n    }\n\n    value = new Model(value);\n    return this._schema.caster.cast(value, this._parent, true)\n  }\n\n  return this._schema.caster.cast(value, this._parent, false)\n},",
    "ctx": {
      "type": "method",
      "name": "_cast",
      "string": "_cast()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "EmbeddedDocument"
        ],
        "name": "embeddedDoc",
        "description": "the embedded doc that invoked this method on the Array",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "embeddedPath",
        "description": "the path which changed in the embeddedDoc",
        "optional": false
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Marks this array as modified.</p><p>If it bubbles up from an embedded document change, then it takes the following arguments (otherwise, takes 0 arguments)</p>",
      "summary": "<p>Marks this array as modified.</p>",
      "body": "<p>If it bubbles up from an embedded document change, then it takes the following arguments (otherwise, takes 0 arguments)</p>"
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": false,
    "line": 91,
    "codeStart": 100,
    "code": "_markModified: function (elem, embeddedPath) {\n  var parent = this._parent\n    , dirtyPath;\n\n  if (parent) {\n    dirtyPath = this._path;\n\n    if (arguments.length) {\n      if (null != embeddedPath) {\n        // an embedded doc bubbled up the change\n        dirtyPath = dirtyPath + '.' + this.indexOf(elem) + '.' + embeddedPath;\n      } else {\n        // directly set an index\n        dirtyPath = dirtyPath + '.' + elem;\n      }\n    }\n\n    parent.markModified(dirtyPath);\n  }\n\n  return this;\n},",
    "ctx": {
      "type": "method",
      "name": "_markModified",
      "string": "_markModified()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "[args...]",
        "description": "",
        "optional": true
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Wraps <a href=\"https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/push\"><code>Array#push</code></a> with proper change tracking.</p>",
      "summary": "<p>Wraps <a href=\"https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/push\"><code>Array#push</code></a> with proper change tracking.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 123,
    "codeStart": 129,
    "code": "push: function () {\n  var values = [].map.call(arguments, this._cast, this)\n    , ret = [].push.apply(this, values);\n\n  this._markModified();\n  return ret;\n},",
    "ctx": {
      "type": "method",
      "name": "push",
      "string": "push()"
    }
  },
  {
    "tags": [
      {
        "type": "see",
        "local": "StorageArray#$pop #types_array_StorageArray-%24pop"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Wraps <a href=\"https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/pop\"><code>Array#pop</code></a> with proper change tracking.</p><h4>Note:</h4>\n<p><em>marks the entire array as modified which will pass the entire thing to $set potentially overwritting any changes that happen between when you retrieved the object and when you save it.</em></p>",
      "summary": "<p>Wraps <a href=\"https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/pop\"><code>Array#pop</code></a> with proper change tracking.</p>",
      "body": "<h4>Note:</h4>\n<p><em>marks the entire array as modified which will pass the entire thing to $set potentially overwritting any changes that happen between when you retrieved the object and when you save it.</em></p>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 137,
    "codeStart": 147,
    "code": "pop: function () {\n  var ret = [].pop.call(this);\n\n  this._markModified();\n  return ret;\n},",
    "ctx": {
      "type": "method",
      "name": "pop",
      "string": "pop()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Wraps <a href=\"https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/unshift\"><code>Array#shift</code></a> with proper change tracking.</p><h4>Example:</h4>\n<pre><code>doc.array = [2,3];\nvar res = doc.array.shift();\nconsole.log(res) // 2\nconsole.log(doc.array) // [3]\n</code></pre><h4>Note:</h4>\n<p><em>marks the entire array as modified, which if saved, will store it as a <code>$set</code> operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it.</em></p>",
      "summary": "<p>Wraps <a href=\"https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/unshift\"><code>Array#shift</code></a> with proper change tracking.</p>",
      "body": "<h4>Example:</h4>\n<pre><code>doc.array = [2,3];\nvar res = doc.array.shift();\nconsole.log(res) // 2\nconsole.log(doc.array) // [3]\n</code></pre><h4>Note:</h4>\n<p><em>marks the entire array as modified, which if saved, will store it as a <code>$set</code> operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it.</em></p>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 154,
    "codeStart": 170,
    "code": "shift: function () {\n  var ret = [].shift.call(this);\n\n  this._markModified();\n  return ret;\n},",
    "ctx": {
      "type": "method",
      "name": "shift",
      "string": "shift()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "*"
        ],
        "name": "arguments",
        "description": "",
        "optional": false
      },
      {
        "type": "see",
        "title": "mongodb",
        "url": "http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pull"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Pulls items from the array atomically.</p><h4>Examples:</h4>\n<pre><code>doc.array.pull(ObjectId)\ndoc.array.pull({ _id: &#39;someId&#39; })\ndoc.array.pull(36)\ndoc.array.pull(&#39;tag 1&#39;, &#39;tag 2&#39;)\n</code></pre><p>To remove a document from a subdocument array we may pass an object with a matching <code>_id</code>.</p><pre><code>doc.subdocs.push({ _id: 4815162342 })\ndoc.subdocs.pull({ _id: 4815162342 }) // removed\n</code></pre><p>Or we may passing the _id directly and let storage take care of it.</p><pre><code>doc.subdocs.push({ _id: 4815162342 })\ndoc.subdocs.pull(4815162342); // works\n</code></pre>",
      "summary": "<p>Pulls items from the array atomically.</p>",
      "body": "<h4>Examples:</h4>\n<pre><code>doc.array.pull(ObjectId)\ndoc.array.pull({ _id: &#39;someId&#39; })\ndoc.array.pull(36)\ndoc.array.pull(&#39;tag 1&#39;, &#39;tag 2&#39;)\n</code></pre><p>To remove a document from a subdocument array we may pass an object with a matching <code>_id</code>.</p><pre><code>doc.subdocs.push({ _id: 4815162342 })\ndoc.subdocs.pull({ _id: 4815162342 }) // removed\n</code></pre><p>Or we may passing the _id directly and let storage take care of it.</p><pre><code>doc.subdocs.push({ _id: 4815162342 })\ndoc.subdocs.pull(4815162342); // works\n</code></pre>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 177,
    "codeStart": 201,
    "code": "pull: function () {\n  var values = [].map.call(arguments, this._cast, this)\n    , cur = this._parent.get(this._path)\n    , i = cur.length\n    , mem;\n\n  while (i--) {\n    mem = cur[i];\n    if (mem instanceof EmbeddedDocument) {\n      if (values.some(function (v) { return v.equals(mem); } )) {\n        [].splice.call(cur, i, 1);\n      }\n    } else if (~cur.indexOf.call(values, mem)) {\n      [].splice.call(cur, i, 1);\n    }\n  }\n\n  this._markModified();\n  return this;\n},",
    "ctx": {
      "type": "method",
      "name": "pull",
      "string": "pull()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Wraps <a href=\"https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/splice\"><code>Array#splice</code></a> with proper change tracking and casting.</p><h4>Note:</h4>\n<p><em>marks the entire array as modified, which if saved, will store it as a <code>$set</code> operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it.</em></p>",
      "summary": "<p>Wraps <a href=\"https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/splice\"><code>Array#splice</code></a> with proper change tracking and casting.</p>",
      "body": "<h4>Note:</h4>\n<p><em>marks the entire array as modified, which if saved, will store it as a <code>$set</code> operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it.</em></p>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 222,
    "codeStart": 231,
    "code": "splice: function splice () {\n  var ret, vals, i;\n\n  if (arguments.length) {\n    vals = [];\n    for (i = 0; i < arguments.length; ++i) {\n      vals[i] = i < 2\n        ? arguments[i]\n        : this._cast(arguments[i]);\n    }\n    ret = [].splice.apply(this, vals);\n\n    this._markModified();\n  }\n\n  return ret;\n},",
    "ctx": {
      "type": "method",
      "name": "splice",
      "string": "splice()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Wraps <a href=\"https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/unshift\"><code>Array#unshift</code></a> with proper change tracking.</p><h4>Note:</h4>\n<p><em>marks the entire array as modified, which if saved, will store it as a <code>$set</code> operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it.</em></p>",
      "summary": "<p>Wraps <a href=\"https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/unshift\"><code>Array#unshift</code></a> with proper change tracking.</p>",
      "body": "<h4>Note:</h4>\n<p><em>marks the entire array as modified, which if saved, will store it as a <code>$set</code> operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it.</em></p>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 249,
    "codeStart": 258,
    "code": "unshift: function () {\n  var values = [].map.call(arguments, this._cast, this);\n  [].unshift.apply(this, values);\n\n  this._markModified();\n  return this.length;\n},",
    "ctx": {
      "type": "method",
      "name": "unshift",
      "string": "unshift()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Wraps <a href=\"https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/sort\"><code>Array#sort</code></a> with proper change tracking.</p><h4>NOTE:</h4>\n<p><em>marks the entire array as modified, which if saved, will store it as a <code>$set</code> operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it.</em></p>",
      "summary": "<p>Wraps <a href=\"https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/sort\"><code>Array#sort</code></a> with proper change tracking.</p>",
      "body": "<h4>NOTE:</h4>\n<p><em>marks the entire array as modified, which if saved, will store it as a <code>$set</code> operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it.</em></p>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 266,
    "codeStart": 275,
    "code": "sort: function () {\n  var ret = [].sort.apply(this, arguments);\n\n  this._markModified();\n  return ret;\n},",
    "ctx": {
      "type": "method",
      "name": "sort",
      "string": "sort()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "*"
        ],
        "name": "arguments",
        "description": "",
        "optional": false
      },
      {
        "type": "return",
        "types": [
          "Array"
        ],
        "description": "the values that were added"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Adds values to the array if not already present.</p><h4>Example:</h4>\n<pre><code>console.log(doc.array) // [2,3,4]\nvar added = doc.array.addToSet(4,5);\nconsole.log(doc.array) // [2,3,4,5]\nconsole.log(added)     // [5]\n</code></pre>",
      "summary": "<p>Adds values to the array if not already present.</p>",
      "body": "<h4>Example:</h4>\n<pre><code>console.log(doc.array) // [2,3,4]\nvar added = doc.array.addToSet(4,5);\nconsole.log(doc.array) // [2,3,4,5]\nconsole.log(added)     // [5]\n</code></pre>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 282,
    "codeStart": 296,
    "code": "addToSet: function addToSet () {\n  var values = [].map.call(arguments, this._cast, this)\n    , added = []\n    , type = values[0] instanceof EmbeddedDocument ? 'doc' :\n             values[0] instanceof Date ? 'date' :\n             '';\n\n  values.forEach(function (v) {\n    var found;\n    switch (type) {\n      case 'doc':\n        found = this.some(function(doc){ return doc.equals(v) });\n        break;\n      case 'date':\n        var val = +v;\n        found = this.some(function(d){ return +d === val });\n        break;\n      default:\n        found = ~this.indexOf(v);\n    }\n\n    if (!found) {\n      [].push.call(this, v);\n\n      this._markModified();\n      [].push.call(added, v);\n    }\n  }, this);\n\n  return added;\n},",
    "ctx": {
      "type": "method",
      "name": "addToSet",
      "string": "addToSet()"
    }
  },
  {
    "tags": [
      {
        "type": "return",
        "types": [
          "Array"
        ],
        "description": "this"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Sets the casted <code>val</code> at index <code>i</code> and marks the array modified.</p><h4>Example:</h4>\n<pre><code>// given documents based on the following\nvar docs = storage.createCollection(&#39;Doc&#39;, new Schema({ array: [Number] }));\n\nvar doc = docs.add({ array: [2,3,4] })\n\nconsole.log(doc.array) // [2,3,4]\n\ndoc.array.set(1,&quot;5&quot;);\nconsole.log(doc.array); // [2,5,4] // properly cast to number\ndoc.save() // the change is saved\n\n// VS not using array#set\ndoc.array[1] = &quot;5&quot;;\nconsole.log(doc.array); // [2,&quot;5&quot;,4] // no casting\ndoc.save() // change is not saved\n</code></pre>",
      "summary": "<p>Sets the casted <code>val</code> at index <code>i</code> and marks the array modified.</p>",
      "body": "<h4>Example:</h4>\n<pre><code>// given documents based on the following\nvar docs = storage.createCollection(&#39;Doc&#39;, new Schema({ array: [Number] }));\n\nvar doc = docs.add({ array: [2,3,4] })\n\nconsole.log(doc.array) // [2,3,4]\n\ndoc.array.set(1,&quot;5&quot;);\nconsole.log(doc.array); // [2,5,4] // properly cast to number\ndoc.save() // the change is saved\n\n// VS not using array#set\ndoc.array[1] = &quot;5&quot;;\nconsole.log(doc.array); // [2,&quot;5&quot;,4] // no casting\ndoc.save() // change is not saved\n</code></pre>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 328,
    "codeStart": 352,
    "code": "set: function (i, val) {\n  this[i] = this._cast(val);\n  this._markModified(i);\n  return this;\n},",
    "ctx": {
      "type": "method",
      "name": "set",
      "string": "set()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "options",
        "description": "",
        "optional": false
      },
      {
        "type": "return",
        "types": [
          "Array"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Returns a native js Array.</p>",
      "summary": "<p>Returns a native js Array.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 358,
    "codeStart": 365,
    "code": "toObject: function (options) {\n  if (options && options.depopulate) {\n    return this.map(function (doc) {\n      return doc instanceof Document\n        ? doc.toObject(options)\n        : doc\n    });\n  }\n\n  return this.slice();\n},",
    "ctx": {
      "type": "method",
      "name": "toObject",
      "string": "toObject()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "obj",
        "description": "the item to look for",
        "optional": false
      },
      {
        "type": "return",
        "types": [
          "Number"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Return the index of <code>obj</code> or <code>-1</code> if not found.</p>",
      "summary": "<p>Return the index of <code>obj</code> or <code>-1</code> if not found.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 377,
    "codeStart": 384,
    "code": "indexOf: function indexOf (obj) {\n  if (obj instanceof ObjectId) obj = obj.toString();\n  for (var i = 0, len = this.length; i < len; ++i) {\n    if (obj == this[i])\n      return i;\n  }\n  return -1;\n}\n};",
    "ctx": {
      "type": "method",
      "name": "indexOf",
      "string": "indexOf()"
    }
  },
  {
    "tags": [
      {
        "type": "see",
        "local": "StorageArray#pull #types_array_StorageArray-pull"
      },
      {
        "type": "see",
        "title": "mongodb",
        "url": "http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pull"
      },
      {
        "type": "api",
        "visibility": "public"
      },
      {
        "type": "memberOf",
        "parent": "StorageArray"
      },
      {
        "type": "method",
        "string": "remove"
      }
    ],
    "description": {
      "full": "<p>Alias of <a href=\"#types_array_StorageArray-pull\">pull</a></p>",
      "summary": "<p>Alias of <a href=\"#types_array_StorageArray-pull\">pull</a></p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 394,
    "codeStart": 403,
    "code": "StorageArray.mixin.remove = StorageArray.mixin.pull;"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Module exports.</p>",
      "summary": "<p>Module exports.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 405,
    "codeStart": 409,
    "code": "module.exports = StorageArray;",
    "ctx": {
      "type": "property",
      "receiver": "module",
      "name": "exports",
      "value": "StorageArray",
      "string": "module.exports"
    }
  }
]
### lib/types/buffer.js
[
  {
    "tags": [],
    "description": {
      "full": "<p>Module dependencies.</p>",
      "summary": "<p>Module dependencies.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 1,
    "codeStart": 5,
    "code": "var Binary = require('../binary');\nvar utils = require('../utils');",
    "ctx": {
      "type": "declaration",
      "name": "Binary",
      "value": "require('../binary')",
      "string": "Binary"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Buffer"
        ],
        "name": "value",
        "description": "",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "encode",
        "description": "",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "Number"
        ],
        "name": "offset",
        "description": "",
        "optional": false
      },
      {
        "type": "api",
        "visibility": "private"
      },
      {
        "type": "inherits",
        "string": "Buffer"
      }
    ],
    "description": {
      "full": "<p>Storage Buffer constructor.</p><p>Values always have to be passed to the constructor to initialize.</p>",
      "summary": "<p>Storage Buffer constructor.</p>",
      "body": "<p>Values always have to be passed to the constructor to initialize.</p>"
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": false,
    "line": 8,
    "codeStart": 20,
    "code": "function StorageBuffer (value, encode, offset) {\n  var length = arguments.length;\n  var val;\n\n  if (0 === length || null === arguments[0] || undefined === arguments[0]) {\n    val = 0;\n  } else {\n    val = value;\n  }\n\n  var encoding;\n  var path;\n  var doc;\n\n  if (Array.isArray(encode)) {\n    // internal casting\n    path = encode[0];\n    doc = encode[1];\n  } else {\n    encoding = encode;\n  }\n\n  var buf = new Buffer(val, encoding, offset);\n  _.mixin( buf, StorageBuffer.mixin );\n  buf.isStorageBuffer = true;\n\n  // make sure these internal props don't show up in Object.keys()\n  Object.defineProperties(buf, {\n      validators: { value: [] }\n    , _path: { value: path }\n    , _parent: { value: doc }\n  });\n\n  if (doc && \"string\" === typeof path) {\n    Object.defineProperty(buf, '_schema', {\n        value: doc.schema.path(path)\n    });\n  }\n\n  buf._subtype = 0;\n  return buf;\n}",
    "ctx": {
      "type": "function",
      "name": "StorageBuffer",
      "string": "StorageBuffer()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Inherit from Buffer.</p>",
      "summary": "<p>Inherit from Buffer.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 63,
    "codeStart": 67,
    "code": "//StorageBuffer.prototype = new Buffer(0);\n\nStorageBuffer.mixin = {"
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      },
      {
        "type": "property",
        "types": [
          "_parent"
        ],
        "name": "",
        "description": "",
        "optional": false
      }
    ],
    "description": {
      "full": "<p>Parent owner document</p>",
      "summary": "<p>Parent owner document</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": false,
    "line": 71,
    "codeStart": 78,
    "code": "_parent: undefined,",
    "ctx": {
      "type": "property",
      "name": "_parent",
      "value": "undefined,",
      "string": "_parent"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      },
      {
        "type": "property",
        "types": [
          "_subtype"
        ],
        "name": "",
        "description": "",
        "optional": false
      }
    ],
    "description": {
      "full": "<p>Default subtype for the Binary representing this Buffer</p>",
      "summary": "<p>Default subtype for the Binary representing this Buffer</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": false,
    "line": 80,
    "codeStart": 87,
    "code": "_subtype: undefined,",
    "ctx": {
      "type": "property",
      "name": "_subtype",
      "value": "undefined,",
      "string": "_subtype"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Marks this buffer as modified.</p>",
      "summary": "<p>Marks this buffer as modified.</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": false,
    "line": 89,
    "codeStart": 95,
    "code": "_markModified: function () {\n  var parent = this._parent;\n\n  if (parent) {\n    parent.markModified(this._path);\n  }\n  return this;\n},",
    "ctx": {
      "type": "method",
      "name": "_markModified",
      "string": "_markModified()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Writes the buffer.</p>",
      "summary": "<p>Writes the buffer.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 104,
    "codeStart": 108,
    "code": "write: function () {\n  var written = Buffer.prototype.write.apply(this, arguments);\n\n  if (written > 0) {\n    this._markModified();\n  }\n\n  return written;\n},",
    "ctx": {
      "type": "method",
      "name": "write",
      "string": "write()"
    }
  },
  {
    "tags": [
      {
        "type": "return",
        "types": [
          "StorageBuffer"
        ],
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "Buffer"
        ],
        "name": "target",
        "description": "",
        "optional": false
      }
    ],
    "description": {
      "full": "<p>Copies the buffer.</p><h4>Note:</h4>\n<p><code>Buffer#copy</code> does not mark <code>target</code> as modified so you must copy from a <code>StorageBuffer</code> for it to work as expected. This is a work around since <code>copy</code> modifies the target, not this.</p>",
      "summary": "<p>Copies the buffer.</p>",
      "body": "<h4>Note:</h4>\n<p><code>Buffer#copy</code> does not mark <code>target</code> as modified so you must copy from a <code>StorageBuffer</code> for it to work as expected. This is a work around since <code>copy</code> modifies the target, not this.</p>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 118,
    "codeStart": 129,
    "code": "copy: function (target) {\n  var ret = Buffer.prototype.copy.apply(this, arguments);\n\n  if (target && target.isStorageBuffer) {\n    target._markModified();\n  }\n\n  return ret;\n}\n};",
    "ctx": {
      "type": "method",
      "name": "copy",
      "string": "copy()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Compile other Buffer methods marking this buffer as modified.</p>",
      "summary": "<p>Compile other Buffer methods marking this buffer as modified.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 140,
    "codeStart": 144,
    "code": ";(\n// node < 0.5\n'writeUInt8 writeUInt16 writeUInt32 writeInt8 writeInt16 writeInt32 ' +\n'writeFloat writeDouble fill ' +\n'utf8Write binaryWrite asciiWrite set ' +\n\n// node >= 0.5\n'writeUInt16LE writeUInt16BE writeUInt32LE writeUInt32BE ' +\n'writeInt16LE writeInt16BE writeInt32LE writeInt32BE ' +\n'writeFloatLE writeFloatBE writeDoubleLE writeDoubleBE'\n).split(' ').forEach(function (method) {\n  if (!Buffer.prototype[method]) return;\n    StorageBuffer.mixin[method] = new Function(\n    'var ret = Buffer.prototype.'+method+'.apply(this, arguments);' +\n    'this._markModified();' +\n    'return ret;'\n  )\n});"
  },
  {
    "tags": [
      {
        "type": "see",
        "title": "",
        "url": "http://bsonspec.org/#/specification"
      },
      {
        "type": "param",
        "types": [
          "Hex"
        ],
        "name": "[subtype]",
        "description": "",
        "optional": true
      },
      {
        "type": "return",
        "types": [
          "Binary"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Converts this buffer to its Binary type representation.</p><h4>SubTypes:</h4>\n<p>  var bson = require(&#39;bson&#39;)<br />  bson.BSON_BINARY_SUBTYPE_DEFAULT<br />  bson.BSON_BINARY_SUBTYPE_FUNCTION<br />  bson.BSON_BINARY_SUBTYPE_BYTE_ARRAY<br />  bson.BSON_BINARY_SUBTYPE_UUID<br />  bson.BSON_BINARY_SUBTYPE_MD5<br />  bson.BSON_BINARY_SUBTYPE_USER_DEFINED</p><p>  doc.buffer.toObject(bson.BSON_BINARY_SUBTYPE_USER_DEFINED);</p>",
      "summary": "<p>Converts this buffer to its Binary type representation.</p>",
      "body": "<h4>SubTypes:</h4>\n<p>  var bson = require(&#39;bson&#39;)<br />  bson.BSON_BINARY_SUBTYPE_DEFAULT<br />  bson.BSON_BINARY_SUBTYPE_FUNCTION<br />  bson.BSON_BINARY_SUBTYPE_BYTE_ARRAY<br />  bson.BSON_BINARY_SUBTYPE_UUID<br />  bson.BSON_BINARY_SUBTYPE_MD5<br />  bson.BSON_BINARY_SUBTYPE_USER_DEFINED</p><p>  doc.buffer.toObject(bson.BSON_BINARY_SUBTYPE_USER_DEFINED);</p>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 163,
    "codeStart": 184,
    "code": "StorageBuffer.mixin.toObject = function (options) {\n  var subtype = 'number' == typeof options\n    ? options\n    : (this._subtype || 0);\n  return new Binary(this, subtype);\n};",
    "ctx": {
      "type": "method",
      "receiver": "StorageBuffer.mixin",
      "name": "toObject",
      "string": "StorageBuffer.mixin.toObject()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Buffer"
        ],
        "name": "other",
        "description": "",
        "optional": false
      },
      {
        "type": "return",
        "types": [
          "Boolean"
        ],
        "description": ""
      }
    ],
    "description": {
      "full": "<p>Determines if this buffer is equals to <code>other</code> buffer</p>",
      "summary": "<p>Determines if this buffer is equals to <code>other</code> buffer</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 191,
    "codeStart": 198,
    "code": "StorageBuffer.mixin.equals = function (other) {\n  if (!Buffer.isBuffer(other)) {\n    return false;\n  }\n\n  if (this.length !== other.length) {\n    return false;\n  }\n\n  for (var i = 0; i < this.length; ++i) {\n    if (this[i] !== other[i]) return false;\n  }\n\n  return true;\n};",
    "ctx": {
      "type": "method",
      "receiver": "StorageBuffer.mixin",
      "name": "equals",
      "string": "StorageBuffer.mixin.equals()"
    }
  },
  {
    "tags": [
      {
        "type": "see",
        "title": "",
        "url": "http://bsonspec.org/#/specification"
      },
      {
        "type": "param",
        "types": [
          "Hex"
        ],
        "name": "subtype",
        "description": "",
        "optional": false
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Sets the subtype option and marks the buffer modified.</p><h4>SubTypes:</h4>\n<p>  var bson = require(&#39;bson&#39;)<br />  bson.BSON_BINARY_SUBTYPE_DEFAULT<br />  bson.BSON_BINARY_SUBTYPE_FUNCTION<br />  bson.BSON_BINARY_SUBTYPE_BYTE_ARRAY<br />  bson.BSON_BINARY_SUBTYPE_UUID<br />  bson.BSON_BINARY_SUBTYPE_MD5<br />  bson.BSON_BINARY_SUBTYPE_USER_DEFINED</p><p>  doc.buffer.subtype(bson.BSON_BINARY_SUBTYPE_UUID);</p>",
      "summary": "<p>Sets the subtype option and marks the buffer modified.</p>",
      "body": "<h4>SubTypes:</h4>\n<p>  var bson = require(&#39;bson&#39;)<br />  bson.BSON_BINARY_SUBTYPE_DEFAULT<br />  bson.BSON_BINARY_SUBTYPE_FUNCTION<br />  bson.BSON_BINARY_SUBTYPE_BYTE_ARRAY<br />  bson.BSON_BINARY_SUBTYPE_UUID<br />  bson.BSON_BINARY_SUBTYPE_MD5<br />  bson.BSON_BINARY_SUBTYPE_USER_DEFINED</p><p>  doc.buffer.subtype(bson.BSON_BINARY_SUBTYPE_UUID);</p>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 214,
    "codeStart": 234,
    "code": "StorageBuffer.mixin.subtype = function (subtype) {\n  if ('number' != typeof subtype) {\n    throw new TypeError('Invalid subtype. Expected a number');\n  }\n\n  if (this._subtype != subtype) {\n    this._markModified();\n  }\n\n  this._subtype = subtype;\n};",
    "ctx": {
      "type": "method",
      "receiver": "StorageBuffer.mixin",
      "name": "subtype",
      "string": "StorageBuffer.mixin.subtype()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Module exports.</p>",
      "summary": "<p>Module exports.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 246,
    "codeStart": 250,
    "code": "StorageBuffer.Binary = Binary;\n\nmodule.exports = StorageBuffer;",
    "ctx": {
      "type": "property",
      "receiver": "StorageBuffer",
      "name": "Binary",
      "value": "Binary",
      "string": "StorageBuffer.Binary"
    }
  }
]
### lib/types/documentarray.js
[
  {
    "tags": [],
    "description": {
      "full": "<p>Module dependencies.</p>",
      "summary": "<p>Module dependencies.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 1,
    "codeStart": 5,
    "code": "var StorageArray = require('./array')\n  , ObjectId = require('./objectid')\n  , ObjectIdSchema = require('../schema/objectid')\n  , utils = require('../utils')\n  , Document = require('../document');",
    "ctx": {
      "type": "declaration",
      "name": "StorageArray",
      "value": "require('./array')",
      "string": "StorageArray"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Array"
        ],
        "name": "values",
        "description": "",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "path",
        "description": "the path to this array",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "Document"
        ],
        "name": "doc",
        "description": "parent document",
        "optional": false
      },
      {
        "type": "api",
        "visibility": "private"
      },
      {
        "type": "return",
        "types": [
          "StorageDocumentArray"
        ],
        "description": ""
      },
      {
        "type": "inherits",
        "string": "StorageArray"
      },
      {
        "type": "see",
        "title": "http://bit.ly/f6CnZU",
        "url": "TODO: подчистить код\n\nВесь нужный код скопирован"
      }
    ],
    "description": {
      "full": "<p>DocumentArray constructor</p>",
      "summary": "<p>DocumentArray constructor</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": false,
    "line": 11,
    "codeStart": 25,
    "code": "function StorageDocumentArray (values, path, doc) {\n  var arr = [];\n\n  // Values always have to be passed to the constructor to initialize, since\n  // otherwise StorageArray#push will mark the array as modified to the parent.\n  arr.push.apply(arr, values);\n  _.mixin( arr, StorageDocumentArray.mixin );\n\n  arr.validators = [];\n  arr._path = path;\n  arr.isStorageArray = true;\n  arr.isStorageDocumentArray = true;\n\n  if (doc) {\n    arr._parent = doc;\n    arr._schema = doc.schema.path(path);\n    arr._handlers = {\n      isNew: arr.notify('isNew'),\n      save: arr.notify('save')\n    };\n\n    // Проброс изменения состояния в поддокумент\n    doc.on('save', arr._handlers.save);\n    doc.on('isNew', arr._handlers.isNew);\n  }\n\n  return arr;\n}",
    "ctx": {
      "type": "function",
      "name": "StorageDocumentArray",
      "string": "StorageDocumentArray()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Inherits from StorageArray</p>",
      "summary": "<p>Inherits from StorageArray</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 54,
    "codeStart": 57,
    "code": "StorageDocumentArray.mixin = Object.create( StorageArray.mixin );",
    "ctx": {
      "type": "property",
      "receiver": "StorageDocumentArray",
      "name": "mixin",
      "value": "Object.create( StorageArray.mixin )",
      "string": "StorageDocumentArray.mixin"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Overrides StorageArray#cast</p>",
      "summary": "<p>Overrides StorageArray#cast</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": false,
    "line": 59,
    "codeStart": 64,
    "code": "StorageDocumentArray.mixin._cast = function (value) {\n  if (value instanceof this._schema.casterConstructor) {\n    if (!(value.__parent && value.__parentArray)) {\n      // value may have been created using array.create()\n      value.__parent = this._parent;\n      value.__parentArray = this;\n    }\n    return value;\n  }\n\n  // handle cast('string') or cast(ObjectId) etc.\n  // only objects are permitted so we can safely assume that\n  // non-objects are to be interpreted as _id\n  if ( value instanceof ObjectId || !_.isObject(value) ) {\n    value = { _id: value };\n  }\n\n  return new this._schema.casterConstructor(value, this);\n};",
    "ctx": {
      "type": "method",
      "receiver": "StorageDocumentArray.mixin",
      "name": "_cast",
      "string": "StorageDocumentArray.mixin._cast()"
    }
  },
  {
    "tags": [
      {
        "type": "return",
        "types": [
          "EmbeddedDocument",
          "null"
        ],
        "description": "the subdocument or null if not found."
      },
      {
        "type": "param",
        "types": [
          "ObjectId",
          "String",
          "Number"
        ],
        "name": "id",
        "description": "",
        "optional": false
      },
      {
        "type": "TODO",
        "string": "cast to the _id based on schema for proper comparison"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Searches array items for the first document with a matching _id.</p><h4>Example:</h4>\n<pre><code>var embeddedDoc = m.array.id(some_id);\n</code></pre>",
      "summary": "<p>Searches array items for the first document with a matching _id.</p>",
      "body": "<h4>Example:</h4>\n<pre><code>var embeddedDoc = m.array.id(some_id);\n</code></pre>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 84,
    "codeStart": 96,
    "code": "StorageDocumentArray.mixin.id = function (id) {\n  var casted\n    , sid\n    , _id;\n\n  try {\n    var casted_ = ObjectIdSchema.prototype.cast.call({}, id);\n    if (casted_) casted = String(casted_);\n  } catch (e) {\n    casted = null;\n  }\n\n  for (var i = 0, l = this.length; i < l; i++) {\n    _id = this[i].get('_id');\n\n    if (_id instanceof Document) {\n      sid || (sid = String(id));\n      if (sid == _id._id) return this[i];\n    } else if (!(_id instanceof ObjectId)) {\n      sid || (sid = String(id));\n      if (sid == _id) return this[i];\n    } else if (casted == _id) {\n      return this[i];\n    }\n  }\n\n  return null;\n};",
    "ctx": {
      "type": "method",
      "receiver": "StorageDocumentArray.mixin",
      "name": "id",
      "string": "StorageDocumentArray.mixin.id()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "[options]",
        "description": "optional options to pass to each documents `toObject` method call during conversion",
        "optional": true
      },
      {
        "type": "return",
        "types": [
          "Array"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Returns a native js Array of plain js objects</p><h4>NOTE:</h4>\n<p><em>Each sub-document is converted to a plain object by calling its <code>#toObject</code> method.</em></p>",
      "summary": "<p>Returns a native js Array of plain js objects</p>",
      "body": "<h4>NOTE:</h4>\n<p><em>Each sub-document is converted to a plain object by calling its <code>#toObject</code> method.</em></p>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 125,
    "codeStart": 137,
    "code": "StorageDocumentArray.mixin.toObject = function (options) {\n  return this.map(function (doc) {\n    return doc && doc.toObject(options) || null;\n  });\n};",
    "ctx": {
      "type": "method",
      "receiver": "StorageDocumentArray.mixin",
      "name": "toObject",
      "string": "StorageDocumentArray.mixin.toObject()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "obj",
        "description": "the value to cast to this arrays SubDocument schema",
        "optional": false
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Creates a subdocument casted to this schema.</p><p>This is the same subdocument constructor used for casting.</p>",
      "summary": "<p>Creates a subdocument casted to this schema.</p>",
      "body": "<p>This is the same subdocument constructor used for casting.</p>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 143,
    "codeStart": 152,
    "code": "StorageDocumentArray.mixin.create = function (obj) {\n  return new this._schema.casterConstructor(obj);\n};",
    "ctx": {
      "type": "method",
      "receiver": "StorageDocumentArray.mixin",
      "name": "create",
      "string": "StorageDocumentArray.mixin.create()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "event",
        "description": "",
        "optional": false
      },
      {
        "type": "return",
        "types": [
          "Function"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Creates a fn that notifies all child docs of <code>event</code>.</p>",
      "summary": "<p>Creates a fn that notifies all child docs of <code>event</code>.</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": false,
    "line": 156,
    "codeStart": 163,
    "code": "StorageDocumentArray.mixin.notify = function notify (event) {\n  var self = this;\n  return function notify (val) {\n    var i = self.length;\n    while (i--) {\n      if (!self[i]) continue;\n      self[i].trigger(event, val);\n    }\n  }\n};",
    "ctx": {
      "type": "method",
      "receiver": "StorageDocumentArray.mixin",
      "name": "notify",
      "string": "StorageDocumentArray.mixin.notify()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Module exports.</p>",
      "summary": "<p>Module exports.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 174,
    "codeStart": 178,
    "code": "module.exports = StorageDocumentArray;",
    "ctx": {
      "type": "property",
      "receiver": "module",
      "name": "exports",
      "value": "StorageDocumentArray",
      "string": "module.exports"
    }
  }
]
### lib/types/embedded.js
[
  {
    "tags": [],
    "description": {
      "full": "<p>Module dependencies.</p>",
      "summary": "<p>Module dependencies.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 1,
    "codeStart": 5,
    "code": "var Document = require('../document');",
    "ctx": {
      "type": "declaration",
      "name": "Document",
      "value": "require('../document')",
      "string": "Document"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "data",
        "description": "js object returned from the db",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "StorageDocumentArray"
        ],
        "name": "parentArr",
        "description": "the parent array of this document",
        "optional": false
      },
      {
        "type": "inherits",
        "string": "Document"
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>EmbeddedDocument constructor.</p>",
      "summary": "<p>EmbeddedDocument constructor.</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": false,
    "line": 7,
    "codeStart": 15,
    "code": "function EmbeddedDocument ( data, parentArr ) {\n  if (parentArr) {\n    this.__parentArray = parentArr;\n    this.__parent = parentArr._parent;\n  } else {\n    this.__parentArray = undefined;\n    this.__parent = undefined;\n  }\n\n  Document.call( this, data, undefined );\n\n  // Нужно для проброса изменения значения из родительского документа, например при сохранении\n  var self = this;\n  this.on('isNew', function (val) {\n    self.isNew = val;\n  });\n}",
    "ctx": {
      "type": "function",
      "name": "EmbeddedDocument",
      "string": "EmbeddedDocument()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Inherit from Document</p>",
      "summary": "<p>Inherit from Document</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 33,
    "codeStart": 36,
    "code": "EmbeddedDocument.prototype = Object.create( Document.prototype );\nEmbeddedDocument.prototype.constructor = EmbeddedDocument;",
    "ctx": {
      "type": "property",
      "receiver": "EmbeddedDocument",
      "name": "prototype",
      "value": "Object.create( Document.prototype )",
      "string": "EmbeddedDocument.prototype"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "path",
        "description": "the path which changed",
        "optional": false
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Marks the embedded doc modified.</p><h4>Example:</h4>\n<pre><code>var doc = blogpost.comments.id(hexstring);\ndoc.mixed.type = &#39;changed&#39;;\ndoc.markModified(&#39;mixed.type&#39;);\n</code></pre>",
      "summary": "<p>Marks the embedded doc modified.</p>",
      "body": "<h4>Example:</h4>\n<pre><code>var doc = blogpost.comments.id(hexstring);\ndoc.mixed.type = &#39;changed&#39;;\ndoc.markModified(&#39;mixed.type&#39;);\n</code></pre>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 39,
    "codeStart": 51,
    "code": "EmbeddedDocument.prototype.markModified = function (path) {\n  if (!this.__parentArray) return;\n\n  this.$__.activePaths.modify(path);\n\n  if (this.isNew) {\n    // Mark the WHOLE parent array as modified\n    // if this is a new document (i.e., we are initializing\n    // a document),\n    this.__parentArray._markModified();\n  } else\n    this.__parentArray._markModified(this, path);\n};",
    "ctx": {
      "type": "method",
      "constructor": "EmbeddedDocument",
      "cons": "EmbeddedDocument",
      "name": "markModified",
      "string": "EmbeddedDocument.prototype.markModified()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "[fn]",
        "description": "",
        "optional": true
      },
      {
        "type": "return",
        "types": [
          "Promise"
        ],
        "description": "resolved Promise"
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Used as a stub for <a href=\"https://github.com/bnoguchi/hooks-js/tree/31ec571cef0332e21121ee7157e0cf9728572cc3\">hooks.js</a></p><h4>NOTE:</h4>\n<p><em>This is a no-op. Does not actually save the doc to the db.</em></p>",
      "summary": "<p>Used as a stub for <a href=\"https://github.com/bnoguchi/hooks-js/tree/31ec571cef0332e21121ee7157e0cf9728572cc3\">hooks.js</a></p>",
      "body": "<h4>NOTE:</h4>\n<p><em>This is a no-op. Does not actually save the doc to the db.</em></p>"
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": false,
    "line": 65,
    "codeStart": 77,
    "code": "EmbeddedDocument.prototype.save = function (fn) {\n  var promise = $.Deferred().done(fn);\n  promise.resolve();\n  return promise;\n}",
    "ctx": {
      "type": "method",
      "constructor": "EmbeddedDocument",
      "cons": "EmbeddedDocument",
      "name": "save",
      "string": "EmbeddedDocument.prototype.save()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "[fn]",
        "description": "",
        "optional": true
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Removes the subdocument from its parent array.</p>",
      "summary": "<p>Removes the subdocument from its parent array.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 83,
    "codeStart": 89,
    "code": "EmbeddedDocument.prototype.remove = function (fn) {\n  if (!this.__parentArray) return this;\n\n  var _id;\n  if (!this.willRemove) {\n    _id = this._doc._id;\n    if (!_id) {\n      throw new Error('For your own good, Storage does not know ' +\n                      'how to remove an EmbeddedDocument that has no _id');\n    }\n    this.__parentArray.pull({ _id: _id });\n    this.willRemove = true;\n  }\n\n  if (fn)\n    fn(null);\n\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "EmbeddedDocument",
      "cons": "EmbeddedDocument",
      "name": "remove",
      "string": "EmbeddedDocument.prototype.remove()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Override #update method of parent documents.</p>",
      "summary": "<p>Override #update method of parent documents.</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": false,
    "line": 109,
    "codeStart": 113,
    "code": "EmbeddedDocument.prototype.update = function () {\n  throw new Error('The #update method is not available on EmbeddedDocuments');\n};",
    "ctx": {
      "type": "method",
      "constructor": "EmbeddedDocument",
      "cons": "EmbeddedDocument",
      "name": "update",
      "string": "EmbeddedDocument.prototype.update()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "path",
        "description": "the field to invalidate",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "String",
          "Error"
        ],
        "name": "err",
        "description": "error which states the reason `path` was invalid",
        "optional": false
      },
      {
        "type": "return",
        "types": [
          "Boolean"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Marks a path as invalid, causing validation to fail.</p>",
      "summary": "<p>Marks a path as invalid, causing validation to fail.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 117,
    "codeStart": 125,
    "code": "EmbeddedDocument.prototype.invalidate = function (path, err, val, first) {\n  if (!this.__parent) {\n    var msg = 'Unable to invalidate a subdocument that has not been added to an array.'\n    throw new Error(msg);\n  }\n\n  var index = this.__parentArray.indexOf(this);\n  var parentPath = this.__parentArray._path;\n  var fullPath = [parentPath, index, path].join('.');\n\n  // sniffing arguments:\n  // need to check if user passed a value to keep\n  // our error message clean.\n  if (2 < arguments.length) {\n    this.__parent.invalidate(fullPath, err, val);\n  } else {\n    this.__parent.invalidate(fullPath, err);\n  }\n\n  if (first)\n    this.$__.validationError = this.ownerDocument().$__.validationError;\n  return true;\n};",
    "ctx": {
      "type": "method",
      "constructor": "EmbeddedDocument",
      "cons": "EmbeddedDocument",
      "name": "invalidate",
      "string": "EmbeddedDocument.prototype.invalidate()"
    }
  },
  {
    "tags": [
      {
        "type": "return",
        "types": [
          "Document"
        ],
        "description": ""
      }
    ],
    "description": {
      "full": "<p>Returns the top level document of this sub-document.</p>",
      "summary": "<p>Returns the top level document of this sub-document.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 149,
    "codeStart": 154,
    "code": "EmbeddedDocument.prototype.ownerDocument = function () {\n  if (this.$__.ownerDocument) {\n    return this.$__.ownerDocument;\n  }\n\n  var parent = this.__parent;\n  if (!parent) return this;\n\n  while (parent.__parent) {\n    parent = parent.__parent;\n  }\n\n  return this.$__.ownerDocument = parent;\n};",
    "ctx": {
      "type": "method",
      "constructor": "EmbeddedDocument",
      "cons": "EmbeddedDocument",
      "name": "ownerDocument",
      "string": "EmbeddedDocument.prototype.ownerDocument()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "[path]",
        "description": "",
        "optional": true
      },
      {
        "type": "return",
        "types": [
          "String"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "private"
      },
      {
        "type": "method",
        "string": "$__fullPath"
      },
      {
        "type": "memberOf",
        "parent": "EmbeddedDocument"
      }
    ],
    "description": {
      "full": "<p>Returns the full path to this document. If optional <code>path</code> is passed, it is appended to the full path.</p>",
      "summary": "<p>Returns the full path to this document. If optional <code>path</code> is passed, it is appended to the full path.</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": false,
    "line": 169,
    "codeStart": 178,
    "code": "EmbeddedDocument.prototype.$__fullPath = function (path) {\n  if (!this.$__.fullPath) {\n    var parent = this;\n    if (!parent.__parent) return path;\n\n    var paths = [];\n    while (parent.__parent) {\n      paths.unshift(parent.__parentArray._path);\n      parent = parent.__parent;\n    }\n\n    this.$__.fullPath = paths.join('.');\n\n    if (!this.$__.ownerDocument) {\n      // optimization\n      this.$__.ownerDocument = parent;\n    }\n  }\n\n  return path\n    ? this.$__.fullPath + '.' + path\n    : this.$__.fullPath;\n};",
    "ctx": {
      "type": "method",
      "constructor": "EmbeddedDocument",
      "cons": "EmbeddedDocument",
      "name": "$__fullPath",
      "string": "EmbeddedDocument.prototype.$__fullPath()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Returns this sub-documents parent document.</p>",
      "summary": "<p>Returns this sub-documents parent document.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 202,
    "codeStart": 207,
    "code": "EmbeddedDocument.prototype.parent = function () {\n  return this.__parent;\n};",
    "ctx": {
      "type": "method",
      "constructor": "EmbeddedDocument",
      "cons": "EmbeddedDocument",
      "name": "parent",
      "string": "EmbeddedDocument.prototype.parent()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Returns this sub-documents parent array.</p>",
      "summary": "<p>Returns this sub-documents parent array.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 211,
    "codeStart": 216,
    "code": "EmbeddedDocument.prototype.parentArray = function () {\n  return this.__parentArray;\n};",
    "ctx": {
      "type": "method",
      "constructor": "EmbeddedDocument",
      "cons": "EmbeddedDocument",
      "name": "parentArray",
      "string": "EmbeddedDocument.prototype.parentArray()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Module exports.</p>",
      "summary": "<p>Module exports.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 220,
    "codeStart": 224,
    "code": "module.exports = EmbeddedDocument;",
    "ctx": {
      "type": "property",
      "receiver": "module",
      "name": "exports",
      "value": "EmbeddedDocument",
      "string": "module.exports"
    }
  }
]
### lib/types/index.js
[
  {
    "tags": [],
    "description": {
      "full": "<p>Module exports.</p>",
      "summary": "<p>Module exports.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 2,
    "codeStart": 6,
    "code": "exports.Array = require('./array');\nexports.Buffer = require('./buffer');\n\nexports.Embedded = require('./embedded');\n\nexports.DocumentArray = require('./documentarray');\nexports.ObjectId = require('./objectid');",
    "ctx": {
      "type": "property",
      "receiver": "exports",
      "name": "Array",
      "value": "require('./array')",
      "string": "exports.Array"
    }
  }
]
### lib/types/objectid.js
[
  {
    "tags": [
      {
        "type": "ignore",
        "string": ""
      }
    ],
    "description": {
      "full": "<p>Module dependencies.</p>",
      "summary": "<p>Module dependencies.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 1,
    "codeStart": 5,
    "code": "var BinaryParser = require('../binaryparser').BinaryParser;",
    "ctx": {
      "type": "declaration",
      "name": "BinaryParser",
      "value": "require('../binaryparser').BinaryParser",
      "string": "BinaryParser"
    }
  },
  {
    "tags": [
      {
        "type": "ignore",
        "string": ""
      }
    ],
    "description": {
      "full": "<p>Machine id.</p><p>Create a random 3-byte value (i.e. unique for this<br />process). Other drivers use a md5 of the machine id here, but<br />that would mean an asyc call to gethostname, so we don&#39;t bother.</p>",
      "summary": "<p>Machine id.</p>",
      "body": "<p>Create a random 3-byte value (i.e. unique for this<br />process). Other drivers use a md5 of the machine id here, but<br />that would mean an asyc call to gethostname, so we don&#39;t bother.</p>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 7,
    "codeStart": 15,
    "code": "var MACHINE_ID = parseInt(Math.random() * 0xFFFFFF, 10);\n\n// Regular expression that checks for hex value\nvar checkForHexRegExp = new RegExp(\"^[0-9a-fA-F]{24}$\");",
    "ctx": {
      "type": "declaration",
      "name": "MACHINE_ID",
      "value": "parseInt(Math.random() * 0xFFFFFF, 10)",
      "string": "MACHINE_ID"
    }
  },
  {
    "tags": [
      {
        "type": "see",
        "title": "",
        "url": "https://github.com/mongodb/js-bson/blob/master/lib/bson/objectid.js"
      },
      {
        "type": "class",
        "string": "Represents a BSON ObjectId type."
      },
      {
        "type": "param",
        "types": [
          "(string",
          "number)"
        ],
        "name": "id",
        "description": "Can be a 24 byte hex string, 12 byte binary string or a Number.",
        "optional": false
      },
      {
        "type": "property",
        "types": [
          "number"
        ],
        "name": "generationTime",
        "description": "The generation time of this ObjectId instance",
        "optional": false
      },
      {
        "type": "return",
        "types": [
          "ObjectId"
        ],
        "description": "instance of ObjectId."
      }
    ],
    "description": {
      "full": "<p>Create a new ObjectId instance</p>",
      "summary": "<p>Create a new ObjectId instance</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 20,
    "codeStart": 29,
    "code": "function ObjectId(id) {\n  if(!(this instanceof ObjectId)) return new ObjectId(id);\n  if((id instanceof ObjectId)) return id;\n\n  this._bsontype = 'ObjectId';\n  var valid = ObjectId.isValid(id);\n\n  // Throw an error if it's not a valid setup\n  if(!valid && id != null){\n    throw new Error(\"Argument passed in must be a single String of 12 bytes or a string of 24 hex characters\");\n  } else if(valid && typeof id == 'string' && id.length == 24) {\n    return ObjectId.createFromHexString(id);\n  } else if(id == null || typeof id == 'number') {\n    // convert to 12 byte binary string\n    this.id = this.generate(id);\n  } else if(id != null && id.length === 12) {\n    // assume 12 byte string\n    this.id = id;\n  }\n\n  if(ObjectId.cacheHexString) this.__id = this.toHexString();\n}\n\n// Precomputed hex table enables speedy hex string conversion\nvar hexTable = [];\nfor (var i = 0; i < 256; i++) {\n  hexTable[i] = (i <= 15 ? '0' : '') + i.toString(16);\n}",
    "ctx": {
      "type": "function",
      "name": "ObjectId",
      "string": "ObjectId()"
    }
  },
  {
    "tags": [
      {
        "type": "method",
        "string": ""
      },
      {
        "type": "return",
        "types": [
          "string"
        ],
        "description": "return the 24 byte hex string representation."
      }
    ],
    "description": {
      "full": "<p>Return the ObjectId id as a 24 byte hex string representation</p>",
      "summary": "<p>Return the ObjectId id as a 24 byte hex string representation</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 58,
    "codeStart": 64,
    "code": "ObjectId.prototype.toHexString = function() {\n  if(ObjectId.cacheHexString && this.__id) return this.__id;\n\n  var hexString = '';\n\n  for (var i = 0; i < this.id.length; i++) {\n    hexString += hexTable[this.id.charCodeAt(i)];\n  }\n\n  if(ObjectId.cacheHexString) this.__id = hexString;\n  return hexString;\n};",
    "ctx": {
      "type": "method",
      "constructor": "ObjectId",
      "cons": "ObjectId",
      "name": "toHexString",
      "string": "ObjectId.prototype.toHexString()"
    }
  },
  {
    "tags": [
      {
        "type": "method",
        "string": ""
      },
      {
        "type": "return",
        "types": [
          "number"
        ],
        "description": "returns next index value."
      },
      {
        "type": "ignore",
        "string": ""
      }
    ],
    "description": {
      "full": "<p>Update the ObjectId index used in generating new ObjectId&#39;s on the driver</p>",
      "summary": "<p>Update the ObjectId index used in generating new ObjectId&#39;s on the driver</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 77,
    "codeStart": 84,
    "code": "ObjectId.prototype.get_inc = function() {\n  return ObjectId.index = (ObjectId.index + 1) % 0xFFFFFF;\n};",
    "ctx": {
      "type": "method",
      "constructor": "ObjectId",
      "cons": "ObjectId",
      "name": "get_inc",
      "string": "ObjectId.prototype.get_inc()"
    }
  },
  {
    "tags": [
      {
        "type": "method",
        "string": ""
      },
      {
        "type": "return",
        "types": [
          "number"
        ],
        "description": "returns next index value."
      },
      {
        "type": "ignore",
        "string": ""
      }
    ],
    "description": {
      "full": "<p>Update the ObjectId index used in generating new ObjectId&#39;s on the driver</p>",
      "summary": "<p>Update the ObjectId index used in generating new ObjectId&#39;s on the driver</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 88,
    "codeStart": 95,
    "code": "ObjectId.prototype.getInc = function() {\n  return this.get_inc();\n};",
    "ctx": {
      "type": "method",
      "constructor": "ObjectId",
      "cons": "ObjectId",
      "name": "getInc",
      "string": "ObjectId.prototype.getInc()"
    }
  },
  {
    "tags": [
      {
        "type": "method",
        "string": ""
      },
      {
        "type": "param",
        "types": [
          "number"
        ],
        "name": "[time]",
        "description": "optional parameter allowing to pass in a second based timestamp.",
        "optional": true
      },
      {
        "type": "return",
        "types": [
          "string"
        ],
        "description": "return the 12 byte id binary string."
      }
    ],
    "description": {
      "full": "<p>Generate a 12 byte id string used in ObjectId&#39;s</p>",
      "summary": "<p>Generate a 12 byte id string used in ObjectId&#39;s</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 99,
    "codeStart": 106,
    "code": "ObjectId.prototype.generate = function(time) {\n  if ('number' != typeof time) {\n    time = parseInt(Date.now()/1000,10);\n  }\n\n  var time4Bytes = BinaryParser.encodeInt(time, 32, true, true);",
    "ctx": {
      "type": "method",
      "constructor": "ObjectId",
      "cons": "ObjectId",
      "name": "generate",
      "string": "ObjectId.prototype.generate()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>for time-based ObjectId the bytes following the time will be zeroed</p>",
      "summary": "<p>for time-based ObjectId the bytes following the time will be zeroed</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 112,
    "codeStart": 113,
    "code": "var machine3Bytes = BinaryParser.encodeInt(MACHINE_ID, 24, false);\nvar pid2Bytes = BinaryParser.fromShort(typeof process === 'undefined' ? Math.floor(Math.random() * 100000) : process.pid);\nvar index3Bytes = BinaryParser.encodeInt(this.get_inc(), 24, false, true);\n\nreturn time4Bytes + machine3Bytes + pid2Bytes + index3Bytes;\n};",
    "ctx": {
      "type": "declaration",
      "name": "machine3Bytes",
      "value": "BinaryParser.encodeInt(MACHINE_ID, 24, false)",
      "string": "machine3Bytes"
    }
  },
  {
    "tags": [
      {
        "type": "return",
        "types": [
          "String"
        ],
        "description": "return the 24 byte hex string representation."
      },
      {
        "type": "ignore",
        "string": ""
      }
    ],
    "description": {
      "full": "<p>Converts the id into a 24 byte hex string for printing</p>",
      "summary": "<p>Converts the id into a 24 byte hex string for printing</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 120,
    "codeStart": 126,
    "code": "ObjectId.prototype.toString = function() {\n  return this.toHexString();\n};",
    "ctx": {
      "type": "method",
      "constructor": "ObjectId",
      "cons": "ObjectId",
      "name": "toString",
      "string": "ObjectId.prototype.toString()"
    }
  },
  {
    "tags": [
      {
        "type": "return",
        "types": [
          "String"
        ],
        "description": "return the 24 byte hex string representation."
      },
      {
        "type": "ignore",
        "string": ""
      }
    ],
    "description": {
      "full": "<p>Converts to its JSON representation.</p>",
      "summary": "<p>Converts to its JSON representation.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 130,
    "codeStart": 136,
    "code": "ObjectId.prototype.toJSON = function() {\n  return this.toHexString();\n};",
    "ctx": {
      "type": "method",
      "constructor": "ObjectId",
      "cons": "ObjectId",
      "name": "toJSON",
      "string": "ObjectId.prototype.toJSON()"
    }
  },
  {
    "tags": [
      {
        "type": "method",
        "string": ""
      },
      {
        "type": "param",
        "types": [
          "object"
        ],
        "name": "otherID",
        "description": "ObjectId instance to compare against.",
        "optional": false
      },
      {
        "type": "return",
        "types": [
          "boolean"
        ],
        "description": "the result of comparing two ObjectId's"
      }
    ],
    "description": {
      "full": "<p>Compares the equality of this ObjectId with <code>otherID</code>.</p>",
      "summary": "<p>Compares the equality of this ObjectId with <code>otherID</code>.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 140,
    "codeStart": 147,
    "code": "ObjectId.prototype.equals = function equals (otherID) {\n  if(otherID == null) return false;\n  var id = (otherID instanceof ObjectId || otherID.toHexString)\n    ? otherID.id\n    : ObjectId.createFromHexString(otherID).id;\n\n  return this.id === id;\n};",
    "ctx": {
      "type": "method",
      "constructor": "ObjectId",
      "cons": "ObjectId",
      "name": "equals",
      "string": "ObjectId.prototype.equals()"
    }
  },
  {
    "tags": [
      {
        "type": "method",
        "string": ""
      },
      {
        "type": "return",
        "types": [
          "date"
        ],
        "description": "the generation date"
      }
    ],
    "description": {
      "full": "<p>Returns the generation date (accurate up to the second) that this ID was generated.</p>",
      "summary": "<p>Returns the generation date (accurate up to the second) that this ID was generated.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 156,
    "codeStart": 162,
    "code": "ObjectId.prototype.getTimestamp = function() {\n  var timestamp = new Date();\n  timestamp.setTime(Math.floor(BinaryParser.decodeInt(this.id.substring(0,4), 32, true, true)) * 1000);\n  return timestamp;\n};",
    "ctx": {
      "type": "method",
      "constructor": "ObjectId",
      "cons": "ObjectId",
      "name": "getTimestamp",
      "string": "ObjectId.prototype.getTimestamp()"
    }
  },
  {
    "tags": [
      {
        "type": "ignore",
        "string": ""
      }
    ],
    "description": {
      "full": "",
      "summary": "",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 168,
    "codeStart": 171,
    "code": "ObjectId.index = parseInt(Math.random() * 0xFFFFFF, 10);",
    "ctx": {
      "type": "property",
      "receiver": "ObjectId",
      "name": "index",
      "value": "parseInt(Math.random() * 0xFFFFFF, 10)",
      "string": "ObjectId.index"
    }
  },
  {
    "tags": [
      {
        "type": "ignore",
        "string": ""
      }
    ],
    "description": {
      "full": "",
      "summary": "",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 173,
    "codeStart": 176,
    "code": "ObjectId.createPk = function createPk () {\n  return new ObjectId();\n};",
    "ctx": {
      "type": "method",
      "receiver": "ObjectId",
      "name": "createPk",
      "string": "ObjectId.createPk()"
    }
  },
  {
    "tags": [
      {
        "type": "method",
        "string": ""
      },
      {
        "type": "param",
        "types": [
          "number"
        ],
        "name": "time",
        "description": "an integer number representing a number of seconds.",
        "optional": false
      },
      {
        "type": "return",
        "types": [
          "ObjectId"
        ],
        "description": "return the created ObjectId"
      }
    ],
    "description": {
      "full": "<p>Creates an ObjectId from a second based number, with the rest of the ObjectId zeroed out. Used for comparisons or sorting the ObjectId.</p>",
      "summary": "<p>Creates an ObjectId from a second based number, with the rest of the ObjectId zeroed out. Used for comparisons or sorting the ObjectId.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 180,
    "codeStart": 187,
    "code": "ObjectId.createFromTime = function createFromTime (time) {\n  var id = BinaryParser.encodeInt(time, 32, true, true) +\n    BinaryParser.encodeInt(0, 64, true, true);\n  return new ObjectId(id);\n};",
    "ctx": {
      "type": "method",
      "receiver": "ObjectId",
      "name": "createFromTime",
      "string": "ObjectId.createFromTime()"
    }
  },
  {
    "tags": [
      {
        "type": "method",
        "string": ""
      },
      {
        "type": "param",
        "types": [
          "string"
        ],
        "name": "hexString",
        "description": "create a ObjectId from a passed in 24 byte hexstring.",
        "optional": false
      },
      {
        "type": "return",
        "types": [
          "ObjectId"
        ],
        "description": "return the created ObjectId"
      }
    ],
    "description": {
      "full": "<p>Creates an ObjectId from a hex string representation of an ObjectId.</p>",
      "summary": "<p>Creates an ObjectId from a hex string representation of an ObjectId.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 193,
    "codeStart": 200,
    "code": "ObjectId.createFromHexString = function createFromHexString (hexString) {\n  // Throw an error if it's not a valid setup\n  if(typeof hexString === 'undefined' || hexString != null && hexString.length != 24)\n    throw new Error(\"Argument passed in must be a single String of 12 bytes or a string of 24 hex characters\");\n\n  var len = hexString.length;\n\n  if(len > 12*2) {\n    throw new Error('Id cannot be longer than 12 bytes');\n  }\n\n  var result = ''\n    , string\n    , number;\n\n  for (var index = 0; index < len; index += 2) {\n    string = hexString.substr(index, 2);\n    number = parseInt(string, 16);\n    result += BinaryParser.fromByte(number);\n  }\n\n  return new ObjectId(result, hexString);\n};",
    "ctx": {
      "type": "method",
      "receiver": "ObjectId",
      "name": "createFromHexString",
      "string": "ObjectId.createFromHexString()"
    }
  },
  {
    "tags": [
      {
        "type": "method",
        "string": ""
      },
      {
        "type": "return",
        "types": [
          "boolean"
        ],
        "description": "return true if the value is a valid bson ObjectId, return false otherwise."
      }
    ],
    "description": {
      "full": "<p>Checks if a value is a valid bson ObjectId</p>",
      "summary": "<p>Checks if a value is a valid bson ObjectId</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 224,
    "codeStart": 230,
    "code": "ObjectId.isValid = function isValid(id) {\n  if(id == null) return false;\n\n  if(id != null && 'number' != typeof id && (id.length != 12 && id.length != 24)) {\n    return false;\n  } else {\n    // Check specifically for hex correctness\n    if(typeof id == 'string' && id.length == 24) return checkForHexRegExp.test(id);\n    return true;\n  }\n};",
    "ctx": {
      "type": "method",
      "receiver": "ObjectId",
      "name": "isValid",
      "string": "ObjectId.isValid()"
    }
  },
  {
    "tags": [
      {
        "type": "ignore",
        "string": ""
      }
    ],
    "description": {
      "full": "",
      "summary": "",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 242,
    "codeStart": 245,
    "code": "Object.defineProperty(ObjectId.prototype, \"generationTime\", {\n  enumerable: true\n  , get: function () {\n    return Math.floor(BinaryParser.decodeInt(this.id.substring(0,4), 32, true, true));\n  }\n  , set: function (value) {\n    var value = BinaryParser.encodeInt(value, 32, true, true);\n    this.id = value + this.id.substr(4);\n    // delete this.__id;\n    this.toHexString();\n  }\n});"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Expose.</p>",
      "summary": "<p>Expose.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 258,
    "codeStart": 261,
    "code": "module.exports = ObjectId;\nmodule.exports.ObjectId = ObjectId;",
    "ctx": {
      "type": "property",
      "receiver": "module",
      "name": "exports",
      "value": "ObjectId",
      "string": "module.exports"
    }
  }
]
### lib/utils.js
[
  {
    "tags": [],
    "description": {
      "full": "<p>Module dependencies.</p>",
      "summary": "<p>Module dependencies.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 1,
    "codeStart": 5,
    "code": "var ObjectId = require('./types/objectid')\n  , mpath = require('./mpath')\n  , StorageArray\n  , Document;\n\nexports.mpath = mpath;",
    "ctx": {
      "type": "declaration",
      "name": "ObjectId",
      "value": "require('./types/objectid')",
      "string": "ObjectId"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Pluralization rules.</p><p>These rules are applied while processing the argument to <code>pluralize</code>.</p>",
      "summary": "<p>Pluralization rules.</p>",
      "body": "<p>These rules are applied while processing the argument to <code>pluralize</code>.</p>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 12,
    "codeStart": 18,
    "code": "exports.pluralization = [\n  [/(m)an$/gi, '$1en'],\n  [/(pe)rson$/gi, '$1ople'],\n  [/(child)$/gi, '$1ren'],\n  [/^(ox)$/gi, '$1en'],\n  [/(ax|test)is$/gi, '$1es'],\n  [/(octop|vir)us$/gi, '$1i'],\n  [/(alias|status)$/gi, '$1es'],\n  [/(bu)s$/gi, '$1ses'],\n  [/(buffal|tomat|potat)o$/gi, '$1oes'],\n  [/([ti])um$/gi, '$1a'],\n  [/sis$/gi, 'ses'],\n  [/(?:([^f])fe|([lr])f)$/gi, '$1$2ves'],\n  [/(hive)$/gi, '$1s'],\n  [/([^aeiouy]|qu)y$/gi, '$1ies'],\n  [/(x|ch|ss|sh)$/gi, '$1es'],\n  [/(matr|vert|ind)ix|ex$/gi, '$1ices'],\n  [/([m|l])ouse$/gi, '$1ice'],\n  [/(kn|w|l)ife$/gi, '$1ives'],\n  [/(quiz)$/gi, '$1zes'],\n  [/s$/gi, 's'],\n  [/([^a-z])$/, '$1'],\n  [/$/gi, 's']\n];\nvar rules = exports.pluralization;",
    "ctx": {
      "type": "property",
      "receiver": "exports",
      "name": "pluralization",
      "value": "[",
      "string": "exports.pluralization"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Uncountable words.</p><p>These words are applied while processing the argument to <code>pluralize</code>.</p>",
      "summary": "<p>Uncountable words.</p>",
      "body": "<p>These words are applied while processing the argument to <code>pluralize</code>.</p>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 44,
    "codeStart": 50,
    "code": "exports.uncountables = [\n  'advice',\n  'energy',\n  'excretion',\n  'digestion',\n  'cooperation',\n  'health',\n  'justice',\n  'labour',\n  'machinery',\n  'equipment',\n  'information',\n  'pollution',\n  'sewage',\n  'paper',\n  'money',\n  'species',\n  'series',\n  'rain',\n  'rice',\n  'fish',\n  'sheep',\n  'moose',\n  'deer',\n  'news',\n  'expertise',\n  'status',\n  'media'\n];\nvar uncountables = exports.uncountables;",
    "ctx": {
      "type": "property",
      "receiver": "exports",
      "name": "uncountables",
      "value": "[",
      "string": "exports.uncountables"
    }
  },
  {
    "tags": [
      {
        "type": "author",
        "string": "TJ Holowaychuk (extracted from _ext.js_)"
      },
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "string",
        "description": "to pluralize",
        "optional": false
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Pluralize function.</p>",
      "summary": "<p>Pluralize function.</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": true,
    "line": 81,
    "codeStart": 89,
    "code": "exports.pluralize = function (str) {\n  var found;\n  if (!~uncountables.indexOf(str.toLowerCase())){\n    found = rules.filter(function(rule){\n      return str.match(rule[0]);\n    });\n    if (found[0]) return str.replace(found[0][0], found[0][1]);\n  }\n  return str;\n};",
    "ctx": {
      "type": "method",
      "receiver": "exports",
      "name": "pluralize",
      "string": "exports.pluralize()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "*"
        ],
        "name": "a",
        "description": "a value to compare to `b`",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "*"
        ],
        "name": "b",
        "description": "a value to compare to `a`",
        "optional": false
      },
      {
        "type": "return",
        "types": [
          "Boolean"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Determines if <code>a</code> and <code>b</code> are deep equal.</p><p>Modified from node/lib/assert.js<br />Modified from mongoose/utils.js</p>",
      "summary": "<p>Determines if <code>a</code> and <code>b</code> are deep equal.</p>",
      "body": "<p>Modified from node/lib/assert.js<br />Modified from mongoose/utils.js</p>"
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": true,
    "line": 100,
    "codeStart": 111,
    "code": "exports.deepEqual = function deepEqual (a, b) {\n  if (isStorageObject(a)) a = a.toObject();\n  if (isStorageObject(b)) b = b.toObject();\n\n  return _.isEqual(a, b);\n};\n\n\n\nvar toString = Object.prototype.toString;\n\nfunction isRegExp (o) {\n  return 'object' == typeof o\n      && '[object RegExp]' == toString.call(o);\n}\n\nfunction cloneRegExp (regexp) {\n  if (!isRegExp(regexp)) {\n    throw new TypeError('Not a RegExp');\n  }\n\n  var flags = [];\n  if (regexp.global) flags.push('g');\n  if (regexp.multiline) flags.push('m');\n  if (regexp.ignoreCase) flags.push('i');\n  return new RegExp(regexp.source, flags.join(''));\n}",
    "ctx": {
      "type": "method",
      "receiver": "exports",
      "name": "deepEqual",
      "string": "exports.deepEqual()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "obj",
        "description": "the object to clone",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "options",
        "description": "",
        "optional": false
      },
      {
        "type": "return",
        "types": [
          "Object"
        ],
        "description": "the cloned object"
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Object clone with Storage natives support.</p><p>If options.minimize is true, creates a minimal data object. Empty objects and undefined values will not be cloned. This makes the data payload sent to MongoDB as small as possible.</p><p>Functions are never cloned.</p>",
      "summary": "<p>Object clone with Storage natives support.</p>",
      "body": "<p>If options.minimize is true, creates a minimal data object. Empty objects and undefined values will not be cloned. This makes the data payload sent to MongoDB as small as possible.</p><p>Functions are never cloned.</p>"
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": true,
    "line": 139,
    "codeStart": 151,
    "code": "exports.clone = function clone (obj, options) {\n  if (obj === undefined || obj === null)\n    return obj;\n\n  if ( _.isArray( obj ) ) {\n    return cloneArray( obj, options );\n  }\n\n  if ( isStorageObject( obj ) ) {\n    if (options && options.json && 'function' === typeof obj.toJSON) {\n      return obj.toJSON( options );\n    } else {\n      return obj.toObject( options );\n    }\n  }\n\n  if ( obj.constructor ) {\n    switch ( getFunctionName( obj.constructor )) {\n      case 'Object':\n        return cloneObject(obj, options);\n      case 'Date':\n        return new obj.constructor( +obj );\n      case 'RegExp':\n        return cloneRegExp( obj );\n      default:\n        // ignore\n        break;\n    }\n  }\n\n  if ( obj instanceof ObjectId ) {\n    return new ObjectId( obj.id );\n  }\n\n  if ( !obj.constructor && _.isObject( obj ) ) {\n    // object created with Object.create(null)\n    return cloneObject( obj, options );\n  }\n\n  if ( obj.valueOf ){\n    return obj.valueOf();\n  }\n};\nvar clone = exports.clone;",
    "ctx": {
      "type": "method",
      "receiver": "exports",
      "name": "clone",
      "string": "exports.clone()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>ignore</p>",
      "summary": "<p>ignore</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 196,
    "codeStart": 199,
    "code": "function cloneObject (obj, options) {\n  var retainKeyOrder = options && options.retainKeyOrder\n    , minimize = options && options.minimize\n    , ret = {}\n    , hasKeys\n    , keys\n    , val\n    , k\n    , i;\n\n  if ( retainKeyOrder ) {\n    for (k in obj) {\n      val = clone( obj[k], options );\n\n      if ( !minimize || ('undefined' !== typeof val) ) {\n        hasKeys || (hasKeys = true);\n        ret[k] = val;\n      }\n    }\n  } else {\n    // faster\n\n    keys = Object.keys( obj );\n    i = keys.length;\n\n    while (i--) {\n      k = keys[i];\n      val = clone(obj[k], options);\n\n      if (!minimize || ('undefined' !== typeof val)) {\n        if (!hasKeys) hasKeys = true;\n        ret[k] = val;\n      }\n    }\n  }\n\n  return minimize\n    ? hasKeys && ret\n    : ret;\n}\n\nfunction cloneArray (arr, options) {\n  var ret = [];\n  for (var i = 0, l = arr.length; i < l; i++) {\n    ret.push( clone( arr[i], options ) );\n  }\n  return ret;\n}",
    "ctx": {
      "type": "function",
      "name": "cloneObject",
      "string": "cloneObject()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "to",
        "description": "",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "from",
        "description": "",
        "optional": false
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Merges <code>from</code> into <code>to</code> without overwriting existing properties.</p>",
      "summary": "<p>Merges <code>from</code> into <code>to</code> without overwriting existing properties.</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": true,
    "line": 248,
    "codeStart": 255,
    "code": "exports.merge = function merge (to, from) {\n  var keys = Object.keys(from)\n    , i = keys.length\n    , key;\n\n  while (i--) {\n    key = keys[i];\n    if ('undefined' === typeof to[key]) {\n      to[key] = from[key];\n    } else if ( _.isObject(from[key]) ) {\n      merge(to[key], from[key]);\n    }\n  }\n};",
    "ctx": {
      "type": "method",
      "receiver": "exports",
      "name": "merge",
      "string": "exports.merge()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Generates a random string</p>",
      "summary": "<p>Generates a random string</p>",
      "body": ""
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": true,
    "line": 270,
    "codeStart": 276,
    "code": "exports.random = function () {\n  return Math.random().toString().substr(3);\n};",
    "ctx": {
      "type": "method",
      "receiver": "exports",
      "name": "random",
      "string": "exports.random()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "*"
        ],
        "name": "v",
        "description": "",
        "optional": false
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Returns if <code>v</code> is a storage object that has a <code>toObject()</code> method we can use.</p><p>This is for compatibility with libs like Date.js which do foolish things to Natives.</p>",
      "summary": "<p>Returns if <code>v</code> is a storage object that has a <code>toObject()</code> method we can use.</p>",
      "body": "<p>This is for compatibility with libs like Date.js which do foolish things to Natives.</p>"
    },
    "isPrivate": true,
    "isConstructor": false,
    "ignore": true,
    "line": 281,
    "codeStart": 289,
    "code": "exports.isStorageObject = function ( v ) {\n  Document || (Document = require('./document'));\n  //StorageArray || (StorageArray = require('./types/array'));\n\n  return v instanceof Document ||\n       ( v && v.isStorageArray );\n};\nvar isStorageObject = exports.isStorageObject;",
    "ctx": {
      "type": "method",
      "receiver": "exports",
      "name": "isStorageObject",
      "string": "exports.isStorageObject()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "path",
        "description": "",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "obj",
        "description": "",
        "optional": false
      }
    ],
    "description": {
      "full": "<p>Return the value of <code>obj</code> at the given <code>path</code>.</p>",
      "summary": "<p>Return the value of <code>obj</code> at the given <code>path</code>.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 298,
    "codeStart": 305,
    "code": "exports.getValue = function (path, obj, map) {\n  return mpath.get(path, obj, '_doc', map);\n};",
    "ctx": {
      "type": "method",
      "receiver": "exports",
      "name": "getValue",
      "string": "exports.getValue()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "path",
        "description": "",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "Anything"
        ],
        "name": "val",
        "description": "",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "obj",
        "description": "",
        "optional": false
      }
    ],
    "description": {
      "full": "<p>Sets the value of <code>obj</code> at the given <code>path</code>.</p>",
      "summary": "<p>Sets the value of <code>obj</code> at the given <code>path</code>.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 309,
    "codeStart": 317,
    "code": "exports.setValue = function (path, val, obj, map) {\n  mpath.set(path, val, obj, '_doc', map);\n};\n\nvar rFunctionName = /^function\\s*([^\\s(]+)/;\n\nfunction getFunctionName( ctor ){\n  if (ctor.name) {\n    return ctor.name;\n  }\n  return (ctor.toString().trim().match( rFunctionName ) || [])[1];\n}\n\nexports.getFunctionName = getFunctionName;\n\nexports.setImmediate = (function() {\n  // Для поддержки тестов (окружение node.js)\n  if ( typeof global === 'object' && process.nextTick ) return process.nextTick;\n  // Если в браузере уже реализован этот метод\n  if ( window.setImmediate ) return window.setImmediate;\n\n  var head = { }, tail = head; // очередь вызовов, 1-связный список\n\n  var ID = Math.random(); // уникальный идентификатор\n\n  function onmessage(e) {\n    if(e.data != ID) return; // не наше сообщение\n    head = head.next;\n    var func = head.func;\n    delete head.func;\n    func();\n  }\n\n  if(window.addEventListener) { // IE9+, другие браузеры\n    window.addEventListener('message', onmessage, false);\n  } else { // IE8\n    window.attachEvent( 'onmessage', onmessage );\n  }\n\n  return window.postMessage ? function(func) {\n    tail = tail.next = { func: func };\n    window.postMessage(ID, \"*\");\n  } :\n  function(func) { // IE<8\n    setTimeout(func, 0);\n  };\n}());",
    "ctx": {
      "type": "method",
      "receiver": "exports",
      "name": "setValue",
      "string": "exports.setValue()"
    }
  }
]
### lib/virtualtype.js
[
  {
    "tags": [
      {
        "type": "parma",
        "string": "{Object} options"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>VirtualType constructor</p><p>This is what mongoose uses to define virtual attributes via <code>Schema.prototype.virtual</code>.</p><h4>Example:</h4>\n<pre><code>var fullname = schema.virtual(&#39;fullname&#39;);\nfullname instanceof mongoose.VirtualType // true\n</code></pre>",
      "summary": "<p>VirtualType constructor</p>",
      "body": "<p>This is what mongoose uses to define virtual attributes via <code>Schema.prototype.virtual</code>.</p><h4>Example:</h4>\n<pre><code>var fullname = schema.virtual(&#39;fullname&#39;);\nfullname instanceof mongoose.VirtualType // true\n</code></pre>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 2,
    "codeStart": 16,
    "code": "function VirtualType (options, name) {\n  this.path = name;\n  this.getters = [];\n  this.setters = [];\n  this.options = options || {};\n}",
    "ctx": {
      "type": "function",
      "name": "VirtualType",
      "string": "VirtualType()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "fn",
        "description": "",
        "optional": false
      },
      {
        "type": "return",
        "types": [
          "VirtualType"
        ],
        "description": "this"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Defines a getter.</p><h4>Example:</h4>\n<pre><code>var virtual = schema.virtual(&#39;fullname&#39;);\nvirtual.get(function () {\n  return this.name.first + &#39; &#39; + this.name.last;\n});\n</code></pre>",
      "summary": "<p>Defines a getter.</p>",
      "body": "<h4>Example:</h4>\n<pre><code>var virtual = schema.virtual(&#39;fullname&#39;);\nvirtual.get(function () {\n  return this.name.first + &#39; &#39; + this.name.last;\n});\n</code></pre>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 23,
    "codeStart": 38,
    "code": "VirtualType.prototype.get = function (fn) {\n  this.getters.push(fn);\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "VirtualType",
      "cons": "VirtualType",
      "name": "get",
      "string": "VirtualType.prototype.get()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "fn",
        "description": "",
        "optional": false
      },
      {
        "type": "return",
        "types": [
          "VirtualType"
        ],
        "description": "this"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Defines a setter.</p><h4>Example:</h4>\n<pre><code>var virtual = schema.virtual(&#39;fullname&#39;);\nvirtual.set(function (v) {\n  var parts = v.split(&#39; &#39;);\n  this.name.first = parts[0];\n  this.name.last = parts[1];\n});\n</code></pre>",
      "summary": "<p>Defines a setter.</p>",
      "body": "<h4>Example:</h4>\n<pre><code>var virtual = schema.virtual(&#39;fullname&#39;);\nvirtual.set(function (v) {\n  var parts = v.split(&#39; &#39;);\n  this.name.first = parts[0];\n  this.name.last = parts[1];\n});\n</code></pre>"
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 43,
    "codeStart": 60,
    "code": "VirtualType.prototype.set = function (fn) {\n  this.setters.push(fn);\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "VirtualType",
      "cons": "VirtualType",
      "name": "set",
      "string": "VirtualType.prototype.set()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "value",
        "description": "",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "scope",
        "description": "",
        "optional": false
      },
      {
        "type": "return",
        "types": [
          "*"
        ],
        "description": "the value after applying all getters"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Applies getters to <code>value</code> using optional <code>scope</code>.</p>",
      "summary": "<p>Applies getters to <code>value</code> using optional <code>scope</code>.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 65,
    "codeStart": 74,
    "code": "VirtualType.prototype.applyGetters = function (value, scope) {\n  var v = value;\n  for (var l = this.getters.length - 1; l >= 0; l--) {\n    v = this.getters[l].call(scope, v, this);\n  }\n  return v;\n};",
    "ctx": {
      "type": "method",
      "constructor": "VirtualType",
      "cons": "VirtualType",
      "name": "applyGetters",
      "string": "VirtualType.prototype.applyGetters()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "value",
        "description": "",
        "optional": false
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "scope",
        "description": "",
        "optional": false
      },
      {
        "type": "return",
        "types": [
          "*"
        ],
        "description": "the value after applying all setters"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Applies setters to <code>value</code> using optional <code>scope</code>.</p>",
      "summary": "<p>Applies setters to <code>value</code> using optional <code>scope</code>.</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": false,
    "line": 82,
    "codeStart": 91,
    "code": "VirtualType.prototype.applySetters = function (value, scope) {\n  var v = value;\n  for (var l = this.setters.length - 1; l >= 0; l--) {\n    v = this.setters[l].call(scope, v, this);\n  }\n  return v;\n};",
    "ctx": {
      "type": "method",
      "constructor": "VirtualType",
      "cons": "VirtualType",
      "name": "applySetters",
      "string": "VirtualType.prototype.applySetters()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>exports</p>",
      "summary": "<p>exports</p>",
      "body": ""
    },
    "isPrivate": false,
    "isConstructor": false,
    "ignore": true,
    "line": 99,
    "codeStart": 103,
    "code": "module.exports = VirtualType;",
    "ctx": {
      "type": "property",
      "receiver": "module",
      "name": "exports",
      "value": "VirtualType",
      "string": "module.exports"
    }
  }
]