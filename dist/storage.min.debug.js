!function(root,factory){"object"==typeof exports&&"object"==typeof module?module.exports=factory():"function"==typeof define&&define.amd?define(factory):"object"==typeof exports?exports.storage=factory():root.storage=factory()}(this,function(){return function(modules){function __webpack_require__(moduleId){if(installedModules[moduleId])return installedModules[moduleId].exports;var module=installedModules[moduleId]={exports:{},id:moduleId,loaded:!1};return modules[moduleId].call(module.exports,module,module.exports,__webpack_require__),module.loaded=!0,module.exports}var installedModules={};return __webpack_require__.m=modules,__webpack_require__.c=installedModules,__webpack_require__.p="",__webpack_require__(0)}([/*!**********************!*\
  !*** ./lib/index.js ***!
  \**********************/
function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';\n\n/*!\n * Storage documents using schema\n * inspired by mongoose 3.8.4 (fixed bugs for 3.8.27 and 3.9.5)\n *\n * Storage implementation\n * http://docs.meteor.com/#selectors\n * https://github.com/meteor/meteor/tree/master/packages/minimongo\n *\n * to track the bug gh-1638 (3.8.16)\n */\n\n/*!\n * Module dependencies.\n */\nvar Collection = __webpack_require__(/*! ./collection */ 5)\n  , Schema = __webpack_require__(/*! ./schema */ 6)\n  , SchemaType = __webpack_require__(/*! ./schematype */ 22)\n  , VirtualType = __webpack_require__(/*! ./virtualtype */ 8)\n  , Types = __webpack_require__(/*! ./types */ 38)\n  , Document = __webpack_require__(/*! ./document */ 14)\n  , utils = __webpack_require__(/*! ./utils */ 9)\n  , pkg = __webpack_require__(/*! json!../package.json */ 41);\n\n\n/**\n * Storage constructor.\n *\n * The exports object of the `storage` module is an instance of this class.\n * Most apps will only use this one instance.\n *\n * @api public\n */\nfunction Storage () {\n  this.collectionNames = [];\n}\n\n/**\n * Create a collection and get it\n *\n * @example\n *\n * @param {string} name - collection name\n * @param {storage.Schema|undefined} schema\n * @param {Object} [api] - reference to the Api-client resource instance\n * @returns {Collection|TypeError}\n * @api public\n */\nStorage.prototype.createCollection = function( name, schema, api ){\n  if ( this[ name ] ){\n    console.info('storage::collection: `' + name + '` already exist');\n    return this[ name ];\n  }\n\n  if ( name == null ){\n    throw new TypeError('storage.createCollection( name, schema ) - `name` must be exist, `schema` must be Schema instance');\n  }\n\n  if ( schema == null || 'Schema' !== utils.getFunctionName( schema.constructor ) ){\n    throw new TypeError('storage.createCollection( name, schema ) - `schema` must be Schema instance');\n  }\n\n  this.collectionNames.push( name );\n\n  this[ name ] = new Collection( name, schema, api );\n\n  return this[ name ];\n};\n\n/**\n * Alias for createCollection\n *\n * @see Storage.createCollection #index_Storage-createCollection\n * @method createCollection\n * @api public\n */\nStorage.prototype.addCollection = Storage.prototype.createCollection;\n\n/**\n * To obtain the names of the collections in an array\n *\n * @returns {Array.<string>} An array containing all collections in the storage.\n */\nStorage.prototype.getCollectionNames = function(){\n  return this.collectionNames;\n};\n\n/**\n * The Storage Collection constructor\n *\n * @method Collection\n * @api public\n */\nStorage.prototype.Collection = Collection;\n\n/**\n * The Storage version\n *\n * @property version\n * @api public\n */\nStorage.prototype.version = pkg.version;\n\n/**\n * The Storage constructor\n *\n * The exports of the storage module is an instance of this class.\n *\n * ####Example:\n *\n *     var storage2 = new storage.Storage();\n *\n * @method Storage\n * @api public\n */\nStorage.prototype.Storage = Storage;\n\n/**\n * The Storage [Schema](#schema_Schema) constructor\n *\n * ####Example:\n *\n *     var Schema = storage.Schema;\n *     var CatSchema = new Schema(..);\n *\n * @method Schema\n * @api public\n */\nStorage.prototype.Schema = Schema;\n\n/**\n * The Storage [SchemaType](#schematype_SchemaType) constructor\n *\n * @method SchemaType\n * @api public\n */\nStorage.prototype.SchemaType = SchemaType;\n\n/**\n * The various Storage SchemaTypes.\n *\n * ####Note:\n *\n * _Alias of storage.Schema.Types for backwards compatibility._\n *\n * @property SchemaTypes\n * @see Schema.SchemaTypes #schema_Schema.Types\n * @api public\n */\nStorage.prototype.SchemaTypes = Schema.Types;\n\n/**\n * The Storage [VirtualType](#virtualtype_VirtualType) constructor\n *\n * @method VirtualType\n * @api public\n */\nStorage.prototype.VirtualType = VirtualType;\n\n/**\n * The various Storage Types.\n *\n * ####Example:\n *\n *     var array = storage.Types.Array;\n *\n * ####Types:\n *\n * - [ObjectId](#types-objectid-js)\n * - [Buffer](#types-buffer-js)\n * - [SubDocument](#types-embedded-js)\n * - [Array](#types-array-js)\n * - [DocumentArray](#types-documentarray-js)\n *\n * Using this exposed access to the `ObjectId` type, we can construct ids on demand.\n *\n *     var ObjectId = storage.Types.ObjectId;\n *     var id1 = new ObjectId;\n *\n * @property Types\n * @api public\n */\nStorage.prototype.Types = Types;\n\n/**\n * The Storage [Document](#document-js) constructor.\n *\n * @method Document\n * @api public\n */\nStorage.prototype.Document = Document;\n\n/**\n * The [StorageError](#error_StorageError) constructor.\n *\n * @method Error\n * @api public\n */\nStorage.prototype.Error = __webpack_require__(/*! ./error */ 15);\n\n\nStorage.prototype.Deferred = __webpack_require__(/*! ./deferred */ 23);\nStorage.prototype.events = __webpack_require__(/*! ./events */ 7);\nStorage.prototype.StateMachine = __webpack_require__(/*! ./statemachine */ 25);\nStorage.prototype.utils = utils;\nStorage.prototype.ObjectId = Types.ObjectId;\nStorage.prototype.schemas = Schema.schemas;\n\nStorage.prototype.setAdapter = function( adapterHooks ){\n  Document.prototype.adapterHooks = adapterHooks;\n};\n\n\n/*!\n * The exports object is an instance of Storage.\n *\n * @api public\n */\nmodule.exports = new Storage();\n\nwindow.Buffer = Buffer;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/node-libs-browser/~/buffer/index.js */ 1).Buffer))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/index.js\n ** module id = 0\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./lib/index.js?")},/*!***********************************************!*\
  !*** ./~/node-libs-browser/~/buffer/index.js ***!
  \***********************************************/
function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(Buffer) {/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n\nvar base64 = __webpack_require__(/*! base64-js */ 2)\nvar ieee754 = __webpack_require__(/*! ieee754 */ 3)\nvar isArray = __webpack_require__(/*! is-array */ 4)\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\nBuffer.poolSize = 8192 // not used by this implementation\n\nvar rootParent = {}\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Note:\n *\n * - Implementation must support adding new properties to `Uint8Array` instances.\n *   Firefox 4-29 lacked support, fixed in Firefox 30+.\n *   See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *  - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *  - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *    incorrect length in some situations.\n *\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they will\n * get the Object implementation, which is slower but will work correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = (function () {\n  try {\n    var buf = new ArrayBuffer(0)\n    var arr = new Uint8Array(buf)\n    arr.foo = function () { return 42 }\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        new Uint8Array(1).subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n})()\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\n/**\n * Class: Buffer\n * =============\n *\n * The Buffer constructor returns instances of `Uint8Array` that are augmented\n * with function properties for all the node `Buffer` API functions. We use\n * `Uint8Array` so that square bracket notation works as expected -- it returns\n * a single octet.\n *\n * By augmenting the instances, we can avoid modifying the `Uint8Array`\n * prototype.\n */\nfunction Buffer (arg) {\n  if (!(this instanceof Buffer)) {\n    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.\n    if (arguments.length > 1) return new Buffer(arg, arguments[1])\n    return new Buffer(arg)\n  }\n\n  this.length = 0\n  this.parent = undefined\n\n  // Common case.\n  if (typeof arg === 'number') {\n    return fromNumber(this, arg)\n  }\n\n  // Slightly less common case.\n  if (typeof arg === 'string') {\n    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')\n  }\n\n  // Unusual.\n  return fromObject(this, arg)\n}\n\nfunction fromNumber (that, length) {\n  that = allocate(that, length < 0 ? 0 : checked(length) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < length; i++) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'\n\n  // Assumption: byteLength() return value is always < kMaxLength.\n  var length = byteLength(string, encoding) | 0\n  that = allocate(that, length)\n\n  that.write(string, encoding)\n  return that\n}\n\nfunction fromObject (that, object) {\n  if (Buffer.isBuffer(object)) return fromBuffer(that, object)\n\n  if (isArray(object)) return fromArray(that, object)\n\n  if (object == null) {\n    throw new TypeError('must start with number, buffer, array or string')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && object.buffer instanceof ArrayBuffer) {\n    return fromTypedArray(that, object)\n  }\n\n  if (object.length) return fromArrayLike(that, object)\n\n  return fromJsonObject(that, object)\n}\n\nfunction fromBuffer (that, buffer) {\n  var length = checked(buffer.length) | 0\n  that = allocate(that, length)\n  buffer.copy(that, 0, 0, length)\n  return that\n}\n\nfunction fromArray (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\n// Duplicate of fromArray() to keep fromArray() monomorphic.\nfunction fromTypedArray (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  // Truncating the elements is probably not what people expect from typed\n  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior\n  // of the old Buffer constructor.\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\n// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.\n// Returns a zero-length buffer for inputs that don't conform to the spec.\nfunction fromJsonObject (that, object) {\n  var array\n  var length = 0\n\n  if (object.type === 'Buffer' && isArray(object.data)) {\n    array = object.data\n    length = checked(array.length) | 0\n  }\n  that = allocate(that, length)\n\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction allocate (that, length) {\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = Buffer._augment(new Uint8Array(length))\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that.length = length\n    that._isBuffer = true\n  }\n\n  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1\n  if (fromPool) that.parent = rootParent\n\n  return that\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (subject, encoding) {\n  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)\n\n  var buf = new Buffer(subject, encoding)\n  delete buf.parent\n  return buf\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  var i = 0\n  var len = Math.min(x, y)\n  while (i < len) {\n    if (a[i] !== b[i]) break\n\n    ++i\n  }\n\n  if (i !== len) {\n    x = a[i]\n    y = b[i]\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'binary':\n    case 'base64':\n    case 'raw':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')\n\n  if (list.length === 0) {\n    return new Buffer(0)\n  } else if (list.length === 1) {\n    return list[0]\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; i++) {\n      length += list[i].length\n    }\n  }\n\n  var buf = new Buffer(length)\n  var pos = 0\n  for (i = 0; i < list.length; i++) {\n    var item = list[i]\n    item.copy(buf, pos)\n    pos += item.length\n  }\n  return buf\n}\n\nfunction byteLength (string, encoding) {\n  if (typeof string !== 'string') string = '' + string\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'binary':\n      // Deprecated\n      case 'raw':\n      case 'raws':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\n// pre-set for values that may exist in the future\nBuffer.prototype.length = undefined\nBuffer.prototype.parent = undefined\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  start = start | 0\n  end = end === undefined || end === Infinity ? this.length : end | 0\n\n  if (!encoding) encoding = 'utf8'\n  if (start < 0) start = 0\n  if (end > this.length) end = this.length\n  if (end <= start) return ''\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'binary':\n        return binarySlice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return 0\n  return Buffer.compare(this, b)\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset) {\n  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff\n  else if (byteOffset < -0x80000000) byteOffset = -0x80000000\n  byteOffset >>= 0\n\n  if (this.length === 0) return -1\n  if (byteOffset >= this.length) return -1\n\n  // Negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)\n\n  if (typeof val === 'string') {\n    if (val.length === 0) return -1 // special case: looking for empty string always fails\n    return String.prototype.indexOf.call(this, val, byteOffset)\n  }\n  if (Buffer.isBuffer(val)) {\n    return arrayIndexOf(this, val, byteOffset)\n  }\n  if (typeof val === 'number') {\n    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {\n      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)\n    }\n    return arrayIndexOf(this, [ val ], byteOffset)\n  }\n\n  function arrayIndexOf (arr, val, byteOffset) {\n    var foundIndex = -1\n    for (var i = 0; byteOffset + i < arr.length; i++) {\n      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex\n      } else {\n        foundIndex = -1\n      }\n    }\n    return -1\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\n// `get` will be removed in Node 0.13+\nBuffer.prototype.get = function get (offset) {\n  console.log('.get() is deprecated. Access using array indexes instead.')\n  return this.readUInt8(offset)\n}\n\n// `set` will be removed in Node 0.13+\nBuffer.prototype.set = function set (v, offset) {\n  console.log('.set() is deprecated. Access using array indexes instead.')\n  return this.writeUInt8(v, offset)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new Error('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; i++) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) throw new Error('Invalid hex string')\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction binaryWrite (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    var swap = encoding\n    encoding = offset\n    offset = length | 0\n    length = swap\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'binary':\n        return binaryWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  var res = ''\n  var tmp = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++) {\n    if (buf[i] <= 0x7F) {\n      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])\n      tmp = ''\n    } else {\n      tmp += '%' + buf[i].toString(16)\n    }\n  }\n\n  return res + decodeUtf8Char(tmp)\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction binarySlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; i++) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = Buffer._augment(this.subarray(start, end))\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; i++) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  if (newBuf.length) newBuf.parent = this.parent || this\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('value is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = value\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = value\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = value\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = value\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = value < 0 ? 1 : 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = value < 0 ? 1 : 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = value\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = value\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = value\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (value > max || value < min) throw new RangeError('value is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('index out of range')\n  if (offset < 0) throw new RangeError('index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n\n  if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < len; i++) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    target._set(this.subarray(start, start + len), targetStart)\n  }\n\n  return len\n}\n\n// fill(value, start=0, end=buffer.length)\nBuffer.prototype.fill = function fill (value, start, end) {\n  if (!value) value = 0\n  if (!start) start = 0\n  if (!end) end = this.length\n\n  if (end < start) throw new RangeError('end < start')\n\n  // Fill 0 bytes; we're done\n  if (end === start) return\n  if (this.length === 0) return\n\n  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')\n  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')\n\n  var i\n  if (typeof value === 'number') {\n    for (i = start; i < end; i++) {\n      this[i] = value\n    }\n  } else {\n    var bytes = utf8ToBytes(value.toString())\n    var len = bytes.length\n    for (i = start; i < end; i++) {\n      this[i] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n/**\n * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.\n * Added in Node 0.12. Only available in browsers that support ArrayBuffer.\n */\nBuffer.prototype.toArrayBuffer = function toArrayBuffer () {\n  if (typeof Uint8Array !== 'undefined') {\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n      return (new Buffer(this)).buffer\n    } else {\n      var buf = new Uint8Array(this.length)\n      for (var i = 0, len = buf.length; i < len; i += 1) {\n        buf[i] = this[i]\n      }\n      return buf.buffer\n    }\n  } else {\n    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')\n  }\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar BP = Buffer.prototype\n\n/**\n * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods\n */\nBuffer._augment = function _augment (arr) {\n  arr.constructor = Buffer\n  arr._isBuffer = true\n\n  // save reference to original Uint8Array set method before overwriting\n  arr._set = arr.set\n\n  // deprecated, will be removed in node 0.13+\n  arr.get = BP.get\n  arr.set = BP.set\n\n  arr.write = BP.write\n  arr.toString = BP.toString\n  arr.toLocaleString = BP.toString\n  arr.toJSON = BP.toJSON\n  arr.equals = BP.equals\n  arr.compare = BP.compare\n  arr.indexOf = BP.indexOf\n  arr.copy = BP.copy\n  arr.slice = BP.slice\n  arr.readUIntLE = BP.readUIntLE\n  arr.readUIntBE = BP.readUIntBE\n  arr.readUInt8 = BP.readUInt8\n  arr.readUInt16LE = BP.readUInt16LE\n  arr.readUInt16BE = BP.readUInt16BE\n  arr.readUInt32LE = BP.readUInt32LE\n  arr.readUInt32BE = BP.readUInt32BE\n  arr.readIntLE = BP.readIntLE\n  arr.readIntBE = BP.readIntBE\n  arr.readInt8 = BP.readInt8\n  arr.readInt16LE = BP.readInt16LE\n  arr.readInt16BE = BP.readInt16BE\n  arr.readInt32LE = BP.readInt32LE\n  arr.readInt32BE = BP.readInt32BE\n  arr.readFloatLE = BP.readFloatLE\n  arr.readFloatBE = BP.readFloatBE\n  arr.readDoubleLE = BP.readDoubleLE\n  arr.readDoubleBE = BP.readDoubleBE\n  arr.writeUInt8 = BP.writeUInt8\n  arr.writeUIntLE = BP.writeUIntLE\n  arr.writeUIntBE = BP.writeUIntBE\n  arr.writeUInt16LE = BP.writeUInt16LE\n  arr.writeUInt16BE = BP.writeUInt16BE\n  arr.writeUInt32LE = BP.writeUInt32LE\n  arr.writeUInt32BE = BP.writeUInt32BE\n  arr.writeIntLE = BP.writeIntLE\n  arr.writeIntBE = BP.writeIntBE\n  arr.writeInt8 = BP.writeInt8\n  arr.writeInt16LE = BP.writeInt16LE\n  arr.writeInt16BE = BP.writeInt16BE\n  arr.writeInt32LE = BP.writeInt32LE\n  arr.writeInt32BE = BP.writeInt32BE\n  arr.writeFloatLE = BP.writeFloatLE\n  arr.writeFloatBE = BP.writeFloatBE\n  arr.writeDoubleLE = BP.writeDoubleLE\n  arr.writeDoubleBE = BP.writeDoubleBE\n  arr.fill = BP.fill\n  arr.inspect = BP.inspect\n  arr.toArrayBuffer = BP.toArrayBuffer\n\n  return arr\n}\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-z\\-]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n  var i = 0\n\n  for (; i < length; i++) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (leadSurrogate) {\n        // 2 leads in a row\n        if (codePoint < 0xDC00) {\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          leadSurrogate = codePoint\n          continue\n        } else {\n          // valid surrogate pair\n          codePoint = leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00 | 0x10000\n          leadSurrogate = null\n        }\n      } else {\n        // no lead yet\n\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else {\n          // valid lead\n          leadSurrogate = codePoint\n          continue\n        }\n      }\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n      leadSurrogate = null\n    }\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x200000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; i++) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction decodeUtf8Char (str) {\n  try {\n    return decodeURIComponent(str)\n  } catch (err) {\n    return String.fromCharCode(0xFFFD) // UTF 8 invalid char\n  }\n}\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/node-libs-browser/~/buffer/index.js */ 1).Buffer))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/node-libs-browser/~/buffer/index.js\n ** module id = 1\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/node-libs-browser/~/buffer/index.js?");
},/*!*************************************************************!*\
  !*** ./~/node-libs-browser/~/buffer/~/base64-js/lib/b64.js ***!
  \*************************************************************/
function(module,exports,__webpack_require__){eval("var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n;(function (exports) {\n	'use strict';\n\n  var Arr = (typeof Uint8Array !== 'undefined')\n    ? Uint8Array\n    : Array\n\n	var PLUS   = '+'.charCodeAt(0)\n	var SLASH  = '/'.charCodeAt(0)\n	var NUMBER = '0'.charCodeAt(0)\n	var LOWER  = 'a'.charCodeAt(0)\n	var UPPER  = 'A'.charCodeAt(0)\n	var PLUS_URL_SAFE = '-'.charCodeAt(0)\n	var SLASH_URL_SAFE = '_'.charCodeAt(0)\n\n	function decode (elt) {\n		var code = elt.charCodeAt(0)\n		if (code === PLUS ||\n		    code === PLUS_URL_SAFE)\n			return 62 // '+'\n		if (code === SLASH ||\n		    code === SLASH_URL_SAFE)\n			return 63 // '/'\n		if (code < NUMBER)\n			return -1 //no match\n		if (code < NUMBER + 10)\n			return code - NUMBER + 26 + 26\n		if (code < UPPER + 26)\n			return code - UPPER\n		if (code < LOWER + 26)\n			return code - LOWER + 26\n	}\n\n	function b64ToByteArray (b64) {\n		var i, j, l, tmp, placeHolders, arr\n\n		if (b64.length % 4 > 0) {\n			throw new Error('Invalid string. Length must be a multiple of 4')\n		}\n\n		// the number of equal signs (place holders)\n		// if there are two placeholders, than the two characters before it\n		// represent one byte\n		// if there is only one, then the three characters before it represent 2 bytes\n		// this is just a cheap hack to not do indexOf twice\n		var len = b64.length\n		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0\n\n		// base64 is 4/3 + up to two characters of the original data\n		arr = new Arr(b64.length * 3 / 4 - placeHolders)\n\n		// if there are placeholders, only get up to the last complete 4 chars\n		l = placeHolders > 0 ? b64.length - 4 : b64.length\n\n		var L = 0\n\n		function push (v) {\n			arr[L++] = v\n		}\n\n		for (i = 0, j = 0; i < l; i += 4, j += 3) {\n			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))\n			push((tmp & 0xFF0000) >> 16)\n			push((tmp & 0xFF00) >> 8)\n			push(tmp & 0xFF)\n		}\n\n		if (placeHolders === 2) {\n			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)\n			push(tmp & 0xFF)\n		} else if (placeHolders === 1) {\n			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)\n			push((tmp >> 8) & 0xFF)\n			push(tmp & 0xFF)\n		}\n\n		return arr\n	}\n\n	function uint8ToBase64 (uint8) {\n		var i,\n			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\n			output = \"\",\n			temp, length\n\n		function encode (num) {\n			return lookup.charAt(num)\n		}\n\n		function tripletToBase64 (num) {\n			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)\n		}\n\n		// go through the array every three bytes, we'll deal with trailing stuff later\n		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n			output += tripletToBase64(temp)\n		}\n\n		// pad the end with zeros, but make sure to not forget the extra bytes\n		switch (extraBytes) {\n			case 1:\n				temp = uint8[uint8.length - 1]\n				output += encode(temp >> 2)\n				output += encode((temp << 4) & 0x3F)\n				output += '=='\n				break\n			case 2:\n				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])\n				output += encode(temp >> 10)\n				output += encode((temp >> 4) & 0x3F)\n				output += encode((temp << 2) & 0x3F)\n				output += '='\n				break\n		}\n\n		return output\n	}\n\n	exports.toByteArray = b64ToByteArray\n	exports.fromByteArray = uint8ToBase64\n}( false ? (this.base64js = {}) : exports))\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/node-libs-browser/~/buffer/~/base64-js/lib/b64.js\n ** module id = 2\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/node-libs-browser/~/buffer/~/base64-js/lib/b64.js?")},/*!*********************************************************!*\
  !*** ./~/node-libs-browser/~/buffer/~/ieee754/index.js ***!
  \*********************************************************/
function(module,exports){eval("exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/node-libs-browser/~/buffer/~/ieee754/index.js\n ** module id = 3\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/node-libs-browser/~/buffer/~/ieee754/index.js?")},/*!**********************************************************!*\
  !*** ./~/node-libs-browser/~/buffer/~/is-array/index.js ***!
  \**********************************************************/
function(module,exports){eval("\n/**\n * isArray\n */\n\nvar isArray = Array.isArray;\n\n/**\n * toString\n */\n\nvar str = Object.prototype.toString;\n\n/**\n * Whether or not the given `val`\n * is an array.\n *\n * example:\n *\n *        isArray([]);\n *        // > true\n *        isArray(arguments);\n *        // > false\n *        isArray('');\n *        // > false\n *\n * @param {mixed} val\n * @return {bool}\n */\n\nmodule.exports = isArray || function (val) {\n  return !! val && '[object Array]' == str.call(val);\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/node-libs-browser/~/buffer/~/is-array/index.js\n ** module id = 4\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/node-libs-browser/~/buffer/~/is-array/index.js?")},/*!***************************!*\
  !*** ./lib/collection.js ***!
  \***************************/
function(module,exports,__webpack_require__){eval("'use strict';\n\n/*!\n * Module dependencies.\n */\n\nvar Schema = __webpack_require__(/*! ./schema */ 6)\n  , Document = __webpack_require__(/*! ./document */ 14);\n\n//TODO: написать метод .upsert( doc ) - обновление документа, а если его нет, то создание\n\n//TODO: доделать логику с apiResource (сохранять ссылку на него и использовть при методе doc.save)\n/**\n * Collection constructor.\n *\n * @example\n *\n * @param {string} name - name collection\n * @param {Schema|object} schema - schema instance or schema settings object\n * @param {object} [api] - reference to the Api-client resource instance\n * @constructor\n */\nfunction Collection ( name, schema, api ){\n  // Сохраним название пространства имён\n  this.name = name;\n  // Хранилище для документов\n  this.documents = {};\n\n  if ( _.isObject( schema ) && !( schema instanceof Schema ) ) {\n    schema = new Schema( schema );\n  }\n\n  // Сохраним ссылку на api для метода .save()\n  this.api = api;\n\n  // Используемая схема для коллекции\n  this.schema = schema;\n\n  // Отображение поля documents в виде массива (для нокаута)\n  this.array = [];\n  // todo: перенести в адаптер или сделать по другому (object.observe)\n  // Нужно для обновления привязок к этому свойству для knockoutjs\n  window.ko && ko.track( this, ['array'] );\n}\n\nCollection.prototype = {\n  /**\n   * To add document or array of documents.\n   *\n   * @example\n   * storage.collection.add({ type: 'jelly bean' });\n   * storage.collection.add([{ type: 'jelly bean' }, { type: 'snickers' }]);\n   * storage.collection.add({ _id: '*****', type: 'jelly bean' }, true);\n   *\n   * @param {object|Array.<object>} [doc] - doc object or array of doc objects\n   * @param {object} [fields] - selected fields in the query from the server (not implemented in Document)\n   * @param {boolean} [init] - hydrate document - наполнить документ данными (используется в api-client)\n   * @param {boolean} [_storageWillMutate] - Флаг добавления массива документов. только для внутреннего использования\n   * @returns {storage.Document|Array.<storage.Document>}\n   */\n  add: function( doc, fields, init, _storageWillMutate ){\n    var self = this;\n\n    // Если документа нет, значит будет пустой\n    if ( doc == null ) doc = null;\n\n    // Массив документов\n    if ( _.isArray( doc ) ){\n      var savedDocs = [];\n\n      _.each( doc, function( doc ){\n        savedDocs.push( self.add( doc, fields, init, true ) );\n      });\n\n      this.storageHasMutated();\n\n      return savedDocs;\n    }\n\n    var id = doc && doc._id;\n\n    // Если документ уже есть, то просто установить значения\n    if ( id && this.documents[ id ] ){\n      this.documents[ id ].set( doc );\n\n    } else {\n      var discriminatorMapping = this.schema\n        ? this.schema.discriminatorMapping\n        : null;\n\n      var key = discriminatorMapping && discriminatorMapping.isRoot\n        ? discriminatorMapping.key\n        : null;\n\n      // Выбираем схему, если есть дискриминатор\n      var schema;\n      if (key && doc && doc[key] && this.schema.discriminators && this.schema.discriminators[doc[key]]) {\n        schema = this.schema.discriminators[doc[key]];\n\n      } else {\n        schema = this.schema;\n      }\n\n      var newDoc = new Document( doc, this.name, schema, fields, init );\n      //todo: тут нужна проверка на существование id (может стоит смотреть в схеме опцию id)\n      /*!\n      if ( !newDoc._id ){\n        throw new TypeError('Для помещения в коллекцию необходимо, чтобы у документа был _id');\n      }\n      */\n\n      id = newDoc._id.toString();\n      // Поместить документ в коллекцию\n      this.documents[ id ] = newDoc;\n    }\n\n    // Для одиночных документов тоже нужно  вызвать storageHasMutated\n    if ( !_storageWillMutate ){\n      this.storageHasMutated();\n    }\n\n    return this.documents[ id ];\n  },\n\n  /**\n   * Remove document.\n   *\n   * @example\n   * storage.collection.remove( Document );\n   * storage.collection.remove( uuid );\n   *\n   * @param {object|number} document - Сам документ или его id.\n   * @returns {boolean}\n   */\n  remove: function( document ){\n    return delete this.documents[ document._id || document ];\n  },\n\n  /**\n   * Find documents by conditions.\n   *\n   * @example\n   * // named john\n   * storage.collection.find({ name: 'john' });\n   * storage.collection.find({ author: 'Shakespeare', year: 1611 });\n   *\n   * @param conditions\n   * @returns {Array.<storage.Document>}\n   */\n  find: function( conditions ){\n    return _.where( this.documents, conditions );\n  },\n\n  /**\n   * Find document by id.\n   *\n   * @example\n   * storage.collection.findById( id );\n   *\n   * @param _id\n   * @returns {storage.Document|undefined}\n   */\n  findById: function( _id ){\n    return this.documents[ _id ];\n  },\n\n  /**\n   * Find document by id and remove it.\n   *\n   * @example\n   * storage.collection.findByIdAndRemove( id ) // returns сollection\n   *\n   * @see Collection.findById\n   * @see Collection.remove\n   *\n   * @param _id\n   * @returns {Collection}\n   */\n  findByIdAndRemove: function( _id ){\n    this.remove( this.findById( _id ) );\n    return this;\n  },\n\n  /**\n   * Find document by id and update the path value in it.\n   *\n   * @see Collection.findById\n   * @see Collection.update\n   *\n   * @param _id\n   * @param {string|object} path\n   * @param {object|boolean|number|string|null|undefined} value\n   * @returns {storage.Document|undefined}\n   */\n  findByIdAndUpdate: function( _id, path, value ){\n    return this.update( this.findById( _id ), path, value );\n  },\n\n  /**\n   * Find one document by conditions.\n   *\n   * @example\n   * // find one iphone adventures\n   * storage.adventure.findOne({ type: 'iphone' });\n   *\n   * @param conditions\n   * @returns {storage.Document|undefined}\n   */\n  findOne: function( conditions ){\n    return _.findWhere( this.documents, conditions );\n  },\n\n  /**\n   * Find one document by conditions and remove it.\n   *\n   * @example\n   * storage.collection.findOneAndRemove( conditions ) // returns сollection\n   *\n   * @see Collection.findOne\n   * @see Collection.remove\n   *\n   * @param {object} conditions\n   * @returns {Collection}\n   */\n  findOneAndRemove: function( conditions ){\n    this.remove( this.findOne( conditions ) );\n    return this;\n  },\n\n  /**\n   * Find one document by conditions and update the path value in it.\n   *\n   * @see Collection.findOne\n   * @see Collection.update\n   *\n   * @param {object} conditions\n   * @param {string|object} path\n   * @param {object|boolean|number|string|null|undefined} value\n   * @returns {storage.Document|undefined}\n   */\n  findOneAndUpdate: function( conditions, path, value ){\n    return this.update( this.findOne( conditions ), path, value );\n  },\n\n  /**\n   * Update the path value in the document.\n   *\n   * @example\n   * storage.places.update( storage.places.findById( 0 ), {\n   *   name: 'Irkutsk'\n   * });\n   *\n   * @param {number|object} document\n   * @param {string|object} path\n   * @param {object|boolean|number|string|null|undefined} value\n   * @returns {storage.Document|Boolean}\n   */\n  update: function( document, path, value ){\n    var doc = this.documents[ document._id || document ];\n\n    if ( doc == null ){\n      console.warn('storage::update: Document is not found.');\n      return false;\n    }\n\n    return doc.set( path, value );\n  },\n\n  /**\n   * Обработчик на изменения (добавление, удаление) данных в коллекции\n   */\n  storageHasMutated: function(){\n    // Обновим массив документов (специальное отображение для перебора нокаутом)\n    this.array = _.toArray( this.documents );\n  },\n\n  /**\n   * Обновить ссылку на документ в поле documents\n   *\n   * @param {Document} doc\n   */\n  updateIdLink: function( doc ){\n    var id = doc._id.toString();\n    var oldId = _.findKey( this.documents, { _id: doc._id });\n\n    if ( !oldId ){\n      throw new TypeError('Не найден документ для обновления ссылки по этому _id: ' + id );\n    }\n\n    delete this.documents[ oldId ];\n    this.documents[ id ] = doc;\n  }\n};\n\n/*!\n * Module exports.\n */\nmodule.exports = Collection;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/collection.js\n ** module id = 5\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./lib/collection.js?")},/*!***********************!*\
  !*** ./lib/schema.js ***!
  \***********************/
function(module,exports,__webpack_require__){eval("'use strict';\n\n/*!\n * Module dependencies.\n */\n\nvar Events = __webpack_require__(/*! ./events */ 7)\n  , VirtualType = __webpack_require__(/*! ./virtualtype */ 8)\n  , utils = __webpack_require__(/*! ./utils */ 9)\n  , Types\n  , schemas;\n\n/**\n * Schema constructor.\n *\n * ####Example:\n *\n *     var child = new Schema({ name: String });\n *     var schema = new Schema({ name: String, age: Number, children: [child] });\n *     var Tree = mongoose.model('Tree', schema);\n *\n *     // setting schema options\n *     new Schema({ name: String }, { _id: false, autoIndex: false })\n *\n * ####Options:\n *\n * - [id](/docs/guide.html#id): bool - defaults to true\n * - `minimize`: bool - controls [document#toObject](#document_Document-toObject) behavior when called manually - defaults to true\n * - [strict](/docs/guide.html#strict): bool - defaults to true\n * - [toJSON](/docs/guide.html#toJSON) - object - no default\n * - [toObject](/docs/guide.html#toObject) - object - no default\n * - [versionKey](/docs/guide.html#versionKey): bool - defaults to \"__v\"\n *\n * ####Note:\n *\n * _When nesting schemas, (`children` in the example above), always declare the child schema first before passing it into is parent._\n *\n * @param {String|undefined} [name] Название схемы\n * @param {Schema} [baseSchema] Базовая схема при наследовании\n * @param {Object} obj Схема\n * @param {Object} [options]\n * @api public\n */\nfunction Schema ( name, baseSchema, obj, options ) {\n  if ( !(this instanceof Schema) ) {\n    return new Schema( name, baseSchema, obj, options );\n  }\n\n  // Если это именованая схема\n  if ( typeof name === 'string' ){\n    this.name = name;\n    schemas[ name ] = this;\n  } else {\n    options = obj;\n    obj = baseSchema;\n    baseSchema = name;\n    name = undefined;\n  }\n\n  if ( !(baseSchema instanceof Schema) ){\n    options = obj;\n    obj = baseSchema;\n    baseSchema = undefined;\n  }\n\n  //todo: зачем оно нужно? проблема: obj становится как у прошлой схемы + текущее, из-за этого source,\n  // потому что оно копируется из старой схемы в текущий source, а так как он ссылается на obj,\n  // и в js у нас разделение памяти, то obj расширяется полями source из старой схемы.\n  // Сохраним описание схемы для поддержки дискриминаторов\n  //this.source = obj;\n\n  this.paths = {};\n  this.subpaths = {};\n  this.virtuals = {};\n  this.nested = {};\n  this.inherits = {};\n  this.callQueue = [];\n  this.methods = {};\n  this.statics = {};\n  this.tree = {};\n  this._requiredpaths = undefined;\n  this.discriminatorMapping = undefined;\n\n  this.options = this.defaultOptions( options );\n\n  if ( baseSchema instanceof Schema ){\n    baseSchema.discriminator( name, this );\n  }\n\n  // build paths\n  if ( obj ) {\n    this.add( obj );\n  }\n\n  // check if _id's value is a subdocument (m-gh-2276)\n  var _idSubDoc = obj && obj._id && _.isObject( obj._id );\n\n  // ensure the documents get an auto _id unless disabled\n  var auto_id = !this.paths['_id'] && (!this.options.noId && this.options._id) && !_idSubDoc;\n\n  if (auto_id) {\n    this.add({ _id: {type: Schema.ObjectId, auto: true} });\n  }\n\n  // ensure the documents receive an id getter unless disabled\n  var autoid = !this.paths['id'] && this.options.id;\n  if ( autoid ) {\n    this.virtual('id').get( idGetter );\n  }\n\n  // adds updatedAt and createdAt timestamps to documents if enabled\n  var timestamps = this.options.timestamps;\n  if (timestamps) {\n    var createdAt = timestamps.createdAt || 'createdAt'\n      , updatedAt = timestamps.updatedAt || 'updatedAt'\n      , schemaAdditions = {};\n\n    schemaAdditions[updatedAt] = Date;\n\n    if (!this.paths[createdAt]) {\n      schemaAdditions[createdAt] = Date;\n    }\n\n    this.add(schemaAdditions);\n\n    //todo:\n    //this.pre('save', function (next) {\n    //  var defaultTimestamp = new Date();\n    //\n    //  if (!this[createdAt]){\n    //    this[createdAt] = auto_id ? this._id.getTimestamp() : defaultTimestamp;\n    //  }\n    //\n    //  this[updatedAt] = this.isNew ? this[createdAt] : defaultTimestamp;\n    //\n    //  next();\n    //});\n  }\n}\n\n/*!\n * Returns this documents _id cast to a string.\n */\nfunction idGetter () {\n  if (this.$__._id) {\n    return this.$__._id;\n  }\n\n  this.$__._id = null == this._id\n    ? null\n    : String(this._id);\n\n  return this.$__._id;\n}\n\n/*!\n * Inherit from EventEmitter.\n */\nSchema.prototype = Object.create( Events.prototype );\nSchema.prototype.constructor = Schema;\n\n/**\n * Schema as flat paths\n *\n * ####Example:\n *     {\n *         '_id'        : SchemaType,\n *       , 'nested.key' : SchemaType,\n *     }\n *\n * @api private\n * @property paths\n */\nSchema.prototype.paths;\n\n/**\n * Schema as a tree\n *\n * ####Example:\n *     {\n *         '_id'     : ObjectId\n *       , 'nested'  : {\n *             'key' : String\n *         }\n *     }\n *\n * @api private\n * @property tree\n */\nSchema.prototype.tree;\n\n/**\n * Returns default options for this schema, merged with `options`.\n *\n * @param {Object} options\n * @return {Object}\n * @api private\n */\nSchema.prototype.defaultOptions = function (options) {\n  options = _.assign({\n      strict: true\n    , versionKey: '__v'\n    , discriminatorKey: '__t'\n    , minimize: true\n    // the following are only applied at construction time\n    , _id: true\n    , id: true\n  }, options );\n\n  return options;\n};\n\n/**\n * Adds key path / schema type pairs to this schema.\n *\n * ####Example:\n *\n *     var ToySchema = new Schema;\n *     ToySchema.add({ name: 'string', color: 'string', price: 'number' });\n *\n * @param {Object} obj\n * @param {String} [prefix]\n * @api public\n */\nSchema.prototype.add = function add ( obj, prefix ) {\n  prefix = prefix || '';\n  var keys = Object.keys( obj );\n\n  for (var i = 0; i < keys.length; ++i) {\n    var key = keys[i];\n\n    if (null == obj[ key ]) {\n      throw new TypeError('Invalid value for schema path `'+ prefix + key +'`');\n    }\n\n    if ( _.isPlainObject(obj[key] )\n      && ( !obj[ key ].constructor || 'Object' === utils.getFunctionName(obj[key].constructor) )\n      && ( !obj[ key ].type || obj[ key ].type.type ) ){\n\n      if ( Object.keys(obj[ key ]).length ) {\n        // nested object { last: { name: String }}\n        this.nested[ prefix + key ] = true;\n        this.add( obj[ key ], prefix + key + '.');\n\n      } else {\n        this.path( prefix + key, obj[ key ] ); // mixed type\n      }\n\n    } else {\n      this.path( prefix + key, obj[ key ] );\n    }\n  }\n};\n\n/**\n * Reserved document keys.\n *\n * Keys in this object are names that are rejected in schema declarations b/c they conflict with mongoose functionality. Using these key name will throw an error.\n *\n *      on, emit, _events, db, get, set, init, isNew, errors, schema, options, _pres, _posts, toObject\n *\n * _NOTE:_ Use of these terms as method names is permitted, but play at your own risk, as they may be existing mongoose document methods you are stomping on.\n *\n *      var schema = new Schema(..);\n *      schema.methods.init = function () {} // potentially breaking\n */\nSchema.reserved = Object.create( null );\nvar reserved = Schema.reserved;\nreserved.on =\nreserved.get =\nreserved.set =\nreserved.init =\nreserved.isNew =\nreserved.errors =\nreserved.schema =\nreserved.options =\nreserved.toObject =\nreserved.trigger =    // Events\nreserved.off =    // Events\nreserved._events = // Events\n\n/**\n * Gets/sets schema paths.\n *\n * Sets a path (if arity 2)\n * Gets a path (if arity 1)\n *\n * ####Example\n *\n *     schema.path('name') // returns a SchemaType\n *     schema.path('name', Number) // changes the schemaType of `name` to Number\n *\n * @param {String} path\n * @param {Object} constructor\n * @api public\n */\nSchema.prototype.path = function (path, obj) {\n  if (obj === undefined) {\n    if (this.paths[path]) return this.paths[path];\n    if (this.subpaths[path]) return this.subpaths[path];\n\n    // subpaths?\n    return /\\.\\d+\\.?.*$/.test(path)\n      ? getPositionalPath(this, path)\n      : undefined;\n  }\n\n  // some path names conflict with document methods\n  if (reserved[path]) {\n    throw new Error('`' + path + '` may not be used as a schema pathname');\n  }\n\n  // update the tree\n  var subpaths = path.split(/\\./)\n    , last = subpaths.pop()\n    , branch = this.tree;\n\n  subpaths.forEach(function(sub, i) {\n    if (!branch[sub]) branch[sub] = {};\n    if ('object' !== typeof branch[sub]) {\n      var msg = 'Cannot set nested path `' + path + '`. '\n              + 'Parent path `'\n              + subpaths.slice(0, i).concat([sub]).join('.')\n              + '` already set to type ' + branch[sub].name\n              + '.';\n      throw new Error(msg);\n    }\n    branch = branch[sub];\n  });\n\n  branch[last] = utils.clone(obj);\n\n  this.paths[path] = Schema.interpretAsType(path, obj);\n  return this;\n};\n\n/**\n * Converts type arguments into Schema Types.\n *\n * @param {String} path\n * @param {Object} obj constructor\n * @api private\n */\nSchema.interpretAsType = function (path, obj) {\n  var constructorName = utils.getFunctionName(obj.constructor);\n  if (constructorName !== 'Object'){\n    obj = { type: obj };\n  }\n\n  // Get the type making sure to allow keys named \"type\"\n  // and default to mixed if not specified.\n  // { type: { type: String, default: 'freshcut' } }\n  var type = obj.type && !obj.type.type\n    ? obj.type\n    : {};\n\n  if ('Object' === utils.getFunctionName(type.constructor) || 'mixed' == type) {\n    return new Types.Mixed(path, obj);\n  }\n\n  if (Array.isArray(type) || Array == type || 'array' == type) {\n    // if it was specified through { type } look for `cast`\n    var cast = (Array == type || 'array' == type)\n      ? obj.cast\n      : type[0];\n\n    if (cast instanceof Schema) {\n      return new Types.DocumentArray(path, cast, obj);\n    }\n\n    if ('string' == typeof cast) {\n      cast = Types[cast.charAt(0).toUpperCase() + cast.substring(1)];\n    } else if (cast && (!cast.type || cast.type.type)\n                    && 'Object' === utils.getFunctionName(cast.constructor)\n                    && Object.keys(cast).length) {\n      return new Types.DocumentArray(path, new Schema(cast), obj);\n    }\n\n    return new Types.Array(path, cast || Types.Mixed, obj);\n  }\n\n  var name = 'string' === typeof type\n    ? type\n    // If not string, `type` is a function. Outside of IE, function.name\n    // gives you the function name. In IE, you need to compute it\n    : utils.getFunctionName(type);\n\n  if (name) {\n    name = name.charAt(0).toUpperCase() + name.substring(1);\n  }\n\n  if (undefined == Types[name]) {\n    throw new TypeError('Undefined type at `' + path +\n        '`\\n  Did you try nesting Schemas? ' +\n        'You can only nest using refs or arrays.');\n  }\n\n  return new Types[name](path, obj);\n};\n\n/**\n * Iterates the schemas paths similar to Array#forEach.\n *\n * The callback is passed the pathname and schemaType as arguments on each iteration.\n *\n * @param {Function} fn callback function\n * @return {Schema} this\n * @api public\n */\nSchema.prototype.eachPath = function (fn) {\n  var keys = Object.keys(this.paths)\n    , len = keys.length;\n\n  for (var i = 0; i < len; ++i) {\n    fn(keys[i], this.paths[keys[i]]);\n  }\n\n  return this;\n};\n\n/**\n * Returns an Array of path strings that are required by this schema.\n *\n * @api public\n * @return {Array}\n */\nSchema.prototype.requiredPaths = function requiredPaths () {\n  if (this._requiredpaths) return this._requiredpaths;\n\n  var paths = Object.keys(this.paths)\n    , i = paths.length\n    , ret = [];\n\n  while (i--) {\n    var path = paths[i];\n    if (this.paths[path].isRequired) ret.push(path);\n  }\n\n  this._requiredpaths = ret;\n\n  return this._requiredpaths;\n};\n\n/**\n * Returns the pathType of `path` for this schema.\n *\n * Given a path, returns whether it is a real, virtual, nested, or ad-hoc/undefined path.\n *\n * @param {String} path\n * @return {String}\n * @api public\n */\nSchema.prototype.pathType = function (path) {\n  if (path in this.paths) return 'real';\n  if (path in this.virtuals) return 'virtual';\n  if (path in this.nested) return 'nested';\n  if (path in this.subpaths) return 'real';\n\n  if (/\\.\\d+\\.|\\.\\d+$/.test(path) && getPositionalPath(this, path)) {\n    return 'real';\n  } else {\n    return 'adhocOrUndefined';\n  }\n};\n\n/*!\n * ignore\n */\nfunction getPositionalPath (self, path) {\n  var subpaths = path.split(/\\.(\\d+)\\.|\\.(\\d+)$/).filter(Boolean);\n  if (subpaths.length < 2) {\n    return self.paths[subpaths[0]];\n  }\n\n  var val = self.path(subpaths[0]);\n  if (!val) return val;\n\n  var last = subpaths.length - 1\n    , subpath\n    , i = 1;\n\n  for (; i < subpaths.length; ++i) {\n    subpath = subpaths[i];\n\n    if (i === last && val && !val.schema && !/\\D/.test(subpath)) {\n      if (val instanceof Types.Array) {\n        // StringSchema, NumberSchema, etc\n        val = val.caster;\n      } else {\n        val = undefined;\n      }\n      break;\n    }\n\n    // ignore if its just a position segment: path.0.subpath\n    if (!/\\D/.test(subpath)) continue;\n\n    if (!(val && val.schema)) {\n      val = undefined;\n      break;\n    }\n\n    val = val.schema.path(subpath);\n  }\n\n  self.subpaths[ path ] = val;\n\n  return self.subpaths[ path ];\n}\n\n/**\n * Adds a method call to the queue.\n *\n * @param {String} name name of the document method to call later\n * @param {Array} args arguments to pass to the method\n * @api private\n */\nSchema.prototype.queue = function(name, args){\n  this.callQueue.push([name, args]);\n  return this;\n};\n\n/**\n * Defines a pre hook for the document.\n *\n * ####Example\n *\n *     var toySchema = new Schema(..);\n *\n *     toySchema.pre('save', function (next) {\n *       if (!this.created) this.created = new Date;\n *       next();\n *     })\n *\n *     toySchema.pre('validate', function (next) {\n *       if (this.name != 'Woody') this.name = 'Woody';\n *       next();\n *     })\n *\n * @param {String} method\n * @param {Function} callback\n * @see hooks.js https://github.com/bnoguchi/hooks-js/tree/31ec571cef0332e21121ee7157e0cf9728572cc3\n * @api public\n */\nSchema.prototype.pre = function(){\n  return this.queue('pre', arguments);\n};\n\n/**\n * Defines a post for the document\n *\n * Post hooks fire `on` the event emitted from document instances of Models compiled from this schema.\n *\n *     var schema = new Schema(..);\n *     schema.post('save', function (doc) {\n *       console.log('this fired after a document was saved');\n *     });\n *\n *     var Model = mongoose.model('Model', schema);\n *\n *     var m = new Model(..);\n *     m.save(function (err) {\n *       console.log('this fires after the `post` hook');\n *     });\n *\n * @param {String} method name of the method to hook\n * @param {Function} fn callback\n * @see hooks.js https://github.com/bnoguchi/hooks-js/tree/31ec571cef0332e21121ee7157e0cf9728572cc3\n * @api public\n */\nSchema.prototype.post = function(method, fn){\n  return this.queue('on', arguments);\n};\n\n/**\n * Registers a plugin for this schema.\n *\n * @param {Function} plugin callback\n * @param {Object} opts\n * @see plugins\n * @api public\n */\nSchema.prototype.plugin = function (fn, opts) {\n  fn(this, opts);\n  return this;\n};\n\n/**\n * Adds an instance method to documents constructed from Models compiled from this schema.\n *\n * ####Example\n *\n *     var schema = kittySchema = new Schema(..);\n *\n *     schema.method('meow', function () {\n *       console.log('meeeeeoooooooooooow');\n *     })\n *\n *     var Kitty = mongoose.model('Kitty', schema);\n *\n *     var fizz = new Kitty;\n *     fizz.meow(); // meeeeeooooooooooooow\n *\n * If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as methods.\n *\n *     schema.method({\n *         purr: function () {}\n *       , scratch: function () {}\n *     });\n *\n *     // later\n *     fizz.purr();\n *     fizz.scratch();\n *\n * @param {String|Object} method name\n * @param {Function} [fn]\n * @api public\n */\nSchema.prototype.method = function (name, fn) {\n  if ('string' !== typeof name) {\n    for (var i in name) {\n      this.methods[i] = name[i];\n    }\n  } else {\n    this.methods[name] = fn;\n  }\n\n  return this;\n};\n\n/**\n * Adds static \"class\" methods to Models compiled from this schema.\n *\n * ####Example\n *\n *     var schema = new Schema(..);\n *     schema.static('findByName', function (name, callback) {\n *       return this.find({ name: name }, callback);\n *     });\n *\n *     var Drink = mongoose.model('Drink', schema);\n *     Drink.findByName('sanpellegrino', function (err, drinks) {\n *       //\n *     });\n *\n * If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as statics.\n *\n * @param {String} name\n * @param {Function} fn\n * @api public\n */\nSchema.prototype.static = function(name, fn) {\n  if ('string' !== typeof name) {\n    for (var i in name) {\n      this.statics[i] = name[i];\n    }\n  } else {\n    this.statics[name] = fn;\n  }\n\n  return this;\n};\n\n/**\n * Sets/gets a schema option.\n *\n * @param {String} key option name\n * @param {Object} [value] if not passed, the current option value is returned\n * @api public\n */\nSchema.prototype.set = function (key, value) {\n  if (1 === arguments.length) {\n    return this.options[key];\n  }\n\n  this.options[key] = value;\n\n  return this;\n};\n\n/**\n * Gets a schema option.\n *\n * @param {String} key option name\n * @api public\n */\n\nSchema.prototype.get = function (key) {\n  return this.options[key];\n};\n\n/**\n * Creates a virtual type with the given name.\n *\n * @param {String} name\n * @param {Object} [options]\n * @return {VirtualType}\n */\n\nSchema.prototype.virtual = function (name, options) {\n  var virtuals = this.virtuals;\n  var parts = name.split('.');\n\n  virtuals[name] = parts.reduce(function (mem, part, i) {\n    mem[part] || (mem[part] = (i === parts.length-1)\n      ? new VirtualType(options, name)\n      : {});\n    return mem[part];\n  }, this.tree);\n\n  return virtuals[name];\n};\n\n/**\n * Returns the virtual type with the given `name`.\n *\n * @param {String} name\n * @return {VirtualType}\n */\n\nSchema.prototype.virtualpath = function (name) {\n  return this.virtuals[name];\n};\n\n/**\n * Registered discriminators for this schema.\n *\n * @property discriminators\n * @api public\n */\nSchema.discriminators;\n\n/**\n * Schema inheritance\n * this - baseSchema\n *\n * ####Example:\n *     var PersonSchema = new Schema('Person', {\n *       name: String,\n *       createdAt: Date\n *     });\n *\n *     var BossSchema = new Schema('Boss', PersonSchema, { department: String });\n *\n * @param {String} name   discriminator name\n * @param {Schema} schema discriminator schema\n * @api public\n */\nSchema.prototype.discriminator = function discriminator (name, schema) {\n  if (!(schema instanceof Schema)) {\n    throw new Error('You must pass a valid discriminator Schema');\n  }\n\n  if ( this.discriminatorMapping && !this.discriminatorMapping.isRoot ) {\n    throw new Error('Discriminator \"' + name + '\" can only be a discriminator of the root model');\n  }\n\n  var key = this.options.discriminatorKey;\n  if ( schema.path(key) ) {\n    throw new Error('Discriminator \"' + name + '\" cannot have field with name \"' + key + '\"');\n  }\n\n  // merges base schema into new discriminator schema and sets new type field.\n  (function mergeSchemas(schema, baseSchema) {\n    utils.merge(schema, baseSchema);\n\n    var obj = {};\n    obj[key] = { type: String, default: name };\n    schema.add(obj);\n    schema.discriminatorMapping = { key: key, value: name, isRoot: false };\n\n      // throws error if options are invalid\n    (function validateOptions(a, b) {\n      a = utils.clone(a);\n      b = utils.clone(b);\n      delete a.toJSON;\n      delete a.toObject;\n      delete b.toJSON;\n      delete b.toObject;\n\n      if (!utils.deepEqual(a, b)) {\n        throw new Error('Discriminator options are not customizable (except toJSON & toObject)');\n      }\n    })(schema.options, baseSchema.options);\n\n    var toJSON = schema.options.toJSON\n      , toObject = schema.options.toObject;\n\n    schema.options = utils.clone(baseSchema.options);\n    if (toJSON)   schema.options.toJSON = toJSON;\n    if (toObject) schema.options.toObject = toObject;\n\n    //schema.callQueue = baseSchema.callQueue.concat(schema.callQueue);\n    schema._requiredpaths = undefined; // reset just in case Schema#requiredPaths() was called on either schema\n  })(schema, this);\n\n  if (!this.discriminators) {\n    this.discriminators = {};\n  }\n\n  if (!this.discriminatorMapping) {\n    this.discriminatorMapping = { key: key, value: null, isRoot: true };\n  }\n\n  if (this.discriminators[name]) {\n    throw new Error('Discriminator with name \"' + name + '\" already exists');\n  }\n\n  this.discriminators[name] = schema;\n\n  // Register methods and statics\n  for ( var m in this.methods ){\n    schema.methods[ m ] = this.methods[ m ];\n  }\n  for ( var s in this.statics ){\n    schema.statics[ s ] = this.methods[ s ];\n  }\n\n  return this.discriminators[name];\n};\n\n/*!\n * exports\n */\n\nmodule.exports = Schema;\nwindow.Schema = Schema;\n\n// require down here because of reference issues\n\n/**\n * The various built-in Storage Schema Types.\n *\n * ####Example:\n *\n *     var mongoose = require('mongoose');\n *     var ObjectId = mongoose.Schema.Types.ObjectId;\n *\n * ####Types:\n *\n * - [String](#schema-string-js)\n * - [Number](#schema-number-js)\n * - [Boolean](#schema-boolean-js) | Bool\n * - [Array](#schema-array-js)\n * - [Date](#schema-date-js)\n * - [ObjectId](#schema-objectid-js) | Oid\n * - [Mixed](#schema-mixed-js) | Object\n *\n * Using this exposed access to the `Mixed` SchemaType, we can use them in our schema.\n *\n *     var Mixed = mongoose.Schema.Types.Mixed;\n *     new mongoose.Schema({ _user: Mixed })\n *\n * @api public\n */\nSchema.Types = __webpack_require__(/*! ./schema/index */ 30);\n\n// Хранилище схем\nSchema.schemas = schemas = {};\n\n\n/*!\n * ignore\n */\n\nTypes = Schema.Types;\nSchema.ObjectId = Types.ObjectId;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/schema.js\n ** module id = 6\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./lib/schema.js?")},/*!***********************!*\
  !*** ./lib/events.js ***!
  \***********************/
function(module,exports){eval("'use strict';\n\n/**\n *\n * Backbone.Events\n\n * A module that can be mixed in to *any object* in order to provide it with\n * custom events. You may bind with `on` or remove with `off` callback\n * functions to an event; `trigger`-ing an event fires all callbacks in\n * succession.\n *\n * var object = {};\n * _.extend(object, Events.prototype);\n * object.on('expand', function(){ alert('expanded'); });\n * object.trigger('expand');\n */\nfunction Events() {}\n\nEvents.prototype = {\n  /**\n   * Bind an event to a `callback` function. Passing `\"all\"` will bind\n   * the callback to all events fired.\n   * @param name\n   * @param callback\n   * @param context\n   * @returns {Events}\n   */\n  on: function(name, callback, context) {\n    if (!eventsApi(this, 'on', name, [callback, context]) || !callback) return this;\n    this._events || (this._events = {});\n    var events = this._events[name] || (this._events[name] = []);\n    events.push({callback: callback, context: context, ctx: context || this});\n    return this;\n  },\n\n  /**\n   * Bind an event to only be triggered a single time. After the first time\n   * the callback is invoked, it will be removed.\n   *\n   * @param name\n   * @param callback\n   * @param context\n   * @returns {Events}\n   */\n  once: function(name, callback, context) {\n    if (!eventsApi(this, 'once', name, [callback, context]) || !callback) return this;\n    var self = this;\n    var once = _.once(function() {\n      self.off(name, once);\n      callback.apply(this, arguments);\n    });\n    once._callback = callback;\n    return this.on(name, once, context);\n  },\n\n  /**\n   * Remove one or many callbacks. If `context` is null, removes all\n   * callbacks with that function. If `callback` is null, removes all\n   * callbacks for the event. If `name` is null, removes all bound\n   * callbacks for all events.\n   *\n   * @param name\n   * @param callback\n   * @param context\n   * @returns {Events}\n   */\n  off: function(name, callback, context) {\n    var retain, ev, events, names, i, l, j, k;\n    if (!this._events || !eventsApi(this, 'off', name, [callback, context])) return this;\n    if (!name && !callback && !context) {\n      this._events = {};\n      return this;\n    }\n    names = name ? [name] : _.keys(this._events);\n    for (i = 0, l = names.length; i < l; i++) {\n      name = names[i];\n      if (events = this._events[name]) {\n        this._events[name] = retain = [];\n        if (callback || context) {\n          for (j = 0, k = events.length; j < k; j++) {\n            ev = events[j];\n            if ((callback && callback !== ev.callback && callback !== ev.callback._callback) ||\n              (context && context !== ev.context)) {\n              retain.push(ev);\n            }\n          }\n        }\n        if (!retain.length) delete this._events[name];\n      }\n    }\n\n    return this;\n  },\n\n  /**\n   * Trigger one or many events, firing all bound callbacks. Callbacks are\n   * passed the same arguments as `trigger` is, apart from the event name\n   * (unless you're listening on `\"all\"`, which will cause your callback to\n   * receive the true name of the event as the first argument).\n   *\n   * @param name\n   * @returns {Events}\n   */\n  trigger: function(name) {\n    if (!this._events) return this;\n    var args = Array.prototype.slice.call(arguments, 1);\n    if (!eventsApi(this, 'trigger', name, args)) return this;\n    var events = this._events[name];\n    var allEvents = this._events.all;\n    if (events) triggerEvents(events, args);\n    if (allEvents) triggerEvents(allEvents, arguments);\n    return this;\n  },\n\n  /**\n   * Tell this object to stop listening to either specific events ... or\n   * to every object it's currently listening to.\n   *\n   * @param obj\n   * @param name\n   * @param callback\n   * @returns {Events}\n   */\n  stopListening: function(obj, name, callback) {\n    var listeningTo = this._listeningTo;\n    if (!listeningTo) return this;\n    var remove = !name && !callback;\n    if (!callback && typeof name === 'object') callback = this;\n    if (obj) (listeningTo = {})[obj._listenId] = obj;\n    for (var id in listeningTo) {\n      obj = listeningTo[id];\n      obj.off(name, callback, this);\n      if (remove || _.isEmpty(obj._events)) delete this._listeningTo[id];\n    }\n    return this;\n  }\n};\n\n// Regular expression used to split event strings.\nvar eventSplitter = /\\s+/;\n\n/**\n * Implement fancy features of the Events API such as multiple event\n * names `\"change blur\"` and jQuery-style event maps `{change: action}`\n * in terms of the existing API.\n *\n * @param obj\n * @param action\n * @param name\n * @param rest\n * @returns {boolean}\n */\nvar eventsApi = function(obj, action, name, rest) {\n  if (!name) return true;\n\n  // Handle event maps.\n  if (typeof name === 'object') {\n    for (var key in name) {\n      obj[action].apply(obj, [key, name[key]].concat(rest));\n    }\n    return false;\n  }\n\n  // Handle space separated event names.\n  if (eventSplitter.test(name)) {\n    var names = name.split(eventSplitter);\n    for (var i = 0, l = names.length; i < l; i++) {\n      obj[action].apply(obj, [names[i]].concat(rest));\n    }\n    return false;\n  }\n\n  return true;\n};\n\n/**\n * A difficult-to-believe, but optimized internal dispatch function for\n * triggering events. Tries to keep the usual cases speedy (most internal\n * Backbone events have 3 arguments).\n *\n * @param events\n * @param args\n */\nvar triggerEvents = function(events, args) {\n  var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];\n  switch (args.length) {\n    case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;\n    case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;\n    case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;\n    case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;\n    default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args);\n  }\n};\n\nvar listenMethods = {listenTo: 'on', listenToOnce: 'once'};\n\n// Inversion-of-control versions of `on` and `once`. Tell *this* object to\n// listen to an event in another object ... keeping track of what it's\n// listening to.\n_.each(listenMethods, function(implementation, method) {\n  Events[method] = function(obj, name, callback) {\n    var listeningTo = this._listeningTo || (this._listeningTo = {});\n    var id = obj._listenId || (obj._listenId = _.uniqueId('l'));\n    listeningTo[id] = obj;\n    if (!callback && typeof name === 'object') callback = this;\n    obj[implementation](name, callback, this);\n    return this;\n  };\n});\n\nmodule.exports = Events;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/events.js\n ** module id = 7\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./lib/events.js?")},/*!****************************!*\
  !*** ./lib/virtualtype.js ***!
  \****************************/
function(module,exports){eval("'use strict';\n\n/**\n * VirtualType constructor\n *\n * This is what mongoose uses to define virtual attributes via `Schema.prototype.virtual`.\n *\n * ####Example:\n *\n *     var fullname = schema.virtual('fullname');\n *     fullname instanceof mongoose.VirtualType // true\n *\n * @parma {Object} options\n * @api public\n */\n\nfunction VirtualType (options, name) {\n  this.path = name;\n  this.getters = [];\n  this.setters = [];\n  this.options = options || {};\n}\n\n/**\n * Defines a getter.\n *\n * ####Example:\n *\n *     var virtual = schema.virtual('fullname');\n *     virtual.get(function () {\n *       return this.name.first + ' ' + this.name.last;\n *     });\n *\n * @param {Function} fn\n * @return {VirtualType} this\n * @api public\n */\n\nVirtualType.prototype.get = function (fn) {\n  this.getters.push(fn);\n  return this;\n};\n\n/**\n * Defines a setter.\n *\n * ####Example:\n *\n *     var virtual = schema.virtual('fullname');\n *     virtual.set(function (v) {\n *       var parts = v.split(' ');\n *       this.name.first = parts[0];\n *       this.name.last = parts[1];\n *     });\n *\n * @param {Function} fn\n * @return {VirtualType} this\n * @api public\n */\n\nVirtualType.prototype.set = function (fn) {\n  this.setters.push(fn);\n  return this;\n};\n\n/**\n * Applies getters to `value` using optional `scope`.\n *\n * @param {Object} value\n * @param {Object} scope\n * @return {*} the value after applying all getters\n * @api public\n */\n\nVirtualType.prototype.applyGetters = function (value, scope) {\n  var v = value;\n  for (var l = this.getters.length - 1; l >= 0; l--) {\n    v = this.getters[l].call(scope, v, this);\n  }\n  return v;\n};\n\n/**\n * Applies setters to `value` using optional `scope`.\n *\n * @param {Object} value\n * @param {Object} scope\n * @return {*} the value after applying all setters\n * @api public\n */\n\nVirtualType.prototype.applySetters = function (value, scope) {\n  var v = value;\n  for (var l = this.setters.length - 1; l >= 0; l--) {\n    v = this.setters[l].call(scope, v, this);\n  }\n  return v;\n};\n\n/*!\n * exports\n */\n\nmodule.exports = VirtualType;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/virtualtype.js\n ** module id = 8\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./lib/virtualtype.js?")},/*!**********************!*\
  !*** ./lib/utils.js ***!
  \**********************/
function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(Buffer, global, process) {'use strict';\n\n/*!\n * Module dependencies.\n */\n\nvar ObjectId = __webpack_require__(/*! ./types/objectid */ 11)\n  , mpath = __webpack_require__(/*! ./mpath */ 13)\n  , Document;\n\nexports.mpath = mpath;\n\n/**\n * Pluralization rules.\n *\n * These rules are applied while processing the argument to `pluralize`.\n *\n */\nexports.pluralization = [\n  [/(m)an$/gi, '$1en'],\n  [/(pe)rson$/gi, '$1ople'],\n  [/(child)$/gi, '$1ren'],\n  [/^(ox)$/gi, '$1en'],\n  [/(ax|test)is$/gi, '$1es'],\n  [/(octop|vir)us$/gi, '$1i'],\n  [/(alias|status)$/gi, '$1es'],\n  [/(bu)s$/gi, '$1ses'],\n  [/(buffal|tomat|potat)o$/gi, '$1oes'],\n  [/([ti])um$/gi, '$1a'],\n  [/sis$/gi, 'ses'],\n  [/(?:([^f])fe|([lr])f)$/gi, '$1$2ves'],\n  [/(hive)$/gi, '$1s'],\n  [/([^aeiouy]|qu)y$/gi, '$1ies'],\n  [/(x|ch|ss|sh)$/gi, '$1es'],\n  [/(matr|vert|ind)ix|ex$/gi, '$1ices'],\n  [/([m|l])ouse$/gi, '$1ice'],\n  [/(kn|w|l)ife$/gi, '$1ives'],\n  [/(quiz)$/gi, '$1zes'],\n  [/s$/gi, 's'],\n  [/([^a-z])$/, '$1'],\n  [/$/gi, 's']\n];\nvar rules = exports.pluralization;\n\n/**\n * Uncountable words.\n *\n * These words are applied while processing the argument to `pluralize`.\n * @api public\n */\nexports.uncountables = [\n  'advice',\n  'energy',\n  'excretion',\n  'digestion',\n  'cooperation',\n  'health',\n  'justice',\n  'labour',\n  'machinery',\n  'equipment',\n  'information',\n  'pollution',\n  'sewage',\n  'paper',\n  'money',\n  'species',\n  'series',\n  'rain',\n  'rice',\n  'fish',\n  'sheep',\n  'moose',\n  'deer',\n  'news',\n  'expertise',\n  'status',\n  'media'\n];\nvar uncountables = exports.uncountables;\n\n/*!\n * Pluralize function.\n *\n * @author TJ Holowaychuk (extracted from _ext.js_)\n * @param {String} string to pluralize\n * @api private\n */\n\nexports.pluralize = function (str) {\n  var found;\n  if (!~uncountables.indexOf(str.toLowerCase())){\n    found = rules.filter(function(rule){\n      return str.match(rule[0]);\n    });\n    if (found[0]) return str.replace(found[0][0], found[0][1]);\n  }\n  return str;\n};\n\n/*!\n * Determines if `a` and `b` are deep equal.\n *\n * Modified from node/lib/assert.js\n * Modified from mongoose/utils.js\n *\n * @param {*} a a value to compare to `b`\n * @param {*} b a value to compare to `a`\n * @return {Boolean}\n * @api private\n */\nexports.deepEqual = function deepEqual (a, b) {\n  if (a instanceof ObjectId && b instanceof ObjectId) {\n    return a.toString() === b.toString();\n  }\n\n  // Handle StorageNumbers\n  if (a instanceof Number && b instanceof Number) {\n    return a.valueOf() === b.valueOf();\n  }\n\n  if (Buffer.isBuffer(a)) {\n    return a.equals(b);\n  }\n\n  if (isStorageObject(a)) a = a.toObject();\n  if (isStorageObject(b)) b = b.toObject();\n\n  return _.isEqual(a, b);\n};\n\n\n\nvar toString = Object.prototype.toString;\n\nfunction isRegExp (o) {\n  return 'object' === typeof o\n      && '[object RegExp]' === toString.call(o);\n}\n\nfunction cloneRegExp (regexp) {\n  if (!isRegExp(regexp)) {\n    throw new TypeError('Not a RegExp');\n  }\n\n  var flags = [];\n  if (regexp.global) flags.push('g');\n  if (regexp.multiline) flags.push('m');\n  if (regexp.ignoreCase) flags.push('i');\n  return new RegExp(regexp.source, flags.join(''));\n}\n\n/*!\n * Object clone with Storage natives support.\n *\n * If options.minimize is true, creates a minimal data object. Empty objects and undefined values will not be cloned. This makes the data payload sent to MongoDB as small as possible.\n *\n * Functions are never cloned.\n *\n * @param {Object} obj the object to clone\n * @param {Object} options\n * @return {Object} the cloned object\n * @api private\n */\nexports.clone = function clone (obj, options) {\n  if (obj === undefined || obj === null)\n    return obj;\n\n  if ( _.isArray( obj ) ) {\n    return cloneArray( obj, options );\n  }\n\n  if ( isStorageObject( obj ) ) {\n    if (options && options.json && 'function' === typeof obj.toJSON) {\n      return obj.toJSON( options );\n    } else {\n      return obj.toObject( options );\n    }\n  }\n\n  if ( obj.constructor ) {\n    switch ( getFunctionName( obj.constructor )) {\n      case 'Object':\n        return cloneObject(obj, options);\n      case 'Date':\n        return new obj.constructor( +obj );\n      case 'RegExp':\n        return cloneRegExp( obj );\n      default:\n        // ignore\n        break;\n    }\n  }\n\n  if ( obj instanceof ObjectId ) {\n    if ( options.depopulate ){\n      return obj.toString();\n    }\n\n    return new ObjectId( obj.id );\n  }\n\n  if ( !obj.constructor && _.isObject( obj ) ) {\n    // object created with Object.create(null)\n    return cloneObject( obj, options );\n  }\n\n  if ( obj.valueOf ){\n    return obj.valueOf();\n  }\n};\nvar clone = exports.clone;\n\n/*!\n * ignore\n */\nfunction cloneObject (obj, options) {\n  var retainKeyOrder = options && options.retainKeyOrder\n    , minimize = options && options.minimize\n    , ret = {}\n    , hasKeys\n    , keys\n    , val\n    , k\n    , i;\n\n  if ( retainKeyOrder ) {\n    for (k in obj) {\n      val = clone( obj[k], options );\n\n      if ( !minimize || ('undefined' !== typeof val) ) {\n        hasKeys || (hasKeys = true);\n        ret[k] = val;\n      }\n    }\n  } else {\n    // faster\n\n    keys = Object.keys( obj );\n    i = keys.length;\n\n    while (i--) {\n      k = keys[i];\n      val = clone(obj[k], options);\n\n      if (!minimize || ('undefined' !== typeof val)) {\n        if (!hasKeys) hasKeys = true;\n        ret[k] = val;\n      }\n    }\n  }\n\n  return minimize\n    ? hasKeys && ret\n    : ret;\n}\n\nfunction cloneArray (arr, options) {\n  var ret = [];\n  for (var i = 0, l = arr.length; i < l; i++) {\n    ret.push( clone( arr[i], options ) );\n  }\n  return ret;\n}\n\n/*!\n * Merges `from` into `to` without overwriting existing properties.\n *\n * @param {Object} to\n * @param {Object} from\n * @api private\n */\nexports.merge = function merge (to, from) {\n  var keys = Object.keys(from)\n    , i = keys.length\n    , key;\n\n  while (i--) {\n    key = keys[i];\n\n    if ( typeof to[key] === 'undefined' ){\n      to[key] = from[key];\n\n    } else if ( _.isObject( from[key] ) ){\n      merge( to[key], from[key] );\n    }\n  }\n};\n\n/*!\n * Generates a random string\n *\n * @api private\n */\n\nexports.random = function () {\n  return Math.random().toString().substr(3);\n};\n\n\n/*!\n * Returns if `v` is a storage object that has a `toObject()` method we can use.\n *\n * This is for compatibility with libs like Date.js which do foolish things to Natives.\n *\n * @param {*} v\n * @api private\n */\nexports.isStorageObject = function ( v ) {\n  Document || (Document = __webpack_require__(/*! ./document */ 14));\n\n  return v instanceof Document ||\n       ( v && v.isStorageArray );\n};\nvar isStorageObject = exports.isStorageObject;\n\n/*!\n * Return the value of `obj` at the given `path`.\n *\n * @param {String} path\n * @param {Object} obj\n */\n\nexports.getValue = function (path, obj, map) {\n  return mpath.get(path, obj, '_doc', map);\n};\n\n/*!\n * Sets the value of `obj` at the given `path`.\n *\n * @param {String} path\n * @param {Anything} val\n * @param {Object} obj\n */\n\nexports.setValue = function (path, val, obj, map) {\n  mpath.set(path, val, obj, '_doc', map);\n};\n\nvar rFunctionName = /^function\\s*([^\\s(]+)/;\nfunction getFunctionName( ctor ){\n  if (ctor.name) {\n    return ctor.name;\n  }\n  return (ctor.toString().trim().match( rFunctionName ) || [])[1];\n}\nexports.getFunctionName = getFunctionName;\n\nexports.setImmediate = (function() {\n  // Для поддержки тестов (окружение node.js)\n  if ( typeof global === 'object' && process.nextTick ) return process.nextTick;\n  // Если в браузере уже реализован этот метод\n  if ( window.setImmediate ) return window.setImmediate;\n\n  var head = { }, tail = head; // очередь вызовов, 1-связный список\n\n  var ID = Math.random(); // уникальный идентификатор\n\n  function onmessage(e) {\n    if(e.data != ID) return; // не наше сообщение\n    head = head.next;\n    var func = head.func;\n    delete head.func;\n    func();\n  }\n\n  if(window.addEventListener) { // IE9+, другие браузеры\n    window.addEventListener('message', onmessage, false);\n  } else { // IE8\n    window.attachEvent( 'onmessage', onmessage );\n  }\n\n  return window.postMessage ? function(func) {\n    tail = tail.next = { func: func };\n    window.postMessage(ID, '*');\n  } :\n  function(func) { // IE<8\n    setTimeout(func, 0);\n  };\n}());\n\n// PhantomJS doesn't support bind yet\nif (!Function.prototype.bind) {\n  Function.prototype.bind = function(oThis) {\n    if (typeof this !== 'function') {\n      // ближайший аналог внутренней функции\n      // IsCallable в ECMAScript 5\n      throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');\n    }\n\n    var aArgs = Array.prototype.slice.call(arguments, 1),\n      fToBind = this,\n      Noop    = function() {},\n      fBound  = function() {\n        return fToBind.apply(this instanceof Noop && oThis\n            ? this\n            : oThis,\n          aArgs.concat(Array.prototype.slice.call(arguments)));\n      };\n\n    Noop.prototype = this.prototype;\n    fBound.prototype = new Noop();\n\n    return fBound;\n  };\n}\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/node-libs-browser/~/buffer/index.js */ 1).Buffer, (function() { return this; }()), __webpack_require__(/*! ./~/node-libs-browser/~/process/browser.js */ 10)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/utils.js\n ** module id = 9\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./lib/utils.js?")},/*!**************************************************!*\
  !*** ./~/node-libs-browser/~/process/browser.js ***!
  \**************************************************/
function(module,exports){eval("// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            currentQueue[queueIndex].run();\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\n// TODO(shtylman)\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/node-libs-browser/~/process/browser.js\n ** module id = 10\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/node-libs-browser/~/process/browser.js?")},/*!*******************************!*\
  !*** ./lib/types/objectid.js ***!
  \*******************************/
function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(process) {'use strict';\n\n/**\n * Module dependencies.\n * @ignore\n */\nvar BinaryParser = __webpack_require__(/*! ../binaryparser */ 12).BinaryParser;\n\n/**\n * Machine id.\n *\n * Create a random 3-byte value (i.e. unique for this\n * process). Other drivers use a md5 of the machine id here, but\n * that would mean an asyc call to gethostname, so we don't bother.\n * @ignore\n */\nvar MACHINE_ID = parseInt(Math.random() * 0xFFFFFF, 10);\n\n// Regular expression that checks for hex value\nvar checkForHexRegExp = new RegExp('^[0-9a-fA-F]{24}$');\n\n/**\n * Create a new ObjectId instance\n *\n * @see https://github.com/mongodb/js-bson/blob/master/lib/bson/objectid.js\n * @class Represents a BSON ObjectId type.\n * @param {(string|number)} id Can be a 24 byte hex string, 12 byte binary string or a Number.\n * @property {number} generationTime The generation time of this ObjectId instance\n * @return {ObjectId} instance of ObjectId.\n */\nfunction ObjectId(id) {\n  if(!(this instanceof ObjectId)) return new ObjectId(id);\n  if((id instanceof ObjectId)) return id;\n\n  this._bsontype = 'ObjectId';\n  var valid = ObjectId.isValid(id);\n\n  // Throw an error if it's not a valid setup\n  if(!valid && id != null){\n    throw new Error('Argument passed in must be a single String of 12 bytes or a string of 24 hex characters');\n  } else if(valid && typeof id === 'string' && id.length === 24) {\n    return ObjectId.createFromHexString(id);\n  } else if(id == null || typeof id === 'number') {\n    // convert to 12 byte binary string\n    this.id = this.generate(id);\n  } else if(id != null && id.length === 12) {\n    // assume 12 byte string\n    this.id = id;\n  }\n\n  if(ObjectId.cacheHexString) this.__id = this.toHexString();\n}\n\n// Precomputed hex table enables speedy hex string conversion\nvar hexTable = [];\nfor (var i = 0; i < 256; i++) {\n  hexTable[i] = (i <= 15 ? '0' : '') + i.toString(16);\n}\n\n/**\n * Return the ObjectId id as a 24 byte hex string representation\n *\n * @method\n * @return {string} return the 24 byte hex string representation.\n */\nObjectId.prototype.toHexString = function() {\n  if(ObjectId.cacheHexString && this.__id) return this.__id;\n\n  var hexString = '';\n\n  for (var i = 0; i < this.id.length; i++) {\n    hexString += hexTable[this.id.charCodeAt(i)];\n  }\n\n  if(ObjectId.cacheHexString) this.__id = hexString;\n  return hexString;\n};\n\n/**\n * Update the ObjectId index used in generating new ObjectId's on the driver\n *\n * @method\n * @return {number} returns next index value.\n * @ignore\n */\nObjectId.prototype.get_inc = function() {\n  ObjectId.index = (ObjectId.index + 1) % 0xFFFFFF;\n\n  return ObjectId.index;\n};\n\n/**\n * Update the ObjectId index used in generating new ObjectId's on the driver\n *\n * @method\n * @return {number} returns next index value.\n * @ignore\n */\nObjectId.prototype.getInc = function() {\n  return this.get_inc();\n};\n\n/**\n * Generate a 12 byte id string used in ObjectId's\n *\n * @method\n * @param {number} [time] optional parameter allowing to pass in a second based timestamp.\n * @return {string} return the 12 byte id binary string.\n */\nObjectId.prototype.generate = function(time) {\n  if ('number' !== typeof time) {\n    time = parseInt(Date.now()/1000,10);\n  }\n\n  var time4Bytes = BinaryParser.encodeInt(time, 32, true, true);\n  /* for time-based ObjectId the bytes following the time will be zeroed */\n  var machine3Bytes = BinaryParser.encodeInt(MACHINE_ID, 24, false);\n  var pid2Bytes = BinaryParser.fromShort(typeof process === 'undefined' ? Math.floor(Math.random() * 100000) : process.pid);\n  var index3Bytes = BinaryParser.encodeInt(this.get_inc(), 24, false, true);\n\n  return time4Bytes + machine3Bytes + pid2Bytes + index3Bytes;\n};\n\n/**\n * Converts the id into a 24 byte hex string for printing\n *\n * @return {String} return the 24 byte hex string representation.\n * @ignore\n */\nObjectId.prototype.toString = function() {\n  return this.toHexString();\n};\n\n/**\n * Converts to its JSON representation.\n *\n * @return {String} return the 24 byte hex string representation.\n * @ignore\n */\nObjectId.prototype.toJSON = function() {\n  return this.toHexString();\n};\n\n/**\n * Compares the equality of this ObjectId with `otherID`.\n *\n * @method\n * @param {object} otherID ObjectId instance to compare against.\n * @return {boolean} the result of comparing two ObjectId's\n */\nObjectId.prototype.equals = function equals (otherID) {\n  if(otherID == null) return false;\n  var id = (otherID instanceof ObjectId || otherID.toHexString)\n    ? otherID.id\n    : ObjectId.createFromHexString(otherID).id;\n\n  return this.id === id;\n};\n\n/**\n * Returns the generation date (accurate up to the second) that this ID was generated.\n *\n * @method\n * @return {date} the generation date\n */\nObjectId.prototype.getTimestamp = function() {\n  var timestamp = new Date();\n  timestamp.setTime(Math.floor(BinaryParser.decodeInt(this.id.substring(0,4), 32, true, true)) * 1000);\n  return timestamp;\n};\n\n/**\n * @ignore\n */\nObjectId.index = parseInt(Math.random() * 0xFFFFFF, 10);\n\n/**\n * @ignore\n */\nObjectId.createPk = function createPk () {\n  return new ObjectId();\n};\n\n/**\n * Creates an ObjectId from a second based number, with the rest of the ObjectId zeroed out. Used for comparisons or sorting the ObjectId.\n *\n * @method\n * @param {number} time an integer number representing a number of seconds.\n * @return {ObjectId} return the created ObjectId\n */\nObjectId.createFromTime = function createFromTime (time) {\n  var id = BinaryParser.encodeInt(time, 32, true, true) +\n    BinaryParser.encodeInt(0, 64, true, true);\n  return new ObjectId(id);\n};\n\n/**\n * Creates an ObjectId from a hex string representation of an ObjectId.\n *\n * @method\n * @param {string} hexString create a ObjectId from a passed in 24 byte hexstring.\n * @return {ObjectId} return the created ObjectId\n */\nObjectId.createFromHexString = function createFromHexString (hexString) {\n  // Throw an error if it's not a valid setup\n  if(typeof hexString === 'undefined' || hexString != null && hexString.length !== 24)\n    throw new Error('Argument passed in must be a single String of 12 bytes or a string of 24 hex characters');\n\n  var len = hexString.length;\n\n  if(len > 12*2) {\n    throw new Error('Id cannot be longer than 12 bytes');\n  }\n\n  var result = ''\n    , string\n    , number;\n\n  for (var index = 0; index < len; index += 2) {\n    string = hexString.substr(index, 2);\n    number = parseInt(string, 16);\n    result += BinaryParser.fromByte(number);\n  }\n\n  return new ObjectId(result, hexString);\n};\n\n/**\n * Checks if a value is a valid bson ObjectId\n *\n * @method\n * @return {boolean} return true if the value is a valid bson ObjectId, return false otherwise.\n */\nObjectId.isValid = function isValid(id) {\n  if(id == null) return false;\n\n  if(id != null && 'number' !== typeof id && (id.length !== 12 && id.length !== 24)) {\n    return false;\n  } else {\n    // Check specifically for hex correctness\n    if(typeof id === 'string' && id.length === 24) return checkForHexRegExp.test(id);\n    return true;\n  }\n};\n\n/*!\n * @ignore\n */\nObject.defineProperty(ObjectId.prototype, 'generationTime', {\n  enumerable: true\n  , get: function () {\n    return Math.floor(BinaryParser.decodeInt(this.id.substring(0,4), 32, true, true));\n  }\n  , set: function (value) {\n    value = BinaryParser.encodeInt(value, 32, true, true);\n\n    this.id = value + this.id.substr(4);\n    // delete this.__id;\n    this.toHexString();\n  }\n});\n\n/**\n * Expose.\n */\nmodule.exports = ObjectId;\nmodule.exports.ObjectId = ObjectId;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/node-libs-browser/~/process/browser.js */ 10)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/types/objectid.js\n ** module id = 11\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./lib/types/objectid.js?")},/*!*****************************!*\
  !*** ./lib/binaryparser.js ***!
  \*****************************/
function(module,exports){eval("'use strict';\n\n/*!\n * Binary Parser.\n * @copyright Jonas Raoni Soares Silva\n * @see http://jsfromhell.com/classes/binary-parser [v1.0]\n *\n * @see https://github.com/mongodb/js-bson/blob/master/lib/bson/binary_parser.js\n */\n\nvar maxBits = [];\nfor (var i = 0; i < 64; i++) {\n	maxBits[i] = Math.pow(2, i);\n}\n\nfunction BinaryParser (bigEndian, allowExceptions) {\n  if(!(this instanceof BinaryParser)) return new BinaryParser(bigEndian, allowExceptions);\n  \n	this.bigEndian = bigEndian;\n	this.allowExceptions = allowExceptions;\n}\n\nBinaryParser.warn = function warn (msg) {\n	if (this.allowExceptions) {\n		throw new Error(msg);\n  }\n\n	return 1;\n};\n\nBinaryParser.decodeInt = function decodeInt (data, bits, signed, forceBigEndian) {\n  var b = new this.Buffer(this.bigEndian || forceBigEndian, data)\n      , x = b.readBits(0, bits)\n      , max = maxBits[bits]; //max = Math.pow( 2, bits );\n  \n  return signed && x >= max / 2\n      ? x - max\n      : x;\n};\n\nBinaryParser.encodeInt = function encodeInt (data, bits, signed, forceBigEndian) {\n	var max = maxBits[bits];\n\n  if (data >= max || data < -(max / 2)) {\n    this.warn('encodeInt::overflow');\n    data = 0;\n  }\n\n	if (data < 0) {\n    data += max;\n  }\n\n	for (var r = []; data; r[r.length] = String.fromCharCode(data % 256), data = Math.floor(data / 256));\n\n	for (bits = -(-bits >> 3) - r.length; bits--; r[r.length] = '\\0');\n\n  return ((this.bigEndian || forceBigEndian) ? r.reverse() : r).join('');\n};\n\nBinaryParser.toSmall    = function( data ){ return this.decodeInt( data,  8, true  ); };\nBinaryParser.fromSmall  = function( data ){ return this.encodeInt( data,  8, true  ); };\nBinaryParser.toByte     = function( data ){ return this.decodeInt( data,  8, false ); };\nBinaryParser.fromByte   = function( data ){ return this.encodeInt( data,  8, false ); };\nBinaryParser.toShort    = function( data ){ return this.decodeInt( data, 16, true  ); };\nBinaryParser.fromShort  = function( data ){ return this.encodeInt( data, 16, true  ); };\nBinaryParser.toWord     = function( data ){ return this.decodeInt( data, 16, false ); };\nBinaryParser.fromWord   = function( data ){ return this.encodeInt( data, 16, false ); };\nBinaryParser.toInt      = function( data ){ return this.decodeInt( data, 32, true  ); };\nBinaryParser.fromInt    = function( data ){ return this.encodeInt( data, 32, true  ); };\nBinaryParser.toLong     = function( data ){ return this.decodeInt( data, 64, true  ); };\nBinaryParser.fromLong   = function( data ){ return this.encodeInt( data, 64, true  ); };\nBinaryParser.toDWord    = function( data ){ return this.decodeInt( data, 32, false ); };\nBinaryParser.fromDWord  = function( data ){ return this.encodeInt( data, 32, false ); };\nBinaryParser.toQWord    = function( data ){ return this.decodeInt( data, 64, true ); };\nBinaryParser.fromQWord  = function( data ){ return this.encodeInt( data, 64, true ); };\n\n/*!\n * @constructor BinaryParser buffer constructor.\n */\nfunction BinaryParserBuffer (bigEndian, buffer) {\n  this.bigEndian = bigEndian || 0;\n  this.buffer = [];\n  this.setBuffer(buffer);\n}\n\nBinaryParserBuffer.prototype.setBuffer = function setBuffer (data) {\n  var l, i, b;\n\n	if (data) {\n    i = l = data.length;\n    b = this.buffer = new Array(l);\n		for (; i; b[l - i] = data.charCodeAt(--i));\n		this.bigEndian && b.reverse();\n	}\n};\n\nBinaryParserBuffer.prototype.hasNeededBits = function hasNeededBits (neededBits) {\n	return this.buffer.length >= -(-neededBits >> 3);\n};\n\nBinaryParserBuffer.prototype.checkBuffer = function checkBuffer (neededBits) {\n	if (!this.hasNeededBits(neededBits)) {\n		throw new Error('checkBuffer::missing bytes');\n  }\n};\n\nBinaryParserBuffer.prototype.readBits = function readBits (start, length) {\n	//shl fix: Henri Torgemane ~1996 (compressed by Jonas Raoni)\n\n	function shl (a, b) {\n		for (; b--; a = ((a %= 0x7fffffff + 1) & 0x40000000) == 0x40000000 ? a * 2 : (a - 0x40000000) * 2 + 0x7fffffff + 1);\n		return a;\n	}\n\n	if (start < 0 || length <= 0) {\n		return 0;\n  }\n\n	this.checkBuffer(start + length);\n\n  var offsetLeft\n    , offsetRight = start % 8\n    , curByte = this.buffer.length - ( start >> 3 ) - 1\n    , lastByte = this.buffer.length + ( -( start + length ) >> 3 )\n    , diff = curByte - lastByte\n    , sum = ((this.buffer[ curByte ] >> offsetRight) & ((1 << (diff ? 8 - offsetRight : length)) - 1)) + (diff && (offsetLeft = (start + length) % 8) ? (this.buffer[lastByte++] & ((1 << offsetLeft) - 1)) << (diff-- << 3) - offsetRight : 0);\n\n	for(; diff; sum += shl(this.buffer[lastByte++], (diff-- << 3) - offsetRight));\n\n	return sum;\n};\n\n/*!\n * Module exports.\n */\nBinaryParser.Buffer = BinaryParserBuffer;\nexports.BinaryParser = BinaryParser;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/binaryparser.js\n ** module id = 12\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./lib/binaryparser.js?")},/*!**********************!*\
  !*** ./lib/mpath.js ***!
  \**********************/
function(module,exports){eval("'use strict';\n\n/**\n * Returns the value of object `o` at the given `path`.\n *\n * ####Example:\n *\n *     var obj = {\n *         comments: [\n *             { title: 'exciting!', _doc: { title: 'great!' }}\n *           , { title: 'number dos' }\n *         ]\n *     }\n *\n *     mpath.get('comments.0.title', o)         // 'exciting!'\n *     mpath.get('comments.0.title', o, '_doc') // 'great!'\n *     mpath.get('comments.title', o)           // ['exciting!', 'number dos']\n *\n *     // summary\n *     mpath.get(path, o)\n *     mpath.get(path, o, special)\n *     mpath.get(path, o, map)\n *     mpath.get(path, o, special, map)\n *\n * @param {String} path\n * @param {Object} o\n * @param {String} [special] When this property name is present on any object in the path, walking will continue on the value of this property.\n * @param {Function} [map] Optional function which receives each individual found value. The value returned from `map` is used in the original values place.\n */\nexports.get = function (path, o, special, map) {\n  var lookup;\n\n  if ('function' === typeof special) {\n    if (special.length < 2) {\n      map = special;\n      special = undefined;\n    } else {\n      lookup = special;\n      special = undefined;\n    }\n  }\n\n  map || (map = K);\n\n  var parts = 'string' === typeof path\n    ? path.split('.')\n    : path;\n\n  if (!Array.isArray(parts)) {\n    throw new TypeError('Invalid `path`. Must be either string or array');\n  }\n\n  var obj = o\n    , part;\n\n  for (var i = 0; i < parts.length; ++i) {\n    part = parts[i];\n\n    if (Array.isArray(obj) && !/^\\d+$/.test(part)) {\n      // reading a property from the array items\n      var paths = parts.slice(i);\n\n      return obj.map(function (item) {\n        return item\n          ? exports.get(paths, item, special || lookup, map)\n          : map(undefined);\n      });\n    }\n\n    if (lookup) {\n      obj = lookup(obj, part);\n    } else {\n      obj = special && obj[special]\n        ? obj[special][part]\n        : obj[part];\n    }\n\n    if (!obj) return map(obj);\n  }\n\n  return map(obj);\n};\n\n/**\n * Sets the `val` at the given `path` of object `o`.\n *\n * @param {String} path\n * @param {*} val\n * @param {Object} o\n * @param {String} [special] When this property name is present on any object in the path, walking will continue on the value of this property.\n * @param {Function} [map] Optional function which is passed each individual value before setting it. The value returned from `map` is used in the original values place.\n */\nexports.set = function (path, val, o, special, map, _copying) {\n  var lookup;\n\n  if ('function' === typeof special) {\n    if (special.length < 2) {\n      map = special;\n      special = undefined;\n    } else {\n      lookup = special;\n      special = undefined;\n    }\n  }\n\n  map || (map = K);\n\n  var parts = 'string' === typeof path\n    ? path.split('.')\n    : path;\n\n  if (!Array.isArray(parts)) {\n    throw new TypeError('Invalid `path`. Must be either string or array');\n  }\n\n  if (null == o) return;\n\n  // the existance of $ in a path tells us if the user desires\n  // the copying of an array instead of setting each value of\n  // the array to the one by one to matching positions of the\n  // current array.\n  var copy = _copying || /\\$/.test(path)\n    , obj = o\n    , part;\n\n  for (var i = 0, len = parts.length - 1; i < len; ++i) {\n    part = parts[i];\n\n    if ('$' === part) {\n      if (i == len - 1) {\n        break;\n      } else {\n        continue;\n      }\n    }\n\n    if (Array.isArray(obj) && !/^\\d+$/.test(part)) {\n      var paths = parts.slice(i);\n      if (!copy && Array.isArray(val)) {\n        for (var j = 0; j < obj.length && j < val.length; ++j) {\n          // assignment of single values of array\n          exports.set(paths, val[j], obj[j], special || lookup, map, copy);\n        }\n      } else {\n        for (var j = 0; j < obj.length; ++j) {\n          // assignment of entire value\n          exports.set(paths, val, obj[j], special || lookup, map, copy);\n        }\n      }\n      return;\n    }\n\n    if (lookup) {\n      obj = lookup(obj, part);\n    } else {\n      obj = special && obj[special]\n        ? obj[special][part]\n        : obj[part];\n    }\n\n    if (!obj) return;\n  }\n\n  // process the last property of the path\n\n  part = parts[len];\n\n  // use the special property if exists\n  if (special && obj[special]) {\n    obj = obj[special];\n  }\n\n  // set the value on the last branch\n  if (Array.isArray(obj) && !/^\\d+$/.test(part)) {\n    if (!copy && Array.isArray(val)) {\n      for (var item, j = 0; j < obj.length && j < val.length; ++j) {\n        item = obj[j];\n        if (item) {\n          if (lookup) {\n            lookup(item, part, map(val[j]));\n          } else {\n            if (item[special]) item = item[special];\n            item[part] = map(val[j]);\n          }\n        }\n      }\n    } else {\n      for (var j = 0; j < obj.length; ++j) {\n        item = obj[j];\n        if (item) {\n          if (lookup) {\n            lookup(item, part, map(val));\n          } else {\n            if (item[special]) item = item[special];\n            item[part] = map(val);\n          }\n        }\n      }\n    }\n  } else {\n    if (lookup) {\n      lookup(obj, part, map(val));\n    } else {\n      obj[part] = map(val);\n    }\n  }\n};\n\n/*!\n * Returns the value passed to it.\n */\nfunction K (v) {\n  return v;\n}\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/mpath.js\n ** module id = 13\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./lib/mpath.js?")},/*!*************************!*\
  !*** ./lib/document.js ***!
  \*************************/
function(module,exports,__webpack_require__){eval("'use strict';\n\n/*!\n * Module dependencies.\n */\n\nvar Events = __webpack_require__(/*! ./events */ 7)\n  , StorageError = __webpack_require__(/*! ./error */ 15)\n  , MixedSchema = __webpack_require__(/*! ./schema/mixed */ 21)\n  , ObjectId = __webpack_require__(/*! ./types/objectid */ 11)\n  , Schema = __webpack_require__(/*! ./schema */ 6)\n  , ValidatorError = __webpack_require__(/*! ./schematype */ 22).ValidatorError\n  , Deferred = __webpack_require__(/*! ./deferred */ 23)\n  , utils = __webpack_require__(/*! ./utils */ 9)\n  , clone = utils.clone\n  , ValidationError = StorageError.ValidationError\n  , InternalCache = __webpack_require__(/*! ./internal */ 24)\n  , deepEqual = utils.deepEqual\n  , DocumentArray\n  , SchemaArray\n  , Embedded;\n\n/**\n * Конструктор документа.\n *\n * @param {object} data - значения, которые нужно установить\n * @param {string|undefined} [collectionName] - коллекция в которой будет находится документ\n * @param {Schema} schema - схема по которой будет создан документ\n * @param {object} [fields] - выбранные поля в документе (не реализовано)\n * @param {Boolean} [init] - hydrate document - наполнить документ данными (используется в api-client)\n * @constructor\n */\nfunction Document ( data, collectionName, schema, fields, init ){\n  if ( !(this instanceof Document) ) {\n    return new Document( data, collectionName, schema, fields, init );\n  }\n\n  this.$__ = new InternalCache();\n  this.isNew = true;\n\n  // Создать пустой документ с флагом init\n  // new TestDocument(true);\n  if ( 'boolean' === typeof data ){\n    init = data;\n    data = null;\n  }\n\n  if ( collectionName instanceof Schema ){\n    schema = collectionName;\n    collectionName = undefined;\n  }\n\n  if ( _.isObject( schema ) && !( schema instanceof Schema )) {\n    schema = new Schema( schema );\n  }\n\n  // Создать пустой документ по схеме\n  if ( data instanceof Schema ){\n    schema = data;\n    data = null;\n\n    if ( schema.options._id ){\n      data = { _id: new ObjectId() };\n    }\n\n  } else {\n    // При создании EmbeddedDocument, в нём уже есть схема и ему не нужен _id\n    schema = this.schema || schema;\n    // Сгенерировать ObjectId, если он отсутствует, но его требует схема\n    if ( schema && !this.schema && schema.options._id ){\n      data = data || {};\n\n      if ( data._id === undefined ){\n        data._id = new ObjectId();\n      }\n    }\n  }\n\n  if ( !schema ){\n    throw new StorageError.MissingSchemaError();\n  }\n\n  // Создать документ с флагом init\n  // new TestDocument({ test: 'boom' }, true);\n  if ( 'boolean' === typeof collectionName ){\n    init = collectionName;\n    collectionName = undefined;\n  }\n\n  // Создать документ с strict: true\n  // collection.add({...}, true);\n  if ('boolean' === typeof fields) {\n    this.$__.strictMode = fields;\n    fields = undefined;\n  } else {\n    this.$__.strictMode = schema.options && schema.options.strict;\n    this.$__.selected = fields;\n  }\n\n  this.schema = schema;\n\n  if ( collectionName ){\n    this.collection = window.storage[ collectionName ];\n    this.collectionName = collectionName;\n  }\n\n  var required = schema.requiredPaths();\n  for (var i = 0; i < required.length; ++i) {\n    this.$__.activePaths.require( required[i] );\n  }\n\n  this.$__setSchema( schema );\n\n  this._doc = this.$__buildDoc( data, init );\n\n  if ( init ){\n    this.init( data );\n  } else if ( data ) {\n    this.set( data, undefined, true );\n  }\n\n  // m-gh-2439\n  // define getters for data.prop properties with non-strict schemas\n  if ( schema.options.strict === false && data ) {\n    var self = this\n      , keys = Object.keys( this._doc );\n\n    keys.forEach(function( key ) {\n      if (!(key in schema.tree)) {\n        defineProp( self, key, null, self );\n      }\n    });\n  }\n\n  // apply methods\n  for (var i in schema.methods) {\n    if (typeof schema.methods[i] === 'function') {\n      this[i] = schema.methods[i];\n    } else {\n      (function(_i) {\n        Object.defineProperty(this, _i, {\n          get: function() {\n            var h = {};\n            for (var k in schema.methods[_i]) {\n              h[k] = schema.methods[_i][k].bind(this);\n            }\n            return h;\n          }\n        });\n      })(i);\n    }\n  }\n\n  // apply statics\n  for (var i in schema.statics) {\n    // use defineProperty so that static props can't be overwritten\n    Object.defineProperty(this, i, {\n      value: schema.statics[i],\n      writable: false\n    });\n  }\n}\n\n/*!\n * Inherits from EventEmitter.\n */\nDocument.prototype = Object.create( Events.prototype );\nDocument.prototype.constructor = Document;\n\n/**\n * The documents schema.\n *\n * @api public\n * @property schema\n */\nDocument.prototype.schema;\n\n/**\n * Boolean flag specifying if the document is new.\n *\n * @api public\n * @property isNew\n */\nDocument.prototype.isNew;\n\n/**\n * The string version of this documents _id.\n *\n * ####Note:\n *\n * This getter exists on all documents by default. The getter can be disabled by setting the `id` [option](/docs/guide.html#id) of its `Schema` to false at construction time.\n *\n *     new Schema({ name: String }, { id: false });\n *\n * @api public\n * @see Schema options /docs/guide.html#options\n * @property id\n */\nDocument.prototype.id;\n\n/**\n * Hash containing current validation errors.\n *\n * @api public\n * @property errors\n */\nDocument.prototype.errors;\n\nDocument.prototype.adapterHooks = {\n  documentDefineProperty: _.noop,\n  documentSetInitialValue: _.noop,\n  documentGetValue: _.noop,\n  documentSetValue: _.noop\n};\n\n/**\n * Builds the default doc structure\n *\n * @param {Object} obj\n * @param {Boolean} [skipId]\n * @return {Object}\n * @api private\n * @method $__buildDoc\n * @memberOf Document\n */\nDocument.prototype.$__buildDoc = function ( obj, skipId ) {\n  var doc = {}\n    , self = this;\n\n  var paths = Object.keys( this.schema.paths )\n    , plen = paths.length\n    , ii = 0;\n\n  for ( ; ii < plen; ++ii ) {\n    var p = paths[ii];\n\n    if ( '_id' === p ) {\n      if ( skipId ) continue;\n      if ( obj && '_id' in obj ) continue;\n    }\n\n    var type = this.schema.paths[ p ];\n    var path = p.split('.');\n    var len = path.length;\n    var last = len - 1;\n    var doc_ = doc;\n    var i = 0;\n\n    for ( ; i < len; ++i ) {\n      var piece = path[ i ]\n        , defaultVal;\n\n      if ( i === last ) {\n        defaultVal = type.getDefault( self, true );\n\n        if ('undefined' !== typeof defaultVal ) {\n          doc_[ piece ] = defaultVal;\n          self.$__.activePaths.default( p );\n        }\n      } else {\n        doc_ = doc_[ piece ] || ( doc_[ piece ] = {} );\n      }\n    }\n  }\n\n  return doc;\n};\n\n/**\n * Initializes the document without setters or marking anything modified.\n *\n * Called internally after a document is returned from server.\n *\n * @param {Object} data document returned by server\n * @api private\n */\nDocument.prototype.init = function ( data ) {\n  this.isNew = false;\n\n  //todo: сдесь всё изменится, смотреть коммент метода this.populated\n  // handle docs with populated paths\n  /*!\n  if ( doc._id && opts && opts.populated && opts.populated.length ) {\n    var id = String( doc._id );\n    for (var i = 0; i < opts.populated.length; ++i) {\n      var item = opts.populated[ i ];\n      this.populated( item.path, item._docs[id], item );\n    }\n  }\n  */\n\n  init( this, data, this._doc );\n\n  return this;\n};\n\n/*!\n * Init helper.\n *\n * @param {Object} self document instance\n * @param {Object} obj raw server doc\n * @param {Object} doc object we are initializing\n * @api private\n */\nfunction init (self, obj, doc, prefix) {\n  prefix = prefix || '';\n\n  var keys = Object.keys(obj)\n    , len = keys.length\n    , schema\n    , path\n    , i;\n\n  while (len--) {\n    i = keys[len];\n    path = prefix + i;\n    schema = self.schema.path(path);\n\n    if (!schema && _.isPlainObject( obj[ i ] ) &&\n        (!obj[i].constructor || 'Object' === utils.getFunctionName(obj[i].constructor))) {\n      // assume nested object\n      if (!doc[i]) doc[i] = {};\n      init(self, obj[i], doc[i], path + '.');\n    } else {\n      if (obj[i] === null) {\n        doc[i] = null;\n      } else if (obj[i] !== undefined) {\n        if (schema) {\n          self.$__try(function(){\n            doc[i] = schema.cast(obj[i], self, true);\n          });\n        } else {\n          doc[i] = obj[i];\n        }\n\n        self.adapterHooks.documentSetInitialValue.call( self, self, path, doc[i] );\n      }\n      // mark as hydrated\n      if (!self.isModified(path)) {\n        self.$__.activePaths.init(path);\n      }\n    }\n  }\n}\n\n/**\n * Sets the value of a path, or many paths.\n *\n * ####Example:\n *\n *     // path, value\n *     doc.set(path, value)\n *\n *     // object\n *     doc.set({\n *         path  : value\n *       , path2 : {\n *            path  : value\n *         }\n *     })\n *\n *     // only-the-fly cast to number\n *     doc.set(path, value, Number)\n *\n *     // only-the-fly cast to string\n *     doc.set(path, value, String)\n *\n *     // changing strict mode behavior\n *     doc.set(path, value, { strict: false });\n *\n * @param {String|Object} path path or object of key/vals to set\n * @param {Mixed} val the value to set\n * @param {Schema|String|Number|etc..} [type] optionally specify a type for \"on-the-fly\" attributes\n * @param {Object} [options] optionally specify options that modify the behavior of the set\n * @api public\n */\nDocument.prototype.set = function (path, val, type, options) {\n  if (type && 'Object' === utils.getFunctionName(type.constructor)) {\n    options = type;\n    type = undefined;\n  }\n\n  var merge = options && options.merge\n    , adhoc = type && true !== type\n    , constructing = true === type\n    , adhocs;\n\n  var strict = options && 'strict' in options\n    ? options.strict\n    : this.$__.strictMode;\n\n  if (adhoc) {\n    adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});\n    adhocs[path] = Schema.interpretAsType(path, type);\n  }\n\n  if ('string' !== typeof path) {\n    // new Document({ key: val })\n\n    if (null === path || undefined === path) {\n      var _temp = path;\n      path = val;\n      val = _temp;\n\n    } else {\n      var prefix = val\n        ? val + '.'\n        : '';\n\n      if (path instanceof Document) path = path._doc;\n\n      var keys = Object.keys(path)\n        , i = keys.length\n        , pathtype\n        , key;\n\n\n      while (i--) {\n        key = keys[i];\n        var pathName = prefix + key;\n        pathtype = this.schema.pathType(pathName);\n\n        if (null != path[key]\n            // need to know if plain object - no Buffer, ObjectId, ref, etc\n            && _.isPlainObject(path[key])\n            && ( !path[key].constructor || 'Object' === utils.getFunctionName(path[key].constructor) )\n            && 'virtual' !== pathtype\n            && !(this.$__path(pathName) instanceof MixedSchema)\n            && !(this.schema.paths[pathName] && this.schema.paths[pathName].options.ref)) {\n\n          this.set(path[key], pathName, constructing);\n\n        } else if (strict) {\n          if ('real' === pathtype || 'virtual' === pathtype) {\n            this.set(prefix + key, path[key], constructing);\n\n          } else if ('throw' === strict) {\n            throw new Error('Field `' + key + '` is not in schema.');\n          }\n\n        } else if (undefined !== path[key]) {\n          this.set(prefix + key, path[key], constructing);\n        }\n      }\n\n      return this;\n    }\n  }\n\n  // ensure _strict is honored for obj props\n  // docschema = new Schema({ path: { nest: 'string' }})\n  // doc.set('path', obj);\n  var pathType = this.schema.pathType(path);\n  if ('nested' === pathType && val && _.isPlainObject(val) &&\n      (!val.constructor || 'Object' === utils.getFunctionName(val.constructor))) {\n    if (!merge) this.setValue(path, null);\n    this.set(val, path, constructing);\n    return this;\n  }\n\n  var schema;\n  var parts = path.split('.');\n  var subpath;\n\n  if ('adhocOrUndefined' === pathType && strict) {\n\n    // check for roots that are Mixed types\n    var mixed;\n\n    for (var i = 0; i < parts.length; ++i) {\n      subpath = parts.slice(0, i+1).join('.');\n      schema = this.schema.path(subpath);\n      if (schema instanceof MixedSchema) {\n        // allow changes to sub paths of mixed types\n        mixed = true;\n        break;\n      }\n    }\n\n    if (!mixed) {\n      if ('throw' === strict) {\n        throw new Error('Field `' + path + '` is not in schema.');\n      }\n      return this;\n    }\n\n  } else if ('virtual' === pathType) {\n    schema = this.schema.virtualpath(path);\n    schema.applySetters(val, this);\n    return this;\n  } else {\n    schema = this.$__path(path);\n  }\n\n  var pathToMark;\n\n  // When using the $set operator the path to the field must already exist.\n  // Else mongodb throws: \"LEFT_SUBFIELD only supports Object\"\n\n  if (parts.length <= 1) {\n    pathToMark = path;\n  } else {\n    for ( i = 0; i < parts.length; ++i ) {\n      subpath = parts.slice(0, i + 1).join('.');\n      if (this.isDirectModified(subpath) // earlier prefixes that are already\n                                         // marked as dirty have precedence\n          || this.get(subpath) === null) {\n        pathToMark = subpath;\n        break;\n      }\n    }\n\n    if (!pathToMark) pathToMark = path;\n  }\n\n  // if this doc is being constructed we should not trigger getters\n  var priorVal = constructing\n    ? undefined\n    : this.getValue(path);\n\n  if (!schema || undefined === val) {\n    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);\n    return this;\n  }\n\n  var shouldSet = true;\n  try {\n    // If the user is trying to set a ref path to a document with\n    // the correct model name, treat it as populated\n    if (schema.options &&\n        schema.options.ref &&\n        val instanceof Document &&\n        schema.options.ref === val.schema.name) {\n      //todo: need test (see https://github.com/Automattic/mongoose/pull/2387/files)\n      this.populated(path, val._id);\n    }\n    val = schema.applySetters(val, this, false, priorVal);\n    this.$markValid(path);\n  } catch (e) {\n    this.invalidate(path,\n        new StorageError.CastError(schema.instance, val, path));\n\n    shouldSet = false;\n  }\n\n  if (shouldSet) {\n    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);\n  }\n\n  return this;\n};\n\n/**\n * Determine if we should mark this change as modified.\n *\n * @return {Boolean}\n * @api private\n * @method $__shouldModify\n * @memberOf Document\n */\nDocument.prototype.$__shouldModify = function (\n    pathToMark, path, constructing, parts, schema, val, priorVal) {\n\n  if (this.isNew) return true;\n\n  if ( undefined === val && !this.isSelected(path) ) {\n    // when a path is not selected in a query, its initial\n    // value will be undefined.\n    return true;\n  }\n\n  if (undefined === val && path in this.$__.activePaths.states.default) {\n    // we're just unsetting the default value which was never saved\n    return false;\n  }\n\n  if (!utils.deepEqual(val, priorVal || this.get(path))) {\n    return true;\n  }\n\n  //тест не проходит из-за наличия лишнего поля в states.default (comments)\n  // На самом деле поле вроде и не лишнее\n  //console.info( path, path in this.$__.activePaths.states.default );\n  //console.log( this.$__.activePaths );\n\n  // Когда мы устанавливаем такое же значение как default\n  // Не понятно зачем мангуст его обновлял\n  /*!\n  if (!constructing &&\n      null != val &&\n      path in this.$__.activePaths.states.default &&\n      utils.deepEqual(val, schema.getDefault(this, constructing)) ) {\n\n    //console.log( pathToMark, this.$__.activePaths.states.modify );\n\n    // a path with a default was $unset on the server\n    // and the user is setting it to the same value again\n    return true;\n  }\n  */\n\n  return false;\n};\n\n/**\n * Handles the actual setting of the value and marking the path modified if appropriate.\n *\n * @api private\n * @method $__set\n * @memberOf Document\n */\nDocument.prototype.$__set = function ( pathToMark, path, constructing, parts, schema, val, priorVal ) {\n  var shouldModify = this.$__shouldModify.apply(this, arguments);\n\n  if (shouldModify) {\n    this.markModified(pathToMark, val);\n  }\n\n  var obj = this._doc\n    , i = 0\n    , l = parts.length;\n\n  for (; i < l; i++) {\n    var next = i + 1\n      , last = next === l;\n\n    if ( last ) {\n      obj[parts[i]] = val;\n\n      this.adapterHooks.documentSetValue.call( this, this, path, val );\n\n    } else {\n      if (obj[parts[i]] && 'Object' === utils.getFunctionName(obj[parts[i]].constructor)) {\n        obj = obj[parts[i]];\n\n      } else if (obj[parts[i]] && 'EmbeddedDocument' === utils.getFunctionName(obj[parts[i]].constructor) ) {\n        obj = obj[parts[i]];\n\n      } else if (obj[parts[i]] && Array.isArray(obj[parts[i]])) {\n        obj = obj[parts[i]];\n\n      } else {\n        obj = obj[parts[i]] = {};\n      }\n    }\n  }\n};\n\n/**\n * Gets a raw value from a path (no getters)\n *\n * @param {String} path\n * @api private\n */\nDocument.prototype.getValue = function (path) {\n  return utils.getValue(path, this._doc);\n};\n\n/**\n * Sets a raw value for a path (no casting, setters, transformations)\n *\n * @param {String} path\n * @param {Object} value\n * @api private\n */\nDocument.prototype.setValue = function (path, value) {\n  utils.setValue(path, value, this._doc);\n  return this;\n};\n\n/**\n * Returns the value of a path.\n *\n * ####Example\n *\n *     // path\n *     doc.get('age') // 47\n *\n *     // dynamic casting to a string\n *     doc.get('age', String) // \"47\"\n *\n * @param {String} path\n * @param {Schema|String|Number} [type] optionally specify a type for on-the-fly attributes\n * @api public\n */\nDocument.prototype.get = function (path, type) {\n  var adhocs;\n  if (type) {\n    adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});\n    adhocs[path] = Schema.interpretAsType(path, type);\n  }\n\n  var schema = this.$__path(path) || this.schema.virtualpath(path)\n    , pieces = path.split('.')\n    , obj = this._doc;\n\n  for (var i = 0, l = pieces.length; i < l; i++) {\n    obj = undefined === obj || null === obj\n      ? undefined\n      : obj[pieces[i]];\n  }\n\n  if (schema) {\n    obj = schema.applyGetters(obj, this);\n  }\n\n  this.adapterHooks.documentGetValue.call( this, this, path );\n\n  return obj;\n};\n\n/**\n * Returns the schematype for the given `path`.\n *\n * @param {String} path\n * @api private\n * @method $__path\n * @memberOf Document\n */\nDocument.prototype.$__path = function (path) {\n  var adhocs = this.$__.adhocPaths\n    , adhocType = adhocs && adhocs[path];\n\n  if (adhocType) {\n    return adhocType;\n  } else {\n    return this.schema.path(path);\n  }\n};\n\n\n/**\n * Marks the path as having pending changes to write to the db.\n *\n * _Very helpful when using [Mixed](./schematypes.html#mixed) types._\n *\n * ####Example:\n *\n *     doc.mixed.type = 'changed';\n *     doc.markModified('mixed.type');\n *     doc.save() // changes to mixed.type are now persisted\n *\n * @param {String} path the path to mark modified\n * @api public\n */\nDocument.prototype.markModified = function (path) {\n  this.$__.activePaths.modify(path);\n};\n\n\n/**\n * Catches errors that occur during execution of `fn` and stores them to later be passed when `save()` is executed.\n *\n * @param {Function} fn function to execute\n * @param {Object} [scope] the scope with which to call fn\n * @api private\n * @method $__try\n * @memberOf Document\n */\nDocument.prototype.$__try = function (fn, scope) {\n  var res;\n  try {\n    fn.call(scope);\n    res = true;\n  } catch (e) {\n    this.$__error(e);\n    res = false;\n  }\n  return res;\n};\n\n\n/**\n * Returns the list of paths that have been modified.\n *\n * @return {Array}\n * @api public\n */\nDocument.prototype.modifiedPaths = function () {\n  var directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);\n\n  return directModifiedPaths.reduce(function (list, path) {\n    var parts = path.split('.');\n    return list.concat(parts.reduce(function (chains, part, i) {\n      return chains.concat(parts.slice(0, i).concat(part).join('.'));\n    }, []));\n  }, []);\n};\n\n/**\n * Returns true if this document was modified, else false.\n *\n * If `path` is given, checks if a path or any full path containing `path` as part of its path chain has been modified.\n *\n * ####Example\n *\n *     doc.set('documents.0.title', 'changed');\n *     doc.isModified()                    // true\n *     doc.isModified('documents')         // true\n *     doc.isModified('documents.0.title') // true\n *     doc.isDirectModified('documents')   // false\n *\n * @param {String} [path] optional\n * @return {Boolean}\n * @api public\n */\nDocument.prototype.isModified = function (path) {\n  return path\n    ? !!~this.modifiedPaths().indexOf(path)\n    : this.$__.activePaths.some('modify');\n};\n\n\n/**\n * Returns true if `path` was directly set and modified, else false.\n *\n * ####Example\n *\n *     doc.set('documents.0.title', 'changed');\n *     doc.isDirectModified('documents.0.title') // true\n *     doc.isDirectModified('documents') // false\n *\n * @param {String} path\n * @return {Boolean}\n * @api public\n */\nDocument.prototype.isDirectModified = function (path) {\n  return (path in this.$__.activePaths.states.modify);\n};\n\n/**\n * Checks if `path` was initialized.\n *\n * @param {String} path\n * @return {Boolean}\n * @api public\n */\nDocument.prototype.isInit = function (path) {\n  return (path in this.$__.activePaths.states.init);\n};\n\n\n/**\n * Checks if `path` was selected in the source query which initialized this document.\n *\n * ####Example\n *\n *     Thing.findOne().select('name').exec(function (err, doc) {\n *        doc.isSelected('name') // true\n *        doc.isSelected('age')  // false\n *     })\n *\n * @param {String} path\n * @return {Boolean}\n * @api public\n */\nDocument.prototype.isSelected = function isSelected (path) {\n  if (this.$__.selected) {\n\n    if ('_id' === path) {\n      return 0 !== this.$__.selected._id;\n    }\n\n    var paths = Object.keys(this.$__.selected)\n      , i = paths.length\n      , inclusive = false\n      , cur;\n\n    if (1 === i && '_id' === paths[0]) {\n      // only _id was selected.\n      return 0 === this.$__.selected._id;\n    }\n\n    while (i--) {\n      cur = paths[i];\n      if ('_id' === cur) continue;\n      inclusive = !! this.$__.selected[cur];\n      break;\n    }\n\n    if (path in this.$__.selected) {\n      return inclusive;\n    }\n\n    i = paths.length;\n    var pathDot = path + '.';\n\n    while (i--) {\n      cur = paths[i];\n      if ('_id' === cur) continue;\n\n      if (0 === cur.indexOf(pathDot)) {\n        return inclusive;\n      }\n\n      if (0 === pathDot.indexOf(cur + '.')) {\n        return inclusive;\n      }\n    }\n\n    return ! inclusive;\n  }\n\n  return true;\n};\n\n\n/**\n * Executes registered validation rules for this document.\n *\n * ####Note:\n *\n * This method is called `pre` save and if a validation rule is violated, [save](#model_Model-save) is aborted and the error is returned to your `callback`.\n *\n * ####Example:\n *\n *     doc.validate(function (err) {\n *       if (err) handleError(err);\n *       else // validation passed\n *     });\n *\n * @param {Function} cb called after validation completes, passing an error if one occurred\n * @api public\n */\nDocument.prototype.validate = function (cb) {\n  var self = this;\n\n  // only validate required fields when necessary\n  var paths = Object.keys(this.$__.activePaths.states.require).filter(function (path) {\n    if (!self.isSelected(path) && !self.isModified(path)) return false;\n    return true;\n  });\n\n  paths = paths.concat(Object.keys(this.$__.activePaths.states.init));\n  paths = paths.concat(Object.keys(this.$__.activePaths.states.modify));\n  paths = paths.concat(Object.keys(this.$__.activePaths.states.default));\n\n  if (0 === paths.length) {\n    complete();\n    return this;\n  }\n\n  var validating = {}\n    , total = 0;\n\n  paths.forEach(validatePath);\n  return this;\n\n  function validatePath (path) {\n    if (validating[path]) return;\n\n    validating[path] = true;\n    total++;\n\n    utils.setImmediate(function(){\n      var p = self.schema.path(path);\n      if (!p) return --total || complete();\n\n      var val = self.getValue(path);\n      p.doValidate(val, function (err) {\n        if (err) {\n          self.invalidate(\n              path\n            , err\n            , undefined\n            //, true // embedded docs\n            );\n        }\n        --total || complete();\n      }, self);\n    });\n  }\n\n  function complete () {\n    var err = self.$__.validationError;\n    self.$__.validationError = undefined;\n    cb && cb(err);\n  }\n};\n\n\n/**\n * Executes registered validation rules (skipping asynchronous validators) for this document.\n *\n * ####Note:\n *\n * This method is useful if you need synchronous validation.\n *\n * ####Example:\n *\n *     var err = doc.validateSync();\n *     if ( err ){\n *       handleError( err );\n *     } else {\n *       // validation passed\n *     }\n *\n * @return {StorageError|undefined} StorageError if there are errors during validation, or undefined if there is no error.\n * @api public\n */\nDocument.prototype.validateSync = function () {\n  var self = this;\n\n  // only validate required fields when necessary\n  var paths = Object.keys(this.$__.activePaths.states.require).filter(function (path) {\n    if (!self.isSelected(path) && !self.isModified(path)) return false;\n    return true;\n  });\n\n  paths = paths.concat(Object.keys(this.$__.activePaths.states.init));\n  paths = paths.concat(Object.keys(this.$__.activePaths.states.modify));\n  paths = paths.concat(Object.keys(this.$__.activePaths.states.default));\n\n  var validating = {};\n\n  paths.forEach(function (path) {\n    if (validating[path]) return;\n\n    validating[path] = true;\n\n    var p = self.schema.path(path);\n    if (!p) return;\n    if (!self.$isValid(path)) {\n      return;\n    }\n\n    var val = self.getValue(path);\n    var err = p.doValidateSync(val, self);\n    if (err) {\n      self.invalidate(path, err, undefined);\n    }\n  });\n\n  var err = self.$__.validationError;\n  self.$__.validationError = undefined;\n  //self.emit('validate', self);\n\n  if (err) {\n    for (var key in err.errors) {\n      // Make sure cast errors persist\n      if (err.errors[key] instanceof StorageError.CastError) {\n        self.invalidate(key, err.errors[key]);\n      }\n    }\n  }\n\n  return err;\n};\n\n\n/**\n * Marks a path as invalid, causing validation to fail.\n *\n * The `errorMsg` argument will become the message of the `ValidationError`.\n *\n * The `value` argument (if passed) will be available through the `ValidationError.value` property.\n *\n *     doc.invalidate('size', 'must be less than 20', 14);\n\n *     doc.validate(function (err) {\n *       console.log(err)\n *       // prints\n *       { message: 'Validation failed',\n *         name: 'ValidationError',\n *         errors:\n *          { size:\n *             { message: 'must be less than 20',\n *               name: 'ValidatorError',\n *               path: 'size',\n *               type: 'user defined',\n *               value: 14 } } }\n *     })\n *\n * @param {String} path the field to invalidate\n * @param {String|StorageError|Error} errorMsg the error which states the reason `path` was invalid\n * @param {Object|String|Number|any} value optional invalid value\n * @api public\n */\nDocument.prototype.invalidate = function (path, errorMsg, value) {\n  if (!this.$__.validationError) {\n    this.$__.validationError = new ValidationError(this);\n  }\n\n  if (this.$__.validationError.errors[path]) return;\n\n  if (!errorMsg || 'string' === typeof errorMsg) {\n    errorMsg = new ValidatorError({\n      path: path,\n      message: errorMsg,\n      type: 'user defined',\n      value: value\n    });\n  }\n\n  if (this.$__.validationError == errorMsg) return;\n\n  this.$__.validationError.errors[path] = errorMsg;\n};\n\n\n/**\n * Marks a path as valid, removing existing validation errors.\n *\n * @param {String} path the field to mark as valid\n * @api private\n * @method $markValid\n * @receiver Document\n */\nDocument.prototype.$markValid = function(path) {\n  if (!this.$__.validationError || !this.$__.validationError.errors[path]) {\n    return;\n  }\n\n  delete this.$__.validationError.errors[path];\n  if (Object.keys(this.$__.validationError.errors).length === 0) {\n    this.$__.validationError = null;\n  }\n};\n\n\n/**\n * Checks if a path is invalid\n *\n * @param {String} path the field to check\n * @method $isValid\n * @api private\n * @receiver Document\n */\nDocument.prototype.$isValid = function(path) {\n  return !this.$__.validationError || !this.$__.validationError.errors[path];\n};\n\n\n/**\n * Resets the internal modified state of this document.\n *\n * @api private\n * @return {Document}\n * @method $__reset\n * @memberOf Document\n */\nDocument.prototype.$__reset = function reset () {\n  var self = this;\n\n  this.$__.activePaths\n  .map('init', 'modify', function (i) {\n    return self.getValue(i);\n  })\n  .filter(function (val) {\n    return val && val.isStorageDocumentArray && val.length;\n  })\n  .forEach(function (array) {\n    var i = array.length;\n    while (i--) {\n      var doc = array[i];\n      if (!doc) continue;\n      doc.$__reset();\n    }\n  });\n\n  // Clear 'modify'('dirty') cache\n  this.$__.activePaths.clear('modify');\n  this.$__.validationError = undefined;\n  this.errors = undefined;\n  //console.log( self.$__.activePaths.states.require );\n  //TODO: тут\n  this.schema.requiredPaths().forEach(function (path) {\n    self.$__.activePaths.require(path);\n  });\n\n  return this;\n};\n\n\n/**\n * Returns this documents dirty paths / vals.\n *\n * @api private\n * @method $__dirty\n * @memberOf Document\n */\n\nDocument.prototype.$__dirty = function () {\n  var self = this;\n\n  var all = this.$__.activePaths.map('modify', function (path) {\n    return { path: path\n           , value: self.getValue( path )\n           , schema: self.$__path( path ) };\n  });\n\n  // Sort dirty paths in a flat hierarchy.\n  all.sort(function (a, b) {\n    return (a.path < b.path ? -1 : (a.path > b.path ? 1 : 0));\n  });\n\n  // Ignore \"foo.a\" if \"foo\" is dirty already.\n  var minimal = []\n    , lastPath\n    , top;\n\n  all.forEach(function( item ){\n    lastPath = item.path + '.';\n    minimal.push(item);\n    top = item;\n  });\n\n  top = lastPath = null;\n  return minimal;\n};\n\n/*!\n * Compiles schemas.\n * (установить геттеры/сеттеры на поля документа)\n */\nfunction compile (self, tree, proto, prefix) {\n  var keys = Object.keys(tree)\n    , i = keys.length\n    , limb\n    , key;\n\n  while (i--) {\n    key = keys[i];\n    limb = tree[key];\n\n    defineProp(self\n        , key\n        , (('Object' === utils.getFunctionName(limb.constructor)\n               && Object.keys(limb).length)\n               && (!limb.type || limb.type.type)\n               ? limb\n               : null)\n        , proto\n        , prefix\n        , keys);\n  }\n}\n\n// gets descriptors for all properties of `object`\n// makes all properties non-enumerable to match previous behavior to #2211\nfunction getOwnPropertyDescriptors(object) {\n  var result = {};\n\n  Object.getOwnPropertyNames(object).forEach(function(key) {\n    result[key] = Object.getOwnPropertyDescriptor(object, key);\n    result[key].enumerable = false;\n  });\n\n  return result;\n}\n\n/*!\n * Defines the accessor named prop on the incoming prototype.\n * там же, поля документа сделаем наблюдаемыми\n */\nfunction defineProp (self, prop, subprops, prototype, prefix, keys) {\n  prefix = prefix || '';\n  var path = (prefix ? prefix + '.' : '') + prop;\n\n  if (subprops) {\n    Object.defineProperty(prototype, prop, {\n        enumerable: true\n      , configurable: true\n      , get: function () {\n          if (!this.$__.getters)\n            this.$__.getters = {};\n\n          if (!this.$__.getters[path]) {\n            var nested = Object.create(Object.getPrototypeOf(this), getOwnPropertyDescriptors(this));\n\n            // save scope for nested getters/setters\n            if (!prefix) nested.$__.scope = this;\n\n            // shadow inherited getters from sub-objects so\n            // thing.nested.nested.nested... doesn't occur (gh-366)\n            var i = 0\n              , len = keys.length;\n\n            for (; i < len; ++i) {\n              // over-write the parents getter without triggering it\n              Object.defineProperty(nested, keys[i], {\n                  enumerable: false   // It doesn't show up.\n                , writable: true      // We can set it later.\n                , configurable: true  // We can Object.defineProperty again.\n                , value: undefined    // It shadows its parent.\n              });\n            }\n\n            nested.toObject = function () {\n              return this.get(path);\n            };\n\n            compile( self, subprops, nested, path );\n            this.$__.getters[path] = nested;\n          }\n\n          return this.$__.getters[path];\n        }\n      , set: function (v) {\n          if (v instanceof Document) v = v.toObject();\n          return (this.$__.scope || this).set( path, v );\n        }\n    });\n\n  } else {\n    Object.defineProperty( prototype, prop, {\n        enumerable: true\n      , configurable: true\n      , get: function ( ) { return this.get.call(this.$__.scope || this, path); }\n      , set: function (v) { return this.set.call(this.$__.scope || this, path, v); }\n    });\n  }\n\n  self.adapterHooks.documentDefineProperty.call( self, self, prototype, prop, prefix, path );\n  //self.adapterHooks.documentDefineProperty.call( self, self, path, prototype );\n}\n\n/**\n * Assigns/compiles `schema` into this documents prototype.\n *\n * @param {Schema} schema\n * @api private\n * @method $__setSchema\n * @memberOf Document\n */\nDocument.prototype.$__setSchema = function ( schema ) {\n  this.schema = schema;\n  compile( this, schema.tree, this );\n};\n\n/**\n * Get all subdocs (by bfs)\n *\n * @api private\n * @method $__getAllSubdocs\n * @memberOf Document\n */\nDocument.prototype.$__getAllSubdocs = function () {\n  DocumentArray || (DocumentArray = __webpack_require__(/*! ./types/documentarray */ 26));\n  Embedded = Embedded || __webpack_require__(/*! ./types/embedded */ 28);\n\n  function docReducer(seed, path) {\n    var val = this[path];\n    if (val instanceof Embedded) seed.push(val);\n    if (val instanceof DocumentArray){\n      val.forEach(function _docReduce(doc) {\n\n        if (!doc || !doc._doc) return;\n        if (doc instanceof Embedded) seed.push(doc);\n\n        seed = Object.keys(doc._doc).reduce(docReducer.bind(doc._doc), seed);\n      });\n    }\n    return seed;\n  }\n\n  return Object.keys(this._doc).reduce(docReducer.bind(this), []);\n};\n\n/**\n * Handle generic save stuff.\n * to solve #1446 use use hierarchy instead of hooks\n *\n * @api private\n * @method $__presaveValidate\n * @memberOf Document\n */\nDocument.prototype.$__presaveValidate = function $__presaveValidate() {\n  // if any doc.set() calls failed\n\n  var docs = this.$__getArrayPathsToValidate();\n\n  var e2 = docs.map(function (doc) {\n    return doc.$__presaveValidate();\n  });\n  var e1 = [this.$__.saveError].concat(e2);\n  var err = e1.filter(function (x) {return x})[0];\n  this.$__.saveError = null;\n\n  return err;\n};\n\n/**\n * Get active path that were changed and are arrays\n *\n * @api private\n * @method $__getArrayPathsToValidate\n * @memberOf Document\n */\nDocument.prototype.$__getArrayPathsToValidate = function () {\n  DocumentArray || (DocumentArray = __webpack_require__(/*! ./types/documentarray */ 26));\n\n  // validate all document arrays.\n  return this.$__.activePaths\n    .map('init', 'modify', function (i) {\n      return this.getValue(i);\n    }.bind(this))\n    .filter(function (val) {\n      return val && val instanceof DocumentArray && val.length;\n    }).reduce(function(seed, array) {\n      return seed.concat(array);\n    }, [])\n    .filter(function (doc) {return doc});\n};\n\n/**\n * Registers an error\n *\n * @param {Error} err\n * @api private\n * @method $__error\n * @memberOf Document\n */\nDocument.prototype.$__error = function (err) {\n  this.$__.saveError = err;\n  return this;\n};\n\n/**\n * Produces a special query document of the modified properties used in updates.\n *\n * @api private\n * @method $__delta\n * @memberOf Document\n */\nDocument.prototype.$__delta = function () {\n  var dirty = this.$__dirty();\n\n  var delta = {}\n    , len = dirty.length\n    , d = 0;\n\n  for (; d < len; ++d) {\n    var data = dirty[ d ];\n    var value = data.value;\n\n    value = utils.clone(value, { depopulate: 1 });\n    delta[ data.path ] = value;\n  }\n\n  return delta;\n};\n\nDocument.prototype.$__handleSave = function(){\n  // Получаем ресурс коллекции, куда будем сохранять данные\n  var resource;\n  if ( this.collection ){\n    resource = this.collection.api;\n  }\n\n  var innerPromise = new Deferred();\n\n  if ( this.isNew ) {\n    // send entire doc\n\n    var toObjectOptions = {};\n    if ( this.schema.options.toObject && this.schema.options.toObject.retainKeyOrder ) {\n      toObjectOptions.retainKeyOrder = true;\n    }\n\n    toObjectOptions.depopulate = 1;\n    var obj = this.toObject( toObjectOptions );\n\n    if ( ( obj || {} ).hasOwnProperty('_id') === false ) {\n      // documents must have an _id else mongoose won't know\n      // what to update later if more changes are made. the user\n      // wouldn't know what _id was generated by mongodb either\n      // nor would the ObjectId generated my mongodb necessarily\n      // match the schema definition.\n      innerPromise.reject(new Error('document must have an _id before saving'));\n      return innerPromise;\n    }\n\n    // Без ресурса можно просто делать валидацию (подготовить данные к отправке), даже если нет коллекции\n    if ( !resource ){\n      innerPromise.resolve( obj );\n    } else {\n      resource.create( obj ).always( innerPromise.resolve );\n    }\n\n    this.$__reset();\n    this.isNew = false;\n    this.trigger('isNew', false);\n    // Make it possible to retry the insert\n    this.$__.inserting = true;\n\n  } else {\n    // Make sure we don't treat it as a new object on error,\n    // since it already exists\n    this.$__.inserting = false;\n\n    var delta = this.$__delta();\n\n    if ( !_.isEmpty( delta ) ) {\n      this.$__reset();\n      // Без ресурса можно просто делать валидацию (подготовить данные к отправке), даже если нет коллекции\n      if ( !resource ){\n        innerPromise.resolve( delta );\n      } else {\n        resource( this.id ).update( delta ).always( innerPromise.resolve );\n      }\n    } else {\n      this.$__reset();\n      innerPromise.resolve( this );\n    }\n\n    this.trigger('isNew', false);\n  }\n\n  return innerPromise;\n};\n\n/**\n * @description Saves this document.\n *\n * Если апи-клиента нет и документ новый, то в колбэке будет plain object со всеми данными для сохранения на сервер.\n * Если апи-клиента нет и документ старое, то в колбэке будет plain object только с изменёнными данными.\n *\n * Если апи-клиент есть и не важно новый документ или старый, в колбэке всегда будет ответ от rest-api-client\n *\n * // todo: доописать это дело\n * Сейчас если есть ресурс (апи клиент), то:\n * если документ новый, то после ответа создастся новый документ на основе ответа, и обовляется!!! (получше объяснить это) ссылка (id) внутри коллекции\n * если документ старый, то после ответа ищется этот документ по id и делается set\n *\n *\n * @example:\n *\n *     product.sold = Date.now();\n *     product.save(function (err, product, numberAffected) {\n *       if (err) ..\n *     })\n *\n * @description The callback will receive three parameters, `err` if an error occurred, `product` which is the saved `product`, and `numberAffected` which will be 1 when the document was found and updated in the database, otherwise 0.\n *\n * The `fn` callback is optional. If no `fn` is passed and validation fails, the validation error will be emitted on the connection used to create this model.\n * @example:\n *     var schema = new Schema(..);\n *     var Product = storage.createCollection('Product', schema );\n *     var doc = Product.add();\n *\n *     // todo: реализовать это\n *     doc.on('error', handleError);\n *\n * @description As an extra measure of flow control, save will return a Promise (bound to `fn` if passed) so it could be chained, or hook to recive errors\n * @example:\n *     product.save().done(function( product ){\n *        ...\n *     }).fail(function( err ){\n *        assert.ok( err )\n *     })\n *\n * @description retainKeyOrder - keep the key order of the doc save\n * @example:\n *     var Checkin = new Schema({\n *       date: Date,\n *       location: {\n *         lat: Number,\n *         lng: Number\n *       }\n *     }, {\n *       toObject: {\n *         retainKeyOrder: true\n *       }\n *     });\n *     var Checkins = storage.createCollection('Product', schema );\n *     var doc = Checkins.add();\n *\n *     doc.save().done(function( objToSave ){\n *       // in `objToSave` followed the correct order of the keys of doc\n *     });\n *\n * @param {function( object )} [done] optional callback, object - objToSave\n * @return {Deferred} Deferred\n * @api public\n * @see middleware http://mongoosejs.com/docs/middleware.html\n */\nDocument.prototype.save = function ( done ) {\n  var self = this;\n  var finalPromise = new Deferred().done( done );\n\n  // Сохранять документ можно только если он находится в коллекции\n  if ( !this.collection ){\n    finalPromise.reject( arguments );\n    console.error('Document.save api handle is not implemented.');\n    return finalPromise;\n  }\n\n  // Check for preSave errors (точно знаю, что она проверяет ошибки в массивах (CastError))\n  var preSaveErr = self.$__presaveValidate();\n  if ( preSaveErr ) {\n    finalPromise.reject( preSaveErr );\n    return finalPromise;\n  }\n\n  // Validate\n  var p0 = new Deferred();\n  self.validate(function( err ){\n    if ( err ){\n      p0.reject( err );\n      finalPromise.reject( err );\n    } else {\n      p0.resolve();\n    }\n  });\n\n  // Сначала надо сохранить все поддокументы и сделать resolve!!!\n  // (тут псевдосохранение смотреть EmbeddedDocument.prototype.save )\n  // Call save hooks on subdocs\n  var subDocs = self.$__getAllSubdocs();\n  var whenCond = subDocs.map(function (d) {return d.save();});\n\n  whenCond.push( p0 );\n\n  // Так мы передаём массив promise условий\n  var p1 = Deferred.when.apply( Deferred, whenCond );\n\n  p1.fail(function ( err ) {\n    // If the initial insert fails provide a second chance.\n    // (If we did this all the time we would break updates)\n    if (self.$__.inserting) {\n      self.isNew = true;\n      self.emit('isNew', true);\n    }\n    finalPromise.reject( err );\n  });\n\n  // Handle save and results\n  p1.done(function(){\n    self.$__handleSave().done(function(){\n      //todo: надо проверять, нужно ли писать проверку на наличие ресурса, если он есть - отдавать self, если нет, отдавать как сейчас написано\n      // возможно и скорее всего, api и так отдаёт всё в правильном порядке (doc, meta, jqxhr)\n      finalPromise.resolve.apply( finalPromise, arguments );\n\n    }).fail(function(){\n      finalPromise.reject.apply( finalPromise, arguments );\n    });\n  });\n\n  return finalPromise;\n};\n\n\n/**\n * Converts this document into a plain javascript object, ready for storage in MongoDB.\n *\n * Buffers are converted to instances of [mongodb.Binary](http://mongodb.github.com/node-mongodb-native/api-bson-generated/binary.html) for proper storage.\n *\n * ####Options:\n *\n * - `getters` apply all getters (path and virtual getters)\n * - `virtuals` apply virtual getters (can override `getters` option)\n * - `minimize` remove empty objects (defaults to true)\n * - `transform` a transform function to apply to the resulting document before returning\n *\n * ####Getters/Virtuals\n *\n * Example of only applying path getters\n *\n *     doc.toObject({ getters: true, virtuals: false })\n *\n * Example of only applying virtual getters\n *\n *     doc.toObject({ virtuals: true })\n *\n * Example of applying both path and virtual getters\n *\n *     doc.toObject({ getters: true })\n *\n * To apply these options to every document of your schema by default, set your [schemas](#schema_Schema) `toObject` option to the same argument.\n *\n *     schema.set('toObject', { virtuals: true })\n *\n * ####Transform\n *\n * We may need to perform a transformation of the resulting object based on some criteria, say to remove some sensitive information or return a custom object. In this case we set the optional `transform` function.\n *\n * Transform functions receive three arguments\n *\n *     function (doc, ret, options) {}\n *\n * - `doc` The mongoose document which is being converted\n * - `ret` The plain object representation which has been converted\n * - `options` The options in use (either schema options or the options passed inline)\n *\n * ####Example\n *\n *     // specify the transform schema option\n *     if (!schema.options.toObject) schema.options.toObject = {};\n *     schema.options.toObject.transform = function (doc, ret, options) {\n *       // remove the _id of every document before returning the result\n *       delete ret._id;\n *     }\n *\n *     // without the transformation in the schema\n *     doc.toObject(); // { _id: 'anId', name: 'Wreck-it Ralph' }\n *\n *     // with the transformation\n *     doc.toObject(); // { name: 'Wreck-it Ralph' }\n *\n * With transformations we can do a lot more than remove properties. We can even return completely new customized objects:\n *\n *     if (!schema.options.toObject) schema.options.toObject = {};\n *     schema.options.toObject.transform = function (doc, ret, options) {\n *       return { movie: ret.name }\n *     }\n *\n *     // without the transformation in the schema\n *     doc.toObject(); // { _id: 'anId', name: 'Wreck-it Ralph' }\n *\n *     // with the transformation\n *     doc.toObject(); // { movie: 'Wreck-it Ralph' }\n *\n * _Note: if a transform function returns `undefined`, the return value will be ignored._\n *\n * Transformations may also be applied inline, overridding any transform set in the options:\n *\n *     function xform (doc, ret, options) {\n *       return { inline: ret.name, custom: true }\n *     }\n *\n *     // pass the transform as an inline option\n *     doc.toObject({ transform: xform }); // { inline: 'Wreck-it Ralph', custom: true }\n *\n * _Note: if you call `toObject` and pass any options, the transform declared in your schema options will __not__ be applied. To force its application pass `transform: true`_\n *\n *     if (!schema.options.toObject) schema.options.toObject = {};\n *     schema.options.toObject.hide = '_id';\n *     schema.options.toObject.transform = function (doc, ret, options) {\n *       if (options.hide) {\n *         options.hide.split(' ').forEach(function (prop) {\n *           delete ret[prop];\n *         });\n *       }\n *     }\n *\n *     var doc = new Doc({ _id: 'anId', secret: 47, name: 'Wreck-it Ralph' });\n *     doc.toObject();                                        // { secret: 47, name: 'Wreck-it Ralph' }\n *     doc.toObject({ hide: 'secret _id' });                  // { _id: 'anId', secret: 47, name: 'Wreck-it Ralph' }\n *     doc.toObject({ hide: 'secret _id', transform: true }); // { name: 'Wreck-it Ralph' }\n *\n * Transforms are applied to the document _and each of its sub-documents_. To determine whether or not you are currently operating on a sub-document you might use the following guard:\n *\n *     if ('function' == typeof doc.ownerDocument) {\n *       // working with a sub doc\n *     }\n *\n * Transforms, like all of these options, are also available for `toJSON`.\n *\n * See [schema options](/docs/guide.html#toObject) for some more details.\n *\n * _During save, no custom options are applied to the document before being sent to the database._\n *\n * retainKeyOrder - keep the key order of the doc save\n *\n *     var Checkin = new Schema({ ... }, {\n *       toObject: {\n *         retainKeyOrder: true\n *       }\n *     });\n *\n *     doc.toObject(); // object with correct order of the keys of doc\n *\n *     // or inline\n *\n *     doc.toObject({ retainKeyOrder: true });\n *\n *     // or if use toJSON();\n *\n *     var Checkin = new Schema({ ... }, {\n *       toJSON: {\n *         retainKeyOrder: true\n *       }\n *     });\n *\n *     doc.toJSON(); // JSON string with correct order of the keys of doc\n *\n *     // or inline\n *\n *     doc.toJSON({ retainKeyOrder: true });\n *\n * @param {Object} [options]\n * @return {Object} js object\n * @api public\n */\nDocument.prototype.toObject = function (options) {\n  if (options && options.depopulate && this.$__.wasPopulated) {\n    // populated paths that we set to a document\n    return utils.clone(this._id, options);\n  }\n\n  // When internally saving this document we always pass options,\n  // bypassing the custom schema options.\n  var optionsParameter = options;\n  if (!(options && 'Object' == utils.getFunctionName(options.constructor)) ||\n    (options && options._useSchemaOptions)) {\n    options = this.schema.options.toObject\n      ? clone(this.schema.options.toObject)\n      : {};\n  }\n\n  if ( options.minimize === undefined ){\n    options.minimize = this.schema.options.minimize;\n  }\n\n  if (!optionsParameter) {\n    options._useSchemaOptions = true;\n  }\n\n  var ret = utils.clone(this._doc, options);\n\n  if (options.virtuals || options.getters && false !== options.virtuals) {\n    applyGetters(this, ret, 'virtuals', options);\n  }\n\n  if (options.getters) {\n    applyGetters(this, ret, 'paths', options);\n    // applyGetters for paths will add nested empty objects;\n    // if minimize is set, we need to remove them.\n    if (options.minimize) {\n      ret = minimize(ret) || {};\n    }\n  }\n\n  // In the case where a subdocument has its own transform function, we need to\n  // check and see if the parent has a transform (options.transform) and if the\n  // child schema has a transform (this.schema.options.toObject) In this case,\n  // we need to adjust options.transform to be the child schema's transform and\n  // not the parent schema's\n  var transform = options.transform;\n\n  if (true === options.transform ||\n      (this.schema.options.toObject && options.transform)) {\n    var opts = options.json\n      ? this.schema.options.toJSON\n      : this.schema.options.toObject;\n    if (opts) {\n      transform = (typeof options.transform === 'function' ? options.transform : opts.transform);\n    }\n  }\n\n  if ('function' == typeof transform) {\n    var xformed = transform(this, ret, options);\n    if ('undefined' != typeof xformed) ret = xformed;\n  }\n\n  return ret;\n};\n\n/*!\n * Minimizes an object, removing undefined values and empty objects\n *\n * @param {Object} object to minimize\n * @return {Object}\n */\n\nfunction minimize (obj) {\n  var keys = Object.keys(obj)\n    , i = keys.length\n    , hasKeys\n    , key\n    , val;\n\n  while (i--) {\n    key = keys[i];\n    val = obj[key];\n\n    if ( _.isPlainObject(val) ) {\n      obj[key] = minimize(val);\n    }\n\n    if (undefined === obj[key]) {\n      delete obj[key];\n      continue;\n    }\n\n    hasKeys = true;\n  }\n\n  return hasKeys\n    ? obj\n    : undefined;\n}\n\n/*!\n * Applies virtuals properties to `json`.\n *\n * @param {Document} self\n * @param {Object} json\n * @param {String} type either `virtuals` or `paths`\n * @return {Object} `json`\n */\n\nfunction applyGetters (self, json, type, options) {\n  var schema = self.schema\n    , paths = Object.keys(schema[type])\n    , i = paths.length\n    , path;\n\n  while (i--) {\n    path = paths[i];\n\n    var parts = path.split('.')\n      , plen = parts.length\n      , last = plen - 1\n      , branch = json\n      , part;\n\n    for (var ii = 0; ii < plen; ++ii) {\n      part = parts[ii];\n      if (ii === last) {\n        branch[part] = utils.clone(self.get(path), options);\n      } else {\n        branch = branch[part] || (branch[part] = {});\n      }\n    }\n  }\n\n  return json;\n}\n\n/**\n * The return value of this method is used in calls to JSON.stringify(doc).\n *\n * This method accepts the same options as [Document#toObject](#document_Document-toObject). To apply the options to every document of your schema by default, set your [schemas](#schema_Schema) `toJSON` option to the same argument.\n *\n *     schema.set('toJSON', { virtuals: true })\n *\n * See [schema options](/docs/guide.html#toJSON) for details.\n *\n * @param {Object} options\n * @return {Object}\n * @see Document#toObject #document_Document-toObject\n * @api public\n */\n\nDocument.prototype.toJSON = function (options) {\n  // check for object type since an array of documents\n  // being stringified passes array indexes instead\n  // of options objects. JSON.stringify([doc, doc])\n  // The second check here is to make sure that populated documents (or\n  // subdocuments) use their own options for `.toJSON()` instead of their\n  // parent's\n  if (!(options && 'Object' == utils.getFunctionName(options.constructor))\n      || ((!options || options.json) && this.schema.options.toJSON)) {\n\n    options = this.schema.options.toJSON\n      ? utils.clone(this.schema.options.toJSON)\n      : {};\n  }\n  options.json = true;\n\n  return this.toObject( options );\n};\n\n/**\n * Returns true if the Document stores the same data as doc.\n *\n * Documents are considered equal when they have matching `_id`s, unless neither\n * document has an `_id`, in which case this function falls back to using\n * `deepEqual()`.\n *\n * @param {Document} doc a document to compare\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.equals = function( doc ){\n  var tid = this.get('_id');\n  var docid = doc.get('_id');\n  if (!tid && !docid) {\n    return deepEqual(this, doc);\n  }\n  return tid && tid.equals\n    ? (docid ? tid.equals(docid) : false)\n    : tid === docid;\n};\n\n/**\n * Gets _id(s) used during population of the given `path`.\n *\n * ####Example:\n *\n *     Model.findOne().populate('author').exec(function (err, doc) {\n *       console.log(doc.author.name)         // Dr.Seuss\n *       console.log(doc.populated('author')) // '5144cf8050f071d979c118a7'\n *     })\n *\n * If the path was not populated, undefined is returned.\n *\n * @param {String} path\n * @return {Array|ObjectId|Number|Buffer|String|undefined}\n * @api public\n */\nDocument.prototype.populated = function( path, val, options ){\n  // val and options are internal\n\n  //TODO: доделать эту проверку, она должна опираться не на $__.populated, а на то, что наш объект имеет родителя\n  // и потом уже выставлять свойство populated == true\n  if (null == val) {\n    if (!this.$__.populated) return undefined;\n    var v = this.$__.populated[path];\n    if (v) return v.value;\n    return undefined;\n  }\n\n  // internal\n\n  if (true === val) {\n    if (!this.$__.populated) return undefined;\n    return this.$__.populated[path];\n  }\n\n  this.$__.populated || (this.$__.populated = {});\n  this.$__.populated[path] = { value: val, options: options };\n  return val;\n};\n\n/**\n * Returns the full path to this document.\n *\n * @param {String} [path]\n * @return {String}\n * @api private\n * @method $__fullPath\n * @memberOf Document\n */\nDocument.prototype.$__fullPath = function (path) {\n  // overridden in SubDocuments\n  return path || '';\n};\n\n/**\n * Удалить документ и вернуть коллекцию.\n *\n * @example\n * document.remove();\n *\n * @see Collection.remove\n * @returns {boolean}\n */\nDocument.prototype.remove = function(){\n  if ( this.collection ){\n    return this.collection.remove( this );\n  }\n\n  return delete this;\n};\n\n\n/**\n * Очищает документ (выставляет значение по умолчанию или undefined)\n */\nDocument.prototype.empty = function(){\n  var doc = this\n    , self = this\n    , paths = Object.keys( this.schema.paths )\n    , plen = paths.length\n    , ii = 0;\n\n  for ( ; ii < plen; ++ii ) {\n    var p = paths[ii];\n\n    if ( '_id' == p ) continue;\n\n    var type = this.schema.paths[ p ]\n      , path = p.split('.')\n      , len = path.length\n      , last = len - 1\n      , doc_ = doc\n      , i = 0;\n\n    for ( ; i < len; ++i ) {\n      var piece = path[ i ]\n        , defaultVal;\n\n      if ( i === last ) {\n        defaultVal = type.getDefault( self, true );\n\n        doc_[ piece ] = defaultVal || undefined;\n        self.$__.activePaths.default( p );\n      } else {\n        doc_ = doc_[ piece ] || ( doc_[ piece ] = {} );\n      }\n    }\n  }\n};\n\n/*!\n * Module exports.\n */\n\nDocument.ValidationError = ValidationError;\nmodule.exports = Document;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/document.js\n ** module id = 14\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./lib/document.js?");
},/*!**********************!*\
  !*** ./lib/error.js ***!
  \**********************/
function(module,exports,__webpack_require__){eval("'use strict';\n\n/**\n * StorageError constructor\n *\n * @param {String} msg - Error message\n * @constructor\n * @inherits Error https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error\n * http://stackoverflow.com/questions/783818/how-do-i-create-a-custom-error-in-javascript\n */\nfunction StorageError ( msg ) {\n  this.message = msg;\n  this.name = 'StorageError';\n}\nStorageError.prototype = new Error();\n\n\n/*!\n * Module exports.\n */\nmodule.exports = StorageError;\n\n/**\n * The default built-in validator error messages.\n *\n * @see Error.messages #error_messages_StorageError-messages\n * @api public\n */\nStorageError.messages = __webpack_require__(/*! ./error/messages */ 16);\n\n/*!\n * Expose subclasses\n */\nStorageError.CastError = __webpack_require__(/*! ./error/cast */ 17);\nStorageError.ValidationError = __webpack_require__(/*! ./error/validation */ 18);\nStorageError.ValidatorError = __webpack_require__(/*! ./error/validator */ 19);\n//todo:\n//StorageError.OverwriteModelError = require('./error/overwriteModel');\nStorageError.MissingSchemaError = __webpack_require__(/*! ./error/missingSchema */ 20);\n//StorageError.DivergentArrayError = require('./error/divergentArray');\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/error.js\n ** module id = 15\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./lib/error.js?")},/*!*******************************!*\
  !*** ./lib/error/messages.js ***!
  \*******************************/
function(module,exports){eval("'use strict';\n\n/**\n * The default built-in validator error messages. These may be customized.\n *\n *     // customize within each schema or globally like so\n *     var mongoose = require('mongoose');\n *     mongoose.Error.messages.String.enum  = \"Your custom message for {PATH}.\";\n *\n * As you might have noticed, error messages support basic templating\n *\n * - `{PATH}` is replaced with the invalid document path\n * - `{VALUE}` is replaced with the invalid value\n * - `{TYPE}` is replaced with the validator type such as \"regexp\", \"min\", or \"user defined\"\n * - `{MIN}` is replaced with the declared min value for the Number.min validator\n * - `{MAX}` is replaced with the declared max value for the Number.max validator\n *\n * Click the \"show code\" link below to see all defaults.\n *\n * @property messages\n * @receiver StorageError\n * @api public\n */\n\nvar msg = module.exports = {};\n\nmsg.general = {};\nmsg.general.default = 'Validator failed for path `{PATH}` with value `{VALUE}`';\nmsg.general.required = 'Path `{PATH}` is required.';\n\nmsg.Number = {};\nmsg.Number.min = 'Path `{PATH}` ({VALUE}) is less than minimum allowed value ({MIN}).';\nmsg.Number.max = 'Path `{PATH}` ({VALUE}) is more than maximum allowed value ({MAX}).';\n\nmsg.Date = {};\nmsg.Date.min = 'Path `{PATH}` ({VALUE}) is before minimum allowed value ({MIN}).';\nmsg.Date.max = 'Path `{PATH}` ({VALUE}) is after maximum allowed value ({MAX}).';\n\nmsg.String = {};\nmsg.String.enum = '`{VALUE}` is not a valid enum value for path `{PATH}`.';\nmsg.String.match = 'Path `{PATH}` is invalid ({VALUE}).';\nmsg.String.minlength = 'Path `{PATH}` (`{VALUE}`) is shorter than the minimum allowed length ({MINLENGTH}).';\nmsg.String.maxlength = 'Path `{PATH}` (`{VALUE}`) is longer than the maximum allowed length ({MAXLENGTH}).';\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/error/messages.js\n ** module id = 16\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./lib/error/messages.js?")},/*!***************************!*\
  !*** ./lib/error/cast.js ***!
  \***************************/
function(module,exports,__webpack_require__){eval("'use strict';\n\n/*!\n * Module dependencies.\n */\n\nvar StorageError = __webpack_require__(/*! ../error.js */ 15);\n\n/**\n * Casting Error constructor.\n *\n * @constructor\n * @param {String} type\n * @param {String} value\n * @param {String} path\n * @inherits StorageError\n * @api private\n */\nfunction CastError (type, value, path) {\n  StorageError.call(this, 'Cast to ' + type + ' failed for value \"' + value + '\" at path \"' + path + '\"');\n  this.name = 'CastError';\n  this.type = type;\n  this.value = value;\n  this.path = path;\n}\n\n/*!\n * Inherits from StorageError.\n */\nCastError.prototype = Object.create( StorageError.prototype );\nCastError.prototype.constructor = CastError;\n\n/*!\n * exports\n */\n\nmodule.exports = CastError;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/error/cast.js\n ** module id = 17\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./lib/error/cast.js?")},/*!*********************************!*\
  !*** ./lib/error/validation.js ***!
  \*********************************/
function(module,exports,__webpack_require__){eval("'use strict';\n\n/*!\n * Module requirements\n */\n\nvar StorageError = __webpack_require__(/*! ../error.js */ 15);\nvar utils = __webpack_require__(/*! ../utils.js */ 9);\n\n/**\n * Document Validation Error\n *\n * @api private\n * @param {Document} instance\n * @inherits StorageError\n */\n\nfunction ValidationError (instance) {\n  StorageError.call(this, 'Validation failed');\n  this.name = 'ValidationError';\n  this.errors = instance.errors = {};\n\n  if (instance && utils.getFunctionName(instance.constructor) === 'model') {\n    //todo\n    //StorageError.call(this, instance.constructor.modelName + \" validation failed\");\n  } else {\n    StorageError.call(this, \"Validation failed\");\n  }\n\n  this.name = 'ValidationError';\n  this.errors = {};\n  if (instance) {\n    instance.errors = this.errors;\n  }\n}\n\n/*!\n * Inherits from StorageError.\n */\nValidationError.prototype = Object.create( StorageError.prototype );\nValidationError.prototype.constructor = ValidationError;\n\n/*!\n * Module exports\n */\n\nmodule.exports = ValidationError;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/error/validation.js\n ** module id = 18\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./lib/error/validation.js?")},/*!********************************!*\
  !*** ./lib/error/validator.js ***!
  \********************************/
function(module,exports,__webpack_require__){eval("'use strict';\n\n/*!\n * Module dependencies.\n */\n\nvar StorageError = __webpack_require__(/*! ../error.js */ 15);\nvar errorMessages = StorageError.messages;\n\n/**\n * Schema validator error\n *\n * @param {Object} properties\n * @inherits StorageError\n * @api private\n */\nfunction ValidatorError (properties) {\n  var msg = properties.message;\n  if (!msg) {\n    msg = errorMessages.general.default;\n  }\n\n  this.properties = properties;\n  var message = this.formatMessage(msg, properties);\n\n  StorageError.call(this, message);\n\n  this.name = 'ValidatorError';\n  this.type = properties.type;\n  this.path = properties.path;\n  this.value = properties.value;\n}\n\n\n/*!\n * Inherits from StorageError\n */\nValidatorError.prototype = Object.create( StorageError.prototype );\nValidatorError.prototype.constructor = ValidatorError;\n\n\n/*!\n * Formats error messages\n */\nValidatorError.prototype.formatMessage = function (msg, properties) {\n  var propertyNames = Object.keys(properties);\n  for (var i = 0; i < propertyNames.length; ++i) {\n    var propertyName = propertyNames[i];\n    if (propertyName === 'message') {\n      continue;\n    }\n    msg = msg.replace('{' + propertyName.toUpperCase() + '}', properties[propertyName]);\n  }\n  return msg;\n};\n\n\n/*!\n * toString helper\n */\nValidatorError.prototype.toString = function () {\n  return this.message;\n};\n\n\n/*!\n * exports\n */\nmodule.exports = ValidatorError;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/error/validator.js\n ** module id = 19\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./lib/error/validator.js?")},/*!************************************!*\
  !*** ./lib/error/missingSchema.js ***!
  \************************************/
function(module,exports,__webpack_require__){eval("'use strict';\n\n/*!\n * Module dependencies.\n */\n\nvar StorageError = __webpack_require__(/*! ../error.js */ 15);\n\n/*!\n * MissingSchema Error constructor.\n *\n * @inherits StorageError\n */\n\nfunction MissingSchemaError(){\n  var msg = 'Schema hasn\\'t been registered for document.\\n'\n    + 'Use storage.Document(data, schema)';\n  StorageError.call(this, msg);\n\n  this.name = 'MissingSchemaError';\n}\n\n/*!\n * Inherits from StorageError.\n */\n\nMissingSchemaError.prototype = Object.create(StorageError.prototype);\nMissingSchemaError.prototype.constructor = StorageError;\n\n/*!\n * exports\n */\n\nmodule.exports = MissingSchemaError;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/error/missingSchema.js\n ** module id = 20\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./lib/error/missingSchema.js?")},/*!*****************************!*\
  !*** ./lib/schema/mixed.js ***!
  \*****************************/
function(module,exports,__webpack_require__){eval("'use strict';\n\n/*!\n * Module dependencies.\n */\n\nvar SchemaType = __webpack_require__(/*! ../schematype */ 22);\n\n/**\n * Mixed SchemaType constructor.\n *\n * @param {String} path\n * @param {Object} options\n * @inherits SchemaType\n * @api private\n */\nfunction Mixed (path, options) {\n  if (options && options.default) {\n    var def = options.default;\n    if (Array.isArray(def) && 0 === def.length) {\n      // make sure empty array defaults are handled\n      options.default = Array;\n    } else if (!options.shared &&\n               _.isPlainObject(def) &&\n               0 === Object.keys(def).length) {\n      // prevent odd \"shared\" objects between documents\n      options.default = function () {\n        return {};\n      };\n    }\n  }\n\n  SchemaType.call(this, path, options);\n}\n\n/*!\n * Inherits from SchemaType.\n */\nMixed.prototype = Object.create( SchemaType.prototype );\nMixed.prototype.constructor = Mixed;\n\n/**\n * Required validator\n *\n * @api private\n */\nMixed.prototype.checkRequired = function (val) {\n  return (val !== undefined) && (val !== null);\n};\n\n/**\n * Casts `val` for Mixed.\n *\n * _this is a no-op_\n *\n * @param {Object} value to cast\n * @api private\n */\nMixed.prototype.cast = function (value) {\n  return value;\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = Mixed;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/schema/mixed.js\n ** module id = 21\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./lib/schema/mixed.js?")},/*!***************************!*\
  !*** ./lib/schematype.js ***!
  \***************************/
function(module,exports,__webpack_require__){eval("'use strict';\n\nvar error = __webpack_require__(/*! ./error */ 15)\n  , utils = __webpack_require__(/*! ./utils */ 9);\n\nvar errorMessages = error.messages;\nvar CastError = error.CastError;\nvar ValidatorError = error.ValidatorError;\n\n\n/**\n * SchemaType constructor\n *\n * @param {String} path\n * @param {Object} [options]\n * @param {String} [instance]\n * @api public\n */\nfunction SchemaType (path, options, instance) {\n  this.path = path;\n  this.instance = instance;\n  this.validators = [];\n  this.setters = [];\n  this.getters = [];\n  this.options = options;\n\n  for (var i in options) if (this[i] && 'function' === typeof this[i]) {\n    var opts = Array.isArray(options[i])\n      ? options[i]\n      : [options[i]];\n\n    this[i].apply(this, opts);\n  }\n}\n\n\n\n/**\n * Sets a default value for this SchemaType.\n *\n * ####Example:\n *\n *     var schema = new Schema({ n: { type: Number, default: 10 })\n *     var M = db.model('M', schema)\n *     var m = new M;\n *     console.log(m.n) // 10\n *\n * Defaults can be either `functions` which return the value to use as the default or the literal value itself. Either way, the value will be cast based on its schema type before being set during document creation.\n *\n * ####Example:\n *\n *     // values are cast:\n *     var schema = new Schema({ aNumber: Number, default: \"4.815162342\" })\n *     var M = db.model('M', schema)\n *     var m = new M;\n *     console.log(m.aNumber) // 4.815162342\n *\n *     // default unique objects for Mixed types:\n *     var schema = new Schema({ mixed: Schema.Types.Mixed });\n *     schema.path('mixed').default(function () {\n *       return {};\n *     });\n *\n *     // if we don't use a function to return object literals for Mixed defaults,\n *     // each document will receive a reference to the same object literal creating\n *     // a \"shared\" object instance:\n *     var schema = new Schema({ mixed: Schema.Types.Mixed });\n *     schema.path('mixed').default({});\n *     var M = db.model('M', schema);\n *     var m1 = new M;\n *     m1.mixed.added = 1;\n *     console.log(m1.mixed); // { added: 1 }\n *     var m2 = new M;\n *     console.log(m2.mixed); // { added: 1 }\n *\n * @param {Function|any} val the default value\n * @return {defaultValue}\n * @api public\n */\nSchemaType.prototype.default = function (val) {\n  if (1 === arguments.length) {\n    this.defaultValue = typeof val === 'function'\n      ? val\n      : this.cast( val );\n\n    return this;\n\n  } else if ( arguments.length > 1 ) {\n    this.defaultValue = _.toArray( arguments );\n  }\n  return this.defaultValue;\n};\n\n\n/**\n * Adds a setter to this schematype.\n *\n * ####Example:\n *\n *     function capitalize (val) {\n *       if ('string' != typeof val) val = '';\n *       return val.charAt(0).toUpperCase() + val.substring(1);\n *     }\n *\n *     // defining within the schema\n *     var s = new Schema({ name: { type: String, set: capitalize }})\n *\n *     // or by retreiving its SchemaType\n *     var s = new Schema({ name: String })\n *     s.path('name').set(capitalize)\n *\n * Setters allow you to transform the data before it gets to the raw mongodb document and is set as a value on an actual key.\n *\n * Suppose you are implementing user registration for a website. Users provide an email and password, which gets saved to mongodb. The email is a string that you will want to normalize to lower case, in order to avoid one email having more than one account -- e.g., otherwise, avenue@q.com can be registered for 2 accounts via avenue@q.com and AvEnUe@Q.CoM.\n *\n * You can set up email lower case normalization easily via a Storage setter.\n *\n *     function toLower (v) {\n *       return v.toLowerCase();\n *     }\n *\n *     var UserSchema = new Schema({\n *       email: { type: String, set: toLower }\n *     })\n *\n *     var User = db.model('User', UserSchema)\n *\n *     var user = new User({email: 'AVENUE@Q.COM'})\n *     console.log(user.email); // 'avenue@q.com'\n *\n *     // or\n *     var user = new User\n *     user.email = 'Avenue@Q.com'\n *     console.log(user.email) // 'avenue@q.com'\n *\n * As you can see above, setters allow you to transform the data before it gets to the raw mongodb document and is set as a value on an actual key.\n *\n * _NOTE: we could have also just used the built-in `lowercase: true` SchemaType option instead of defining our own function._\n *\n *     new Schema({ email: { type: String, lowercase: true }})\n *\n * Setters are also passed a second argument, the schematype on which the setter was defined. This allows for tailored behavior based on options passed in the schema.\n *\n *     function inspector (val, schematype) {\n *       if (schematype.options.required) {\n *         return schematype.path + ' is required';\n *       } else {\n *         return val;\n *       }\n *     }\n *\n *     var VirusSchema = new Schema({\n *       name: { type: String, required: true, set: inspector },\n *       taxonomy: { type: String, set: inspector }\n *     })\n *\n *     var Virus = db.model('Virus', VirusSchema);\n *     var v = new Virus({ name: 'Parvoviridae', taxonomy: 'Parvovirinae' });\n *\n *     console.log(v.name);     // name is required\n *     console.log(v.taxonomy); // Parvovirinae\n *\n * @param {Function} fn\n * @return {SchemaType} this\n * @api public\n */\nSchemaType.prototype.set = function (fn) {\n  if ('function' !== typeof fn)\n    throw new TypeError('A setter must be a function.');\n  this.setters.push(fn);\n  return this;\n};\n\n\n/**\n * Adds a getter to this schematype.\n *\n * ####Example:\n *\n *     function dob (val) {\n *       if (!val) return val;\n *       return (val.getMonth() + 1) + \"/\" + val.getDate() + \"/\" + val.getFullYear();\n *     }\n *\n *     // defining within the schema\n *     var s = new Schema({ born: { type: Date, get: dob })\n *\n *     // or by retreiving its SchemaType\n *     var s = new Schema({ born: Date })\n *     s.path('born').get(dob)\n *\n * Getters allow you to transform the representation of the data as it travels from the raw mongodb document to the value that you see.\n *\n * Suppose you are storing credit card numbers and you want to hide everything except the last 4 digits to the mongoose user. You can do so by defining a getter in the following way:\n *\n *     function obfuscate (cc) {\n *       return '****-****-****-' + cc.slice(cc.length-4, cc.length);\n *     }\n *\n *     var AccountSchema = new Schema({\n *       creditCardNumber: { type: String, get: obfuscate }\n *     });\n *\n *     var Account = db.model('Account', AccountSchema);\n *\n *     Account.findById(id, function (err, found) {\n *       console.log(found.creditCardNumber); // '****-****-****-1234'\n *     });\n *\n * Getters are also passed a second argument, the schematype on which the getter was defined. This allows for tailored behavior based on options passed in the schema.\n *\n *     function inspector (val, schematype) {\n *       if (schematype.options.required) {\n *         return schematype.path + ' is required';\n *       } else {\n *         return schematype.path + ' is not';\n *       }\n *     }\n *\n *     var VirusSchema = new Schema({\n *       name: { type: String, required: true, get: inspector },\n *       taxonomy: { type: String, get: inspector }\n *     })\n *\n *     var Virus = db.model('Virus', VirusSchema);\n *\n *     Virus.findById(id, function (err, virus) {\n *       console.log(virus.name);     // name is required\n *       console.log(virus.taxonomy); // taxonomy is not\n *     })\n *\n * @param {Function} fn\n * @return {SchemaType} this\n * @api public\n */\nSchemaType.prototype.get = function (fn) {\n  if ('function' !== typeof fn)\n    throw new TypeError('A getter must be a function.');\n  this.getters.push(fn);\n  return this;\n};\n\n\n/**\n * Adds validator(s) for this document path.\n *\n * Validators always receive the value to validate as their first argument and must return `Boolean`. Returning `false` means validation failed.\n *\n * The error message argument is optional. If not passed, the [default generic error message template](#error_messages_StorageError-messages) will be used.\n *\n * ####Examples:\n *\n *     // make sure every value is equal to \"something\"\n *     function validator (val) {\n *       return val == 'something';\n *     }\n *     new Schema({ name: { type: String, validate: validator }});\n *\n *     // with a custom error message\n *\n *     var custom = [validator, 'Uh oh, {PATH} does not equal \"something\".']\n *     new Schema({ name: { type: String, validate: custom }});\n *\n *     // adding many validators at a time\n *\n *     var many = [\n *         { validator: validator, msg: 'uh oh' }\n *       , { validator: anotherValidator, msg: 'failed' }\n *     ]\n *     new Schema({ name: { type: String, validate: many }});\n *\n *     // or utilizing SchemaType methods directly:\n *\n *     var schema = new Schema({ name: 'string' });\n *     schema.path('name').validate(validator, 'validation of `{PATH}` failed with value `{VALUE}`');\n *\n * ####Error message templates:\n *\n * From the examples above, you may have noticed that error messages support baseic templating. There are a few other template keywords besides `{PATH}` and `{VALUE}` too. To find out more, details are available [here](#error_messages_StorageError-messages)\n *\n * ####Asynchronous validation:\n *\n * Passing a validator function that receives two arguments tells mongoose that the validator is an asynchronous validator. The first argument passed to the validator function is the value being validated. The second argument is a callback function that must called when you finish validating the value and passed either `true` or `false` to communicate either success or failure respectively.\n *\n *     schema.path('name').validate(function (value, respond) {\n *       doStuff(value, function () {\n *         ...\n *         respond(false); // validation failed\n *       })\n*      }, '{PATH} failed validation.');\n*\n * You might use asynchronous validators to retreive other documents from the database to validate against or to meet other I/O bound validation needs.\n *\n * Validation occurs `pre('save')` or whenever you manually execute [document#validate](#document_Document-validate).\n *\n * If validation fails during `pre('save')` and no callback was passed to receive the error, an `error` event will be emitted on your Models associated db [connection](#connection_Connection), passing the validation error object along.\n *\n *     var conn = mongoose.createConnection(..);\n *     conn.on('error', handleError);\n *\n *     var Product = conn.model('Product', yourSchema);\n *     var dvd = new Product(..);\n *     dvd.save(); // emits error on the `conn` above\n *\n * If you desire handling these errors at the Model level, attach an `error` listener to your Model and the event will instead be emitted there.\n *\n *     // registering an error listener on the Model lets us handle errors more locally\n *     Product.on('error', handleError);\n *\n * @param {RegExp|Function|Object} obj validator\n * @param {String} [message] optional error message\n * @return {SchemaType} this\n * @api public\n */\nSchemaType.prototype.validate = function (obj, message, type) {\n  if ('function' == typeof obj || obj && 'RegExp' === utils.getFunctionName(obj.constructor)) {\n    var properties;\n    if (message instanceof Object && !type) {\n      properties = utils.clone(message);\n      if (!properties.message) {\n        properties.message = properties.msg;\n      }\n      properties.validator = obj;\n    } else {\n      if (!message) message = errorMessages.general.default;\n      if (!type) type = 'user defined';\n      properties = { message: message, type: type, validator: obj };\n    }\n    this.validators.push(properties);\n    return this;\n  }\n\n  var i;\n  var length;\n  var arg;\n\n  for (i=0, length=arguments.length; i<length; i++) {\n    arg = arguments[i];\n    if (!(arg && 'Object' === utils.getFunctionName(arg.constructor) )) {\n      var msg = 'Invalid validator. Received (' + typeof arg + ') '\n        + arg\n        + '. See http://mongoosejs.com/docs/api.html#schematype_SchemaType-validate';\n\n      throw new Error(msg);\n    }\n    this.validate(arg.validator, arg);\n  }\n\n  return this;\n};\n\n\n/**\n * Adds a required validator to this schematype.\n *\n * ####Example:\n *\n *     var s = new Schema({ born: { type: Date, required: true })\n *\n *     // or with custom error message\n *\n *     var s = new Schema({ born: { type: Date, required: '{PATH} is required!' })\n *\n *     // or through the path API\n *\n *     Schema.path('name').required(true);\n *\n *     // with custom error messaging\n *\n *     Schema.path('name').required(true, 'grrr :( ');\n *\n *\n * @param {Boolean} required enable/disable the validator\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages #error_messages_StorageError-messages\n * @api public\n */\nSchemaType.prototype.required = function (required, message) {\n  if (false === required) {\n    this.validators = this.validators.filter(function (v) {\n      return v.validator != this.requiredValidator;\n    }, this);\n\n    this.isRequired = false;\n    return this;\n  }\n\n  var self = this;\n  this.isRequired = true;\n\n  this.requiredValidator = function (v) {\n    // in here, `this` refers to the validating document.\n    // no validation when this path wasn't selected in the query.\n    if (this !== undefined && // специальная проверка из-за strict mode и особенности .call(undefined)\n        'isSelected' in this &&\n        !this.isSelected(self.path) &&\n        !this.isModified(self.path)) return true;\n\n    return (('function' === typeof required) && !required.apply(this)) ||\n      self.checkRequired(v, this);\n  };\n\n  if ('string' === typeof required) {\n    message = required;\n    required = undefined;\n  }\n\n  var msg = message || errorMessages.general.required;\n  this.validators.push({ validator: this.requiredValidator, message: msg, type: 'required' });\n\n  return this;\n};\n\n\n/**\n * Gets the default value\n *\n * @param {Object} scope the scope which callback are executed\n * @param {Boolean} init\n * @api private\n */\nSchemaType.prototype.getDefault = function (scope, init) {\n  var ret = 'function' === typeof this.defaultValue\n    ? this.defaultValue.call(scope)\n    : this.defaultValue;\n\n  if (null !== ret && undefined !== ret) {\n    return this.cast(ret, scope, init);\n  } else {\n    return ret;\n  }\n};\n\n\n/**\n * Applies setters\n *\n * @param {*} value\n * @param {Object} scope\n * @param {Boolean} init\n * @param {*} priorVal\n * @api private\n */\nSchemaType.prototype.applySetters = function (value, scope, init, priorVal) {\n  if (SchemaType._isRef( this, value )) {\n    return init\n      ? value\n      : this.cast(value, scope, init, priorVal);\n  }\n\n  var v = value\n    , setters = this.setters\n    , len = setters.length\n    , caster = this.caster;\n\n  if (Array.isArray(v) && caster && caster.setters) {\n    for (var i = 0; i < v.length; i++) {\n      v[i] = caster.applySetters(v[i], scope, init, priorVal);\n    }\n  }\n\n  if (!len) {\n    if (null === v || undefined === v) return v;\n    return this.cast(v, scope, init, priorVal);\n  }\n\n  while (len--) {\n    v = setters[len].call(scope, v, this);\n  }\n\n  if (null === v || undefined === v) return v;\n\n  // do not cast until all setters are applied #665\n  v = this.cast(v, scope, init, priorVal);\n\n  return v;\n};\n\n\n/**\n * Applies getters to a value\n *\n * @param {Object} value\n * @param {Object} scope\n * @api private\n */\nSchemaType.prototype.applyGetters = function( value, scope ){\n  if ( SchemaType._isRef( this, value ) ) return value;\n\n  var v = value\n    , getters = this.getters\n    , len = getters.length;\n\n  if ( !len ) {\n    return v;\n  }\n\n  while ( len-- ) {\n    v = getters[ len ].call(scope, v, this);\n  }\n\n  return v;\n};\n\n\n/**\n * Performs a validation of `value` using the validators declared for this SchemaType.\n *\n * @param {*} value\n * @param {Function} callback\n * @param {Object} scope\n * @api private\n */\nSchemaType.prototype.doValidate = function (value, callback, scope) {\n  var err = false\n    , path = this.path\n    , count = this.validators.length;\n\n  if (!count) return callback(null);\n\n  var validate = function validate(ok, validatorProperties) {\n    if (err) return;\n    if (ok === undefined || ok) {\n      --count || callback(null);\n    } else {\n      err = new ValidatorError(validatorProperties);\n      callback(err);\n    }\n  };\n\n  var self = this;\n  this.validators.forEach(function (v) {\n    if (err) {\n      return;\n    }\n\n    var validator = v.validator;\n    var message = v.message;\n    var type = v.type;\n\n    var validatorProperties = utils.clone(v);\n    validatorProperties.path = path;\n    validatorProperties.value = value;\n\n    if (validator instanceof RegExp) {\n      validate(validator.test(value), validatorProperties);\n    } else if ('function' === typeof validator) {\n      if (value === undefined && !self.isRequired) {\n        validate(true, validatorProperties);\n        return;\n      }\n      if (2 === validator.length) {\n        validator.call(scope, value, function (ok) {\n          validate(ok, validatorProperties);\n        });\n      } else {\n        validate(validator.call(scope, value), validatorProperties);\n      }\n    }\n  });\n};\n\n\n/**\n * Performs a validation of `value` using the validators declared for this SchemaType.\n *\n * ####Note:\n *\n * This method ignores the asynchronous validators.\n *\n * @param {any} value\n * @param {Object} scope\n * @return {StorageError|undefined}\n * @api private\n */\nSchemaType.prototype.doValidateSync = function (value, scope) {\n  var err = null\n      , path = this.path\n      , count = this.validators.length;\n\n  if (!count) return null;\n\n  var validate = function(ok, validatorProperties) {\n    if (err) return;\n    if (ok === undefined || ok) {\n\n    } else {\n      err = new ValidatorError(validatorProperties);\n    }\n  };\n\n  var self = this;\n  if (value === undefined && !self.isRequired) {\n    return null;\n  }\n\n  this.validators.forEach(function (v) {\n    if (err) {\n      return;\n    }\n\n    var validator = v.validator;\n    var validatorProperties = utils.clone(v);\n    validatorProperties.path = path;\n    validatorProperties.value = value;\n\n    if (validator instanceof RegExp) {\n      validate(validator.test(value), validatorProperties);\n    } else if ('function' === typeof validator) {\n      // if not async validators\n      if (2 !== validator.length) {\n        validate(validator.call(scope, value), validatorProperties);\n      }\n    }\n  });\n\n  return err;\n};\n\n\n/**\n * Determines if value is a valid Reference.\n *\n * На клиенте в качестве ссылки можно хранить как id, так и полные документы\n *\n * @param {SchemaType} self\n * @param {Object} value\n * @return {Boolean}\n * @api private\n */\nSchemaType._isRef = function( self, value ){\n  // fast path\n  var ref = self.options && self.options.ref;\n\n  if ( ref ) {\n    if ( null == value ) return true;\n    if ( _.isObject( value ) ) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\n//exports\nmodule.exports = SchemaType;\n\nSchemaType.CastError = CastError;\nSchemaType.ValidatorError = ValidatorError;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/schematype.js\n ** module id = 22\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./lib/schematype.js?")},/*!*************************!*\
  !*** ./lib/deferred.js ***!
  \*************************/
function(module,exports){eval("'use strict';\n\n/*\nStandalone Deferred\nCopyright 2012 Otto Vehviläinen\nReleased under MIT license\nhttps://github.com/Mumakil/Standalone-Deferred\n\nThis is a standalone implementation of the wonderful jQuery.Deferred API.\nThe documentation here is only for quick reference, for complete api please\nsee the great work of the original project:\n\nhttp://api.jquery.com/category/deferred-object/\n*/\n\nvar Promise, flatten, isObservable,\n  __slice = Array.prototype.slice,\n  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\nif (!Array.prototype.forEach) throw new Error('Deferred requires Array.forEach');\n\n/*\nTells if an object is observable\n*/\n\nisObservable = function(obj) {\n  return (obj instanceof Deferred) || (obj instanceof Promise);\n};\n\n/*\nFlatten a two dimensional array into one dimension.\nRemoves elements that are not functions\n*/\n\nflatten = function(args) {\n  var flatted;\n  if (!args) return [];\n  flatted = [];\n  args.forEach(function(item) {\n    if (item) {\n      if (typeof item === 'function') {\n        return flatted.push(item);\n      } else {\n        return args.forEach(function(fn) {\n          if (typeof fn === 'function') return flatted.push(fn);\n        });\n      }\n    }\n  });\n  return flatted;\n};\n\n/*\nPromise object functions as a proxy for a Deferred, except\nit does not let you modify the state of the Deferred\n*/\n\nPromise = (function() {\n\n  Promise.prototype._deferred = null;\n\n  function Promise(deferred) {\n    this._deferred = deferred;\n  }\n\n  Promise.prototype.always = function() {\n    var args, _ref;\n    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n    (_ref = this._deferred).always.apply(_ref, args);\n    return this;\n  };\n\n  Promise.prototype.done = function() {\n    var args, _ref;\n    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n    (_ref = this._deferred).done.apply(_ref, args);\n    return this;\n  };\n\n  Promise.prototype.fail = function() {\n    var args, _ref;\n    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n    (_ref = this._deferred).fail.apply(_ref, args);\n    return this;\n  };\n\n  Promise.prototype.pipe = function(doneFilter, failFilter) {\n    return this._deferred.pipe(doneFilter, failFilter);\n  };\n\n  Promise.prototype.state = function() {\n    return this._deferred.state();\n  };\n\n  Promise.prototype.then = function(done, fail) {\n    this._deferred.then(done, fail);\n    return this;\n  };\n\n  return Promise;\n\n})();\n\n/*\n  Initializes a new Deferred. You can pass a function as a parameter\n  to be executed immediately after init. The function receives\n  the new deferred object as a parameter and this is also set to the\n  same object.\n*/\nfunction Deferred(fn) {\n  this.then = __bind(this.then, this);\n  this.resolveWith = __bind(this.resolveWith, this);\n  this.resolve = __bind(this.resolve, this);\n  this.rejectWith = __bind(this.rejectWith, this);\n  this.reject = __bind(this.reject, this);\n  this.promise = __bind(this.promise, this);\n  this.progress = __bind(this.progress, this);\n  this.pipe = __bind(this.pipe, this);\n  this.notifyWith = __bind(this.notifyWith, this);\n  this.notify = __bind(this.notify, this);\n  this.fail = __bind(this.fail, this);\n  this.done = __bind(this.done, this);\n  this.always = __bind(this.always, this);\n  if (typeof fn === 'function') fn.call(this, this);\n\n  this._state = 'pending';\n}\n\n/*\n  Pass in functions or arrays of functions to be executed when the\n  Deferred object changes state from pending. If the state is already\n  rejected or resolved, the functions are executed immediately. They\n  receive the arguments that are passed to reject or resolve and this\n  is set to the object defined by rejectWith or resolveWith if those\n  variants are used.\n*/\n\nDeferred.prototype.always = function() {\n  var args, functions, _ref,\n    _this = this;\n  args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n  if (args.length === 0) return this;\n  functions = flatten(args);\n  if (this._state === 'pending') {\n    this._alwaysCallbacks || (this._alwaysCallbacks = []);\n    (_ref = this._alwaysCallbacks).push.apply(_ref, functions);\n  } else {\n    functions.forEach(function(fn) {\n      return fn.apply(_this._context, _this._withArguments);\n    });\n  }\n  return this;\n};\n\n/*\n  Pass in functions or arrays of functions to be executed when the\n  Deferred object is resolved. If the object has already been resolved,\n  the functions are executed immediately. If the object has been rejected,\n  nothing happens. The functions receive the arguments that are passed\n  to resolve and this is set to the object defined by resolveWith if that\n  variant is used.\n*/\n\nDeferred.prototype.done = function() {\n  var args, functions, _ref,\n    _this = this;\n  args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n  if (args.length === 0) return this;\n  functions = flatten(args);\n  if (this._state === 'resolved') {\n    functions.forEach(function(fn) {\n      return fn.apply(_this._context, _this._withArguments);\n    });\n  } else if (this._state === 'pending') {\n    this._doneCallbacks || (this._doneCallbacks = []);\n    (_ref = this._doneCallbacks).push.apply(_ref, functions);\n  }\n  return this;\n};\n\n/*\n  Pass in functions or arrays of functions to be executed when the\n  Deferred object is rejected. If the object has already been rejected,\n  the functions are executed immediately. If the object has been resolved,\n  nothing happens. The functions receive the arguments that are passed\n  to reject and this is set to the object defined by rejectWith if that\n  variant is used.\n*/\n\nDeferred.prototype.fail = function() {\n  var args, functions, _ref,\n    _this = this;\n  args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n  if (args.length === 0) return this;\n  functions = flatten(args);\n  if (this._state === 'rejected') {\n    functions.forEach(function(fn) {\n      return fn.apply(_this._context, _this._withArguments);\n    });\n  } else if (this._state === 'pending') {\n    this._failCallbacks || (this._failCallbacks = []);\n    (_ref = this._failCallbacks).push.apply(_ref, functions);\n  }\n  return this;\n};\n\n/*\n  Notify progress callbacks. The callbacks get passed the arguments given to notify.\n  If the object has resolved or rejected, nothing will happen\n*/\n\nDeferred.prototype.notify = function() {\n  var args;\n  args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n  this.notifyWith.apply(this, [window].concat(__slice.call(args)));\n  return this;\n};\n\n/*\n  Notify progress callbacks with additional context. Works the same way as notify(),\n  except this is set to context when calling the functions.\n*/\n\nDeferred.prototype.notifyWith = function() {\n  var args, context, _ref;\n  context = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];\n  if (this._state !== 'pending') return this;\n  if ((_ref = this._progressCallbacks) != null) {\n    _ref.forEach(function(fn) {\n      return fn.apply(context, args);\n    });\n  }\n  return this;\n};\n\n/*\n  Returns a new Promise object that's tied to the current Deferred. The doneFilter\n  and failFilter can be used to modify the final values that are passed to the\n  callbacks of the new promise. If the parameters passed are falsy, the promise\n  object resolves or rejects normally. If the filter functions return a value,\n  that one is passed to the respective callbacks. The filters can also return a\n  new Promise or Deferred object, of which rejected / resolved will control how the\n  callbacks fire.\n*/\n\nDeferred.prototype.pipe = function(doneFilter, failFilter) {\n  var def;\n  def = new Deferred();\n  this.done(function() {\n    var args, result, _ref;\n    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n    if (doneFilter != null) {\n      result = doneFilter.apply(this, args);\n      if (isObservable(result)) {\n        return result.done(function() {\n          var doneArgs, _ref;\n          doneArgs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n          return (_ref = def.resolveWith).call.apply(_ref, [def, this].concat(__slice.call(doneArgs)));\n        }).fail(function() {\n          var failArgs, _ref;\n          failArgs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n          return (_ref = def.rejectWith).call.apply(_ref, [def, this].concat(__slice.call(failArgs)));\n        });\n      } else {\n        return def.resolveWith.call(def, this, result);\n      }\n    } else {\n      return (_ref = def.resolveWith).call.apply(_ref, [def, this].concat(__slice.call(args)));\n    }\n  });\n  this.fail(function() {\n    var args, result, _ref, _ref2;\n    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n    if (failFilter != null) {\n      result = failFilter.apply(this, args);\n      if (isObservable(result)) {\n        result.done(function() {\n          var doneArgs, _ref;\n          doneArgs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n          return (_ref = def.resolveWith).call.apply(_ref, [def, this].concat(__slice.call(doneArgs)));\n        }).fail(function() {\n          var failArgs, _ref;\n          failArgs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n          return (_ref = def.rejectWith).call.apply(_ref, [def, this].concat(__slice.call(failArgs)));\n        });\n      } else {\n        def.rejectWith.call(def, this, result);\n      }\n      return (_ref = def.rejectWith).call.apply(_ref, [def, this].concat(__slice.call(args)));\n    } else {\n      return (_ref2 = def.rejectWith).call.apply(_ref2, [def, this].concat(__slice.call(args)));\n    }\n  });\n  return def.promise();\n};\n\n/*\n  Add progress callbacks to be fired when using notify()\n*/\n\nDeferred.prototype.progress = function() {\n  var args, functions, _ref;\n  args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n  if (args.length === 0 || this._state !== 'pending') return this;\n  functions = flatten(args);\n  this._progressCallbacks || (this._progressCallbacks = []);\n  (_ref = this._progressCallbacks).push.apply(_ref, functions);\n  return this;\n};\n\n/*\n  Returns the promise object of this Deferred.\n*/\n\nDeferred.prototype.promise = function() {\n  return this._promise || (this._promise = new Promise(this));\n};\n\n/*\n  Reject this Deferred. If the object has already been rejected or resolved,\n  nothing happens. Parameters passed to reject will be handed to all current\n  and future fail and always callbacks.\n*/\n\nDeferred.prototype.reject = function() {\n  var args;\n  args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n  this.rejectWith.apply(this, [window].concat(__slice.call(args)));\n  return this;\n};\n\n/*\n  Reject this Deferred with additional context. Works the same way as reject, except\n  the first parameter is used as this when calling the fail and always callbacks.\n*/\n\nDeferred.prototype.rejectWith = function() {\n  var args, context, _ref, _ref2,\n    _this = this;\n  context = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];\n  if (this._state !== 'pending') return this;\n  this._state = 'rejected';\n  this._withArguments = args;\n  this._context = context;\n  if ((_ref = this._failCallbacks) != null) {\n    _ref.forEach(function(fn) {\n      return fn.apply(_this._context, args);\n    });\n  }\n  if ((_ref2 = this._alwaysCallbacks) != null) {\n    _ref2.forEach(function(fn) {\n      return fn.apply(_this._context, args);\n    });\n  }\n  return this;\n};\n\n/*\n  Resolves this Deferred object. If the object has already been rejected or resolved,\n  nothing happens. Parameters passed to resolve will be handed to all current and\n  future done and always callbacks.\n*/\n\nDeferred.prototype.resolve = function() {\n  var args;\n  args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n  this.resolveWith.apply(this, [window].concat(__slice.call(args)));\n  return this;\n};\n\n/*\n  Resolve this Deferred with additional context. Works the same way as resolve, except\n  the first parameter is used as this when calling the done and always callbacks.\n*/\n\nDeferred.prototype.resolveWith = function() {\n  var args, context, _ref, _ref2,\n    _this = this;\n  context = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];\n  if (this._state !== 'pending') return this;\n  this._state = 'resolved';\n  this._context = context;\n  this._withArguments = args;\n  if ((_ref = this._doneCallbacks) != null) {\n    _ref.forEach(function(fn) {\n      return fn.apply(_this._context, args);\n    });\n  }\n  if ((_ref2 = this._alwaysCallbacks) != null) {\n    _ref2.forEach(function(fn) {\n      return fn.apply(_this._context, args);\n    });\n  }\n  return this;\n};\n\n/*\n  Returns the state of this Deferred. Can be 'pending', 'rejected' or 'resolved'.\n*/\n\nDeferred.prototype.state = function() {\n  return this._state;\n};\n\n/*\n  Convenience function to specify each done, fail and progress callbacks at the same time.\n*/\n\nDeferred.prototype.then = function(doneCallbacks, failCallbacks, progressCallbacks) {\n  this.done(doneCallbacks);\n  this.fail(failCallbacks);\n  this.progress(progressCallbacks);\n  return this;\n};\n\n\n\n/*\nReturns a new promise object which will resolve when all of the deferreds or promises\npassed to the function resolve. The callbacks receive all the parameters that the\nindividual resolves yielded as an array. If any of the deferreds or promises are\nrejected, the promise will be rejected immediately.\n*/\n\nDeferred.when = function() {\n  var allDoneArgs, allReady, args, readyCount;\n  args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n  if (args.length === 0) return new Deferred().resolve().promise();\n  if (args.length === 1) return args[0].promise();\n  allReady = new Deferred();\n  readyCount = 0;\n  allDoneArgs = [];\n  args.forEach(function(dfr, index) {\n    return dfr.done(function() {\n      var doneArgs;\n      doneArgs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      readyCount += 1;\n      allDoneArgs[index] = doneArgs;\n      if (readyCount === args.length) {\n        return allReady.resolve.apply(allReady, allDoneArgs);\n      }\n    }).fail(function() {\n      var failArgs;\n      failArgs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      return allReady.rejectWith.apply(allReady, [this].concat(__slice.call(failArgs)));\n    });\n  });\n  return allReady.promise();\n};\n\nmodule.exports = Deferred;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/deferred.js\n ** module id = 23\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./lib/deferred.js?")},/*!*************************!*\
  !*** ./lib/internal.js ***!
  \*************************/
function(module,exports,__webpack_require__){eval("'use strict';\n\n// Машина состояний используется для пометки, в каком состоянии находятся поле\n// Например: если поле имеет состояние default - значит его значением является значение по умолчанию\n// Примечание: для массивов в общем случае это означает пустой массив\n\n/*!\n * Dependencies\n */\n\nvar StateMachine = __webpack_require__(/*! ./statemachine */ 25);\n\nvar ActiveRoster = StateMachine.ctor('require', 'modify', 'init', 'default');\n\nmodule.exports = InternalCache;\n\nfunction InternalCache () {\n  this.strictMode = undefined;\n  this.selected = undefined;\n  this.saveError = undefined;\n  this.validationError = undefined;\n  this.adhocPaths = undefined;\n  this.removing = undefined;\n  this.inserting = undefined;\n  this.version = undefined;\n  this.getters = {};\n  this._id = undefined;\n  this.populate = undefined; // what we want to populate in this doc\n  this.populated = undefined;// the _ids that have been populated\n  this.wasPopulated = false; // if this doc was the result of a population\n  this.scope = undefined;\n  this.activePaths = new ActiveRoster();\n\n  // embedded docs\n  this.ownerDocument = undefined;\n  this.fullPath = undefined;\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/internal.js\n ** module id = 24\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./lib/internal.js?")},/*!*****************************!*\
  !*** ./lib/statemachine.js ***!
  \*****************************/
function(module,exports){eval("'use strict';\n\n/*!\n * StateMachine represents a minimal `interface` for the\n * constructors it builds via StateMachine.ctor(...).\n *\n * @api private\n */\nvar StateMachine = module.exports = function StateMachine () {\n  this.paths = {};\n  this.states = {};\n};\n\n/*!\n * StateMachine.ctor('state1', 'state2', ...)\n * A factory method for subclassing StateMachine.\n * The arguments are a list of states. For each state,\n * the constructor's prototype gets state transition\n * methods named after each state. These transition methods\n * place their path argument into the given state.\n *\n * @param {String} state\n * @param {String} [state]\n * @return {Function} subclass constructor\n * @private\n */\nStateMachine.ctor = function () {\n  var states = _.toArray(arguments);\n\n  var ctor = function () {\n    StateMachine.apply(this, arguments);\n    this.stateNames = states;\n\n    var i = states.length\n      , state;\n\n    while (i--) {\n      state = states[i];\n      this.states[state] = {};\n    }\n  };\n\n  ctor.prototype = Object.create( StateMachine.prototype );\n  ctor.prototype.constructor = ctor;\n\n  states.forEach(function (state) {\n    // Changes the `path`'s state to `state`.\n    ctor.prototype[state] = function (path) {\n      this._changeState(path, state);\n    };\n  });\n\n  return ctor;\n};\n\n/*!\n * This function is wrapped by the state change functions:\n *\n * - `require(path)`\n * - `modify(path)`\n * - `init(path)`\n *\n * @api private\n */\nStateMachine.prototype._changeState = function _changeState (path, nextState) {\n  var prevBucket = this.states[this.paths[path]];\n  if (prevBucket) delete prevBucket[path];\n\n  this.paths[path] = nextState;\n  this.states[nextState][path] = true;\n};\n\n/*!\n * ignore\n */\nStateMachine.prototype.clear = function clear (state) {\n  var keys = Object.keys(this.states[state])\n    , i = keys.length\n    , path;\n\n  while (i--) {\n    path = keys[i];\n    delete this.states[state][path];\n    delete this.paths[path];\n  }\n};\n\n/*!\n * Checks to see if at least one path is in the states passed in via `arguments`\n * e.g., this.some('required', 'inited')\n *\n * @param {String} state that we want to check for.\n * @private\n */\nStateMachine.prototype.some = function some () {\n  var self = this;\n  var what = arguments.length ? arguments : this.stateNames;\n  return Array.prototype.some.call(what, function (state) {\n    return Object.keys(self.states[state]).length;\n  });\n};\n\n/*!\n * This function builds the functions that get assigned to `forEach` and `map`,\n * since both of those methods share a lot of the same logic.\n *\n * @param {String} iterMethod is either 'forEach' or 'map'\n * @return {Function}\n * @api private\n */\nStateMachine.prototype._iter = function _iter (iterMethod) {\n  return function () {\n    var numArgs = arguments.length\n      , states = _.toArray(arguments).slice(0, numArgs-1)\n      , callback = arguments[numArgs-1];\n\n    if (!states.length) states = this.stateNames;\n\n    var self = this;\n\n    var paths = states.reduce(function (paths, state) {\n      return paths.concat(Object.keys(self.states[state]));\n    }, []);\n\n    return paths[iterMethod](function (path, i, paths) {\n      return callback(path, i, paths);\n    });\n  };\n};\n\n/*!\n * Iterates over the paths that belong to one of the parameter states.\n *\n * The function profile can look like:\n * this.forEach(state1, fn);         // iterates over all paths in state1\n * this.forEach(state1, state2, fn); // iterates over all paths in state1 or state2\n * this.forEach(fn);                 // iterates over all paths in all states\n *\n * @param {String} [state]\n * @param {String} [state]\n * @param {Function} callback\n * @private\n */\nStateMachine.prototype.forEach = function forEach () {\n  this.forEach = this._iter('forEach');\n  return this.forEach.apply(this, arguments);\n};\n\n/*!\n * Maps over the paths that belong to one of the parameter states.\n *\n * The function profile can look like:\n * this.forEach(state1, fn);         // iterates over all paths in state1\n * this.forEach(state1, state2, fn); // iterates over all paths in state1 or state2\n * this.forEach(fn);                 // iterates over all paths in all states\n *\n * @param {String} [state]\n * @param {String} [state]\n * @param {Function} callback\n * @return {Array}\n * @private\n */\nStateMachine.prototype.map = function map () {\n  this.map = this._iter('map');\n  return this.map.apply(this, arguments);\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/statemachine.js\n ** module id = 25\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./lib/statemachine.js?")},/*!************************************!*\
  !*** ./lib/types/documentarray.js ***!
  \************************************/
function(module,exports,__webpack_require__){eval("'use strict';\n\n/*!\n * Module dependencies.\n */\nvar StorageArray = __webpack_require__(/*! ./array */ 27)\n  , ObjectId = __webpack_require__(/*! ./objectid */ 11)\n  , ObjectIdSchema = __webpack_require__(/*! ../schema/objectid */ 29)\n  , Document = __webpack_require__(/*! ../document */ 14);\n\n/**\n * DocumentArray constructor\n *\n * @param {Array} values\n * @param {String} path the path to this array\n * @param {Document} doc parent document\n * @api private\n * @return {StorageDocumentArray}\n * @inherits StorageArray\n * @see http://bit.ly/f6CnZU\n * TODO: подчистить код\n *\n * Весь нужный код скопирован\n */\nfunction StorageDocumentArray (values, path, doc) {\n  // Values always have to be passed to the constructor to initialize, since\n  // otherwise MongooseArray#push will mark the array as modified to the parent.\n  var arr = [].concat(values);\n  _.mixin( arr, StorageDocumentArray.mixin );\n\n  arr.validators = [];\n  arr._path = path;\n  arr.isStorageArray = true;\n  arr.isStorageDocumentArray = true;\n\n  if (doc) {\n    arr._parent = doc;\n    arr._schema = doc.schema.path(path);\n    arr._handlers = {\n      isNew: arr.notify('isNew'),\n      save: arr.notify('save')\n    };\n\n    // Проброс изменения состояния в поддокумент\n    doc.on('save', arr._handlers.save);\n    doc.on('isNew', arr._handlers.isNew);\n  }\n\n  return arr;\n}\n\n/*!\n * Inherits from StorageArray\n */\nStorageDocumentArray.mixin = Object.create( StorageArray.mixin );\n\n/**\n * Overrides StorageArray#cast\n *\n * @api private\n */\nStorageDocumentArray.mixin._cast = function (value) {\n  if (value instanceof this._schema.casterConstructor) {\n    if (!(value.__parent && value.__parentArray)) {\n      // value may have been created using array.create()\n      value.__parent = this._parent;\n      value.__parentArray = this;\n    }\n    return value;\n  }\n\n  // handle cast('string') or cast(ObjectId) etc.\n  // only objects are permitted so we can safely assume that\n  // non-objects are to be interpreted as _id\n  if ( value instanceof ObjectId || !_.isObject(value) ) {\n    value = { _id: value };\n  }\n\n  return new this._schema.casterConstructor(value, this);\n};\n\n/**\n * Searches array items for the first document with a matching _id.\n *\n * ####Example:\n *\n *     var embeddedDoc = m.array.id(some_id);\n *\n * @return {EmbeddedDocument|null} the subdocument or null if not found.\n * @param {ObjectId|String|Number} id\n * @TODO cast to the _id based on schema for proper comparison\n * @api public\n */\nStorageDocumentArray.mixin.id = function (id) {\n  var casted\n    , sid\n    , _id;\n\n  try {\n    var casted_ = ObjectIdSchema.prototype.cast.call({}, id);\n    if (casted_) casted = String(casted_);\n  } catch (e) {\n    casted = null;\n  }\n\n  for (var i = 0, l = this.length; i < l; i++) {\n    _id = this[i].get('_id');\n\n    if (_id instanceof Document) {\n      sid || (sid = String(id));\n      if (sid == _id._id) return this[i];\n    } else if (!(_id instanceof ObjectId)) {\n      sid || (sid = String(id));\n      if (sid == _id) return this[i];\n    } else if (casted == _id) {\n      return this[i];\n    }\n  }\n\n  return null;\n};\n\n/**\n * Returns a native js Array of plain js objects\n *\n * ####NOTE:\n *\n * _Each sub-document is converted to a plain object by calling its `#toObject` method._\n *\n * @param {Object} [options] optional options to pass to each documents `toObject` method call during conversion\n * @return {Array}\n * @api public\n */\n\nStorageDocumentArray.mixin.toObject = function (options) {\n  return this.map(function (doc) {\n    return doc && doc.toObject(options) || null;\n  });\n};\n\n/**\n * Creates a subdocument casted to this schema.\n *\n * This is the same subdocument constructor used for casting.\n *\n * @param {Object} obj the value to cast to this arrays SubDocument schema\n * @api public\n */\n\nStorageDocumentArray.mixin.create = function (obj) {\n  return new this._schema.casterConstructor(obj);\n};\n\n/**\n * Creates a fn that notifies all child docs of `event`.\n *\n * @param {String} event\n * @return {Function}\n * @api private\n */\nStorageDocumentArray.mixin.notify = function notify (event) {\n  var self = this;\n  return function notify (val) {\n    var i = self.length;\n    while (i--) {\n      if (!self[i]) continue;\n      self[i].trigger(event, val);\n    }\n  };\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = StorageDocumentArray;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/types/documentarray.js\n ** module id = 26\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./lib/types/documentarray.js?")},/*!****************************!*\
  !*** ./lib/types/array.js ***!
  \****************************/
function(module,exports,__webpack_require__){eval("'use strict';\n\n//TODO: почистить код\n\n/*!\n * Module dependencies.\n */\n\nvar EmbeddedDocument = __webpack_require__(/*! ./embedded */ 28);\nvar Document = __webpack_require__(/*! ../document */ 14);\nvar ObjectId = __webpack_require__(/*! ./objectid */ 11);\n\n/**\n * Storage Array constructor.\n *\n * ####NOTE:\n *\n * _Values always have to be passed to the constructor to initialize, otherwise `StorageArray#push` will mark the array as modified._\n *\n * @param {Array} values\n * @param {String} path\n * @param {Document} doc parent document\n * @api private\n * @inherits Array\n */\nfunction StorageArray (values, path, doc) {\n  var arr = [].concat(values);\n  _.mixin( arr, StorageArray.mixin );\n\n  arr.validators = [];\n  arr._path = path;\n  arr.isStorageArray = true;\n\n  if (doc) {\n    arr._parent = doc;\n    arr._schema = doc.schema.path(path);\n  }\n\n  return arr;\n}\n\nStorageArray.mixin = {\n  /**\n   * Parent owner document\n   *\n   * @property _parent\n   * @api private\n   */\n  _parent: undefined,\n\n  /**\n   * Casts a member based on this arrays schema.\n   *\n   * @param {*} value\n   * @return value the casted value\n   * @api private\n   */\n  _cast: function ( value ) {\n    var owner = this._owner;\n    var populated = false;\n\n    if (this._parent) {\n      // if a populated array, we must cast to the same model\n      // instance as specified in the original query.\n      if (!owner) {\n        owner = this._owner = this._parent.ownerDocument\n          ? this._parent.ownerDocument()\n          : this._parent;\n      }\n\n      populated = owner.populated(this._path, true);\n    }\n\n    if (populated && null != value) {\n      // cast to the populated Models schema\n      var Model = populated.options.model;\n\n      // only objects are permitted so we can safely assume that\n      // non-objects are to be interpreted as _id\n      if ( value instanceof ObjectId || !_.isObject(value) ) {\n        value = { _id: value };\n      }\n\n      // gh-2399\n      // we should cast model only when it's not a discriminator\n      var isDisc = value.schema && value.schema.discriminatorMapping &&\n        value.schema.discriminatorMapping.key !== undefined;\n      if (!isDisc) {\n        value = new Model(value);\n      }\n      return this._schema.caster.cast(value, this._parent, true);\n    }\n\n    return this._schema.caster.cast(value, this._parent, false);\n  },\n\n  /**\n   * Marks this array as modified.\n   *\n   * If it bubbles up from an embedded document change, then it takes the following arguments (otherwise, takes 0 arguments)\n   *\n   * @param {EmbeddedDocument} embeddedDoc the embedded doc that invoked this method on the Array\n   * @param {String} embeddedPath the path which changed in the embeddedDoc\n   * @api private\n   */\n  _markModified: function (elem, embeddedPath) {\n    var parent = this._parent\n      , dirtyPath;\n\n    if (parent) {\n      dirtyPath = this._path;\n\n      if (arguments.length) {\n        if (null != embeddedPath) {\n          // an embedded doc bubbled up the change\n          dirtyPath = dirtyPath + '.' + this.indexOf(elem) + '.' + embeddedPath;\n        } else {\n          // directly set an index\n          dirtyPath = dirtyPath + '.' + elem;\n        }\n      }\n\n      parent.markModified(dirtyPath);\n    }\n\n    return this;\n  },\n\n  /**\n   * Wraps [`Array#push`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/push) with proper change tracking.\n   *\n   * @param {Object} [args...]\n   * @api public\n   */\n  push: function () {\n    var values = [].map.call(arguments, this._cast, this)\n      , ret = [].push.apply(this, values);\n\n    this._markModified();\n    return ret;\n  },\n\n  /**\n   * Wraps [`Array#pop`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/pop) with proper change tracking.\n   *\n   * ####Note:\n   *\n   * _marks the entire array as modified which will pass the entire thing to $set potentially overwritting any changes that happen between when you retrieved the object and when you save it._\n   *\n   * @see StorageArray#$pop #types_array_StorageArray-%24pop\n   * @api public\n   */\n  pop: function () {\n    var ret = [].pop.call(this);\n\n    this._markModified();\n    return ret;\n  },\n\n  /**\n   * Wraps [`Array#shift`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/unshift) with proper change tracking.\n   *\n   * ####Example:\n   *\n   *     doc.array = [2,3];\n   *     var res = doc.array.shift();\n   *     console.log(res) // 2\n   *     console.log(doc.array) // [3]\n   *\n   * ####Note:\n   *\n   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._\n   *\n   * @api public\n   */\n  shift: function () {\n    var ret = [].shift.call(this);\n\n    this._markModified();\n    return ret;\n  },\n\n  /**\n   * Pulls items from the array atomically.\n   *\n   * ####Examples:\n   *\n   *     doc.array.pull(ObjectId)\n   *     doc.array.pull({ _id: 'someId' })\n   *     doc.array.pull(36)\n   *     doc.array.pull('tag 1', 'tag 2')\n   *\n   * To remove a document from a subdocument array we may pass an object with a matching `_id`.\n   *\n   *     doc.subdocs.push({ _id: 4815162342 })\n   *     doc.subdocs.pull({ _id: 4815162342 }) // removed\n   *\n   * Or we may passing the _id directly and let storage take care of it.\n   *\n   *     doc.subdocs.push({ _id: 4815162342 })\n   *     doc.subdocs.pull(4815162342); // works\n   *\n   * @param {*} arguments\n   * @see mongodb http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pull\n   * @api public\n   */\n  pull: function () {\n    var values = [].map.call(arguments, this._cast, this)\n      , cur = this._parent.get(this._path)\n      , i = cur.length\n      , mem;\n\n    while (i--) {\n      mem = cur[i];\n      if (mem instanceof EmbeddedDocument) {\n        if (values.some(function (v) { return v.equals(mem); } )) {\n          [].splice.call(cur, i, 1);\n        }\n      } else if (~cur.indexOf.call(values, mem)) {\n        [].splice.call(cur, i, 1);\n      }\n    }\n\n    this._markModified();\n    return this;\n  },\n\n  /**\n   * Wraps [`Array#splice`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/splice) with proper change tracking and casting.\n   *\n   * ####Note:\n   *\n   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._\n   *\n   * @api public\n   */\n  splice: function splice () {\n    var ret, vals, i;\n\n    if (arguments.length) {\n      vals = [];\n      for (i = 0; i < arguments.length; ++i) {\n        vals[i] = i < 2\n          ? arguments[i]\n          : this._cast(arguments[i]);\n      }\n      ret = [].splice.apply(this, vals);\n\n      this._markModified();\n    }\n\n    return ret;\n  },\n\n  /**\n   * Wraps [`Array#unshift`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/unshift) with proper change tracking.\n   *\n   * ####Note:\n   *\n   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._\n   *\n   * @api public\n   */\n  unshift: function () {\n    var values = [].map.call(arguments, this._cast, this);\n    [].unshift.apply(this, values);\n\n    this._markModified();\n    return this.length;\n  },\n\n  /**\n   * Wraps [`Array#sort`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/sort) with proper change tracking.\n   *\n   * ####NOTE:\n   *\n   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._\n   *\n   * @api public\n   */\n  sort: function () {\n    var ret = [].sort.apply(this, arguments);\n\n    this._markModified();\n    return ret;\n  },\n\n  /**\n   * Adds values to the array if not already present.\n   *\n   * ####Example:\n   *\n   *     console.log(doc.array) // [2,3,4]\n   *     var added = doc.array.addToSet(4,5);\n   *     console.log(doc.array) // [2,3,4,5]\n   *     console.log(added)     // [5]\n   *\n   * @param {*} arguments\n   * @return {Array} the values that were added\n   * @api public\n   */\n  addToSet: function addToSet () {\n    var values = [].map.call(arguments, this._cast, this)\n      , added = []\n      , type = values[0] instanceof EmbeddedDocument ? 'doc' :\n               values[0] instanceof Date ? 'date' :\n               '';\n\n    values.forEach(function (v) {\n      var found;\n      switch (type) {\n        case 'doc':\n          found = this.some(function(doc){ return doc.equals(v); });\n          break;\n        case 'date':\n          var val = +v;\n          found = this.some(function(d){ return +d === val; });\n          break;\n        default:\n          found = ~this.indexOf(v);\n      }\n\n      if (!found) {\n        [].push.call(this, v);\n\n        this._markModified();\n        [].push.call(added, v);\n      }\n    }, this);\n\n    return added;\n  },\n\n  /**\n   * Sets the casted `val` at index `i` and marks the array modified.\n   *\n   * ####Example:\n   *\n   *     // given documents based on the following\n   *     var docs = storage.createCollection('Doc', new Schema({ array: [Number] }));\n   *\n   *     var doc = docs.add({ array: [2,3,4] })\n   *\n   *     console.log(doc.array) // [2,3,4]\n   *\n   *     doc.array.set(1,\"5\");\n   *     console.log(doc.array); // [2,5,4] // properly cast to number\n   *     doc.save() // the change is saved\n   *\n   *     // VS not using array#set\n   *     doc.array[1] = \"5\";\n   *     console.log(doc.array); // [2,\"5\",4] // no casting\n   *     doc.save() // change is not saved\n   *\n   * @return {Array} this\n   * @api public\n   */\n  set: function (i, val) {\n    this[i] = this._cast(val);\n    this._markModified(i);\n    return this;\n  },\n\n  /**\n   * Returns a native js Array.\n   *\n   * @param {Object} options\n   * @return {Array}\n   * @api public\n   */\n  toObject: function (options) {\n    if (options && options.depopulate) {\n      return this.map(function (doc) {\n        return doc instanceof Document\n          ? doc.toObject(options)\n          : doc;\n      });\n    }\n\n    return this.slice();\n  },\n\n  /**\n   * Return the index of `obj` or `-1` if not found.\n   *\n   * @param {Object} obj the item to look for\n   * @return {Number}\n   * @api public\n   */\n  indexOf: function indexOf (obj) {\n    if (obj instanceof ObjectId) obj = obj.toString();\n    for (var i = 0, len = this.length; i < len; ++i) {\n      if (obj == this[i])\n        return i;\n    }\n    return -1;\n  }\n};\n\n/**\n * Alias of [pull](#types_array_StorageArray-pull)\n *\n * @see StorageArray#pull #types_array_StorageArray-pull\n * @see mongodb http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pull\n * @api public\n * @memberOf StorageArray\n * @method remove\n */\nStorageArray.mixin.remove = StorageArray.mixin.pull;\n\n/*!\n * Module exports.\n */\n\nmodule.exports = StorageArray;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/types/array.js\n ** module id = 27\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./lib/types/array.js?")},/*!*******************************!*\
  !*** ./lib/types/embedded.js ***!
  \*******************************/
function(module,exports,__webpack_require__){eval("'use strict';\n\n/*!\n * Module dependencies.\n */\n\nvar Document = __webpack_require__(/*! ../document */ 14);\nvar Deferred = __webpack_require__(/*! ../deferred */ 23);\n\n/**\n * EmbeddedDocument constructor.\n *\n * @param {Object} data js object returned from the db\n * @param {StorageDocumentArray} parentArr the parent array of this document\n * @inherits Document\n * @api private\n */\nfunction EmbeddedDocument ( data, parentArr ) {\n  if (parentArr) {\n    this.__parentArray = parentArr;\n    this.__parent = parentArr._parent;\n  } else {\n    this.__parentArray = undefined;\n    this.__parent = undefined;\n  }\n\n  Document.call( this, data, undefined );\n\n  // Нужно для проброса изменения значения из родительского документа, например при сохранении\n  var self = this;\n  this.on('isNew', function (val) {\n    self.isNew = val;\n  });\n}\n\n/*!\n * Inherit from Document\n */\nEmbeddedDocument.prototype = Object.create( Document.prototype );\nEmbeddedDocument.prototype.constructor = EmbeddedDocument;\n\n/**\n * Marks the embedded doc modified.\n *\n * ####Example:\n *\n *     var doc = blogpost.comments.id(hexstring);\n *     doc.mixed.type = 'changed';\n *     doc.markModified('mixed.type');\n *\n * @param {String} path the path which changed\n * @api public\n */\nEmbeddedDocument.prototype.markModified = function (path) {\n  if (!this.__parentArray) return;\n\n  this.$__.activePaths.modify(path);\n\n  if (this.isNew) {\n    // Mark the WHOLE parent array as modified\n    // if this is a new document (i.e., we are initializing\n    // a document),\n    this.__parentArray._markModified();\n  } else\n    this.__parentArray._markModified(this, path);\n};\n\n/**\n * Used as a stub for [hooks.js](https://github.com/bnoguchi/hooks-js/tree/31ec571cef0332e21121ee7157e0cf9728572cc3)\n *\n * ####NOTE:\n *\n * _This is a no-op. Does not actually save the doc to the db._\n *\n * @param {Function} [fn]\n * @return {Promise} resolved Promise\n * @api private\n */\n\nEmbeddedDocument.prototype.save = function (fn) {\n  var promise = new Deferred().done(fn);\n  promise.resolve();\n  return promise;\n};\n\n/**\n * Removes the subdocument from its parent array.\n *\n * @param {Function} [fn]\n * @api public\n */\nEmbeddedDocument.prototype.remove = function (fn) {\n  if (!this.__parentArray) return this;\n\n  var _id;\n  if (!this.willRemove) {\n    _id = this._doc._id;\n    if (!_id) {\n      throw new Error('For your own good, Storage does not know ' +\n                      'how to remove an EmbeddedDocument that has no _id');\n    }\n    this.__parentArray.pull({ _id: _id });\n    this.willRemove = true;\n  }\n\n  if (fn)\n    fn(null);\n\n  return this;\n};\n\n/**\n * Override #update method of parent documents.\n * @api private\n */\nEmbeddedDocument.prototype.update = function () {\n  throw new Error('The #update method is not available on EmbeddedDocuments');\n};\n\n/**\n * Marks a path as invalid, causing validation to fail.\n *\n * @param {String} path the field to invalidate\n * @param {String|Error} err error which states the reason `path` was invalid\n * @return {Boolean}\n * @api public\n */\nEmbeddedDocument.prototype.invalidate = function (path, err, val, first) {\n  if (!this.__parent) {\n    var msg = 'Unable to invalidate a subdocument that has not been added to an array.';\n    throw new Error(msg);\n  }\n\n  var index = this.__parentArray.indexOf(this);\n  var parentPath = this.__parentArray._path;\n  var fullPath = [parentPath, index, path].join('.');\n\n  // sniffing arguments:\n  // need to check if user passed a value to keep\n  // our error message clean.\n  if (2 < arguments.length) {\n    this.__parent.invalidate(fullPath, err, val);\n  } else {\n    this.__parent.invalidate(fullPath, err);\n  }\n\n  if (first)\n    this.$__.validationError = this.ownerDocument().$__.validationError;\n  return true;\n};\n\n/**\n * Returns the top level document of this sub-document.\n *\n * @return {Document}\n */\nEmbeddedDocument.prototype.ownerDocument = function () {\n  if (this.$__.ownerDocument) {\n    return this.$__.ownerDocument;\n  }\n\n  var parent = this.__parent;\n  if (!parent) return this;\n\n  while (parent.__parent) {\n    parent = parent.__parent;\n  }\n\n  this.$__.ownerDocument = parent;\n\n  return this.$__.ownerDocument;\n};\n\n/**\n * Returns the full path to this document. If optional `path` is passed, it is appended to the full path.\n *\n * @param {String} [path]\n * @return {String}\n * @api private\n * @method $__fullPath\n * @memberOf EmbeddedDocument\n */\nEmbeddedDocument.prototype.$__fullPath = function (path) {\n  if (!this.$__.fullPath) {\n    var parent = this;\n    if (!parent.__parent) return path;\n\n    var paths = [];\n    while (parent.__parent) {\n      paths.unshift(parent.__parentArray._path);\n      parent = parent.__parent;\n    }\n\n    this.$__.fullPath = paths.join('.');\n\n    if (!this.$__.ownerDocument) {\n      // optimization\n      this.$__.ownerDocument = parent;\n    }\n  }\n\n  return path\n    ? this.$__.fullPath + '.' + path\n    : this.$__.fullPath;\n};\n\n/**\n * Returns this sub-documents parent document.\n *\n * @api public\n */\nEmbeddedDocument.prototype.parent = function () {\n  return this.__parent;\n};\n\n/**\n * Returns this sub-documents parent array.\n *\n * @api public\n */\nEmbeddedDocument.prototype.parentArray = function () {\n  return this.__parentArray;\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = EmbeddedDocument;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/types/embedded.js\n ** module id = 28\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./lib/types/embedded.js?")},/*!********************************!*\
  !*** ./lib/schema/objectid.js ***!
  \********************************/
function(module,exports,__webpack_require__){eval("'use strict';\n\n/*!\n * Module dependencies.\n */\n\nvar SchemaType = __webpack_require__(/*! ../schematype */ 22)\n  , CastError = SchemaType.CastError\n  , oid = __webpack_require__(/*! ../types/objectid */ 11)\n  , Document;\n\n/**\n * ObjectId SchemaType constructor.\n *\n * @param {String} key\n * @param {Object} options\n * @inherits SchemaType\n * @api private\n */\n\nfunction ObjectId (key, options) {\n  SchemaType.call(this, key, options, 'ObjectId');\n}\n\n/*!\n * Inherits from SchemaType.\n */\nObjectId.prototype = Object.create( SchemaType.prototype );\nObjectId.prototype.constructor = ObjectId;\n\n/**\n * Adds an auto-generated ObjectId default if turnOn is true.\n * @param {Boolean} turnOn auto generated ObjectId defaults\n * @api public\n * @return {SchemaType} this\n */\nObjectId.prototype.auto = function ( turnOn ) {\n  if ( turnOn ) {\n    this.default( defaultId );\n    this.set( resetId );\n  }\n\n  return this;\n};\n\n/**\n * Check required\n *\n * @api private\n */\nObjectId.prototype.checkRequired = function ( value ) {\n  if (SchemaType._isRef( this, value )) {\n    return null != value;\n  } else {\n    return value instanceof oid;\n  }\n};\n\n/**\n * Casts to ObjectId\n *\n * @param {ObjectId|String} value\n * @param {Document} doc\n * @param {Boolean} init\n * @param {ObjectId|Document} priorVal\n * @api private\n */\nObjectId.prototype.cast = function ( value, doc, init, priorVal ) {\n  // lazy load\n  Document || (Document = __webpack_require__(/*! ./../document */ 14));\n\n  if ( SchemaType._isRef( this, value ) ) {\n    // wait! we may need to cast this to a document\n\n    // If null or undefined\n    if (null == value) {\n      return value;\n    }\n\n    if (value instanceof Document) {\n      value.$__.wasPopulated = true;\n      return value;\n    }\n\n    // setting a populated path\n    if (value instanceof oid ) {\n      return value;\n    } else if ( !_.isPlainObject( value ) ) {\n      throw new CastError('ObjectId', value, this.path);\n    }\n\n    // Нужно создать документ по схеме, указанной в ссылке\n    var schema = this.options.ref;\n    if ( !schema ){\n      throw new TypeError('При ссылке (ref) на документ ' +\n        'нужно указывать схему, по которой этот документ создавать');\n    }\n\n    if ( !storage.schemas[ schema ] ){\n      throw new TypeError('При ссылке (ref) на документ ' +\n        'нужно указывать название схемы на которую ссылаемся при её создании ( new Schema(\"name\", schemaObject) )');\n    }\n\n    // init doc\n    doc = new Document( value, undefined, storage.schemas[ schema ], undefined, true );\n    doc.$__.wasPopulated = true;\n\n    return doc;\n  }\n\n  if (value === null) return value;\n\n  // Предотвратить depopulate\n  if ( priorVal instanceof Document ){\n    if ( priorVal._id && priorVal._id.equals( value ) ){\n      return priorVal;\n    }\n  }\n\n  if (value instanceof oid)\n    return value;\n\n  if ( value._id && value._id instanceof oid )\n    return value._id;\n\n  if (value.toString) {\n    try {\n      return oid.createFromHexString(value.toString());\n    } catch (err) {\n      throw new CastError('ObjectId', value, this.path);\n    }\n  }\n\n  throw new CastError('ObjectId', value, this.path);\n};\n\n/*!\n * ignore\n */\nfunction defaultId () {\n  return new oid();\n}\n\nfunction resetId (v) {\n  this.$__._id = null;\n  return v;\n}\n\n/*!\n * Module exports.\n */\n\nmodule.exports = ObjectId;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/schema/objectid.js\n ** module id = 29\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./lib/schema/objectid.js?")},/*!*****************************!*\
  !*** ./lib/schema/index.js ***!
  \*****************************/
function(module,exports,__webpack_require__){eval("'use strict';\n\n/*!\n * Module exports.\n */\n\nexports.String = __webpack_require__(/*! ./string */ 31);\n\nexports.Number = __webpack_require__(/*! ./number */ 32);\n\nexports.Boolean = __webpack_require__(/*! ./boolean */ 33);\n\nexports.DocumentArray = __webpack_require__(/*! ./documentarray */ 34);\n\nexports.Array = __webpack_require__(/*! ./array */ 35);\n\nexports.Buffer = __webpack_require__(/*! ./buffer */ 37);\n\nexports.Date = __webpack_require__(/*! ./date */ 36);\n\nexports.ObjectId = __webpack_require__(/*! ./objectid */ 29);\n\nexports.Mixed = __webpack_require__(/*! ./mixed */ 21);\n\n// alias\n\nexports.Oid = exports.ObjectId;\nexports.Object = exports.Mixed;\nexports.Bool = exports.Boolean;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/schema/index.js\n ** module id = 30\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./lib/schema/index.js?")},/*!******************************!*\
  !*** ./lib/schema/string.js ***!
  \******************************/
function(module,exports,__webpack_require__){eval("'use strict';\n\n/*!\n * Module dependencies.\n */\n\nvar SchemaType = __webpack_require__(/*! ../schematype */ 22)\n  , CastError = SchemaType.CastError\n  , errorMessages = __webpack_require__(/*! ../error */ 15).messages;\n\n/**\n * String SchemaType constructor.\n *\n * @param {String} key\n * @param {Object} options\n * @inherits SchemaType\n * @api private\n */\n\nfunction StringSchema (key, options) {\n  this.enumValues = [];\n  this.regExp = null;\n  SchemaType.call(this, key, options, 'String');\n}\n\n/*!\n * Inherits from SchemaType.\n */\nStringSchema.prototype = Object.create( SchemaType.prototype );\nStringSchema.prototype.constructor = StringSchema;\n\n/**\n * Adds an enum validator\n *\n * ####Example:\n *\n *     var states = 'opening open closing closed'.split(' ')\n *     var s = new Schema({ state: { type: String, enum: states }})\n *     var M = db.model('M', s)\n *     var m = new M({ state: 'invalid' })\n *     m.save(function (err) {\n *       console.error(String(err)) // ValidationError: `invalid` is not a valid enum value for path `state`.\n *       m.state = 'open'\n *       m.save(callback) // success\n *     })\n *\n *     // or with custom error messages\n *     var enu = {\n *       values: 'opening open closing closed'.split(' '),\n *       message: 'enum validator failed for path `{PATH}` with value `{VALUE}`'\n *     }\n *     var s = new Schema({ state: { type: String, enum: enu })\n *     var M = db.model('M', s)\n *     var m = new M({ state: 'invalid' })\n *     m.save(function (err) {\n *       console.error(String(err)) // ValidationError: enum validator failed for path `state` with value `invalid`\n *       m.state = 'open'\n *       m.save(callback) // success\n *     })\n *\n * @param {String|Object} [args...] enumeration values\n * @return {SchemaType} this\n * @see Customized Error Messages #error_messages_StorageError-messages\n * @api public\n */\nStringSchema.prototype.enum = function () {\n  if (this.enumValidator) {\n    this.validators = this.validators.filter(function(v) {\n      return v.validator != this.enumValidator;\n    }, this);\n    this.enumValidator = false;\n  }\n\n  if (undefined === arguments[0] || false === arguments[0]) {\n    return this;\n  }\n\n  var values;\n  var errorMessage;\n\n  if (_.isPlainObject(arguments[0])) {\n    values = arguments[0].values;\n    errorMessage = arguments[0].message;\n  } else {\n    values = arguments;\n    errorMessage = errorMessages.String.enum;\n  }\n\n  for (var i = 0; i < values.length; i++) {\n    if (undefined !== values[i]) {\n      this.enumValues.push(this.cast(values[i]));\n    }\n  }\n\n  var vals = this.enumValues;\n  this.enumValidator = function (v) {\n    return undefined === v || ~vals.indexOf(v);\n  };\n  this.validators.push({ validator: this.enumValidator, message: errorMessage, type: 'enum' });\n\n  return this;\n};\n\n/**\n * Adds a lowercase setter.\n *\n * ####Example:\n *\n *     var s = new Schema({ email: { type: String, lowercase: true }})\n *     var M = db.model('M', s);\n *     var m = new M({ email: 'SomeEmail@example.COM' });\n *     console.log(m.email) // someemail@example.com\n *\n * @api public\n * @return {SchemaType} this\n */\nStringSchema.prototype.lowercase = function () {\n  return this.set(function (v, self) {\n    if ('string' !== typeof v) v = self.cast(v);\n    if (v) return v.toLowerCase();\n    return v;\n  });\n};\n\n/**\n * Adds an uppercase setter.\n *\n * ####Example:\n *\n *     var s = new Schema({ caps: { type: String, uppercase: true }})\n *     var M = db.model('M', s);\n *     var m = new M({ caps: 'an example' });\n *     console.log(m.caps) // AN EXAMPLE\n *\n * @api public\n * @return {SchemaType} this\n */\nStringSchema.prototype.uppercase = function () {\n  return this.set(function (v, self) {\n    if ('string' !== typeof v) v = self.cast(v);\n    if (v) return v.toUpperCase();\n    return v;\n  });\n};\n\n/**\n * Adds a trim setter.\n *\n * The string value will be trimmed when set.\n *\n * ####Example:\n *\n *     var s = new Schema({ name: { type: String, trim: true }})\n *     var M = db.model('M', s)\n *     var string = ' some name '\n *     console.log(string.length) // 11\n *     var m = new M({ name: string })\n *     console.log(m.name.length) // 9\n *\n * @api public\n * @return {SchemaType} this\n */\nStringSchema.prototype.trim = function () {\n  return this.set(function (v, self) {\n    if ('string' !== typeof v) v = self.cast(v);\n    if (v) return v.trim();\n    return v;\n  });\n};\n\n/**\n * Sets a regexp validator.\n *\n * Any value that does not pass `regExp`.test(val) will fail validation.\n *\n * ####Example:\n *\n *     var s = new Schema({ name: { type: String, match: /^a/ }})\n *     var M = db.model('M', s)\n *     var m = new M({ name: 'I am invalid' })\n *     m.validate(function (err) {\n *       console.error(String(err)) // \"ValidationError: Path `name` is invalid (I am invalid).\"\n *       m.name = 'apples'\n *       m.validate(function (err) {\n *         assert.ok(err) // success\n *       })\n *     })\n *\n *     // using a custom error message\n *     var match = [ /\\.html$/, \"That file doesn't end in .html ({VALUE})\" ];\n *     var s = new Schema({ file: { type: String, match: match }})\n *     var M = db.model('M', s);\n *     var m = new M({ file: 'invalid' });\n *     m.validate(function (err) {\n *       console.log(String(err)) // \"ValidationError: That file doesn't end in .html (invalid)\"\n *     })\n *\n * Empty strings, `undefined`, and `null` values always pass the match validator. If you require these values, enable the `required` validator also.\n *\n *     var s = new Schema({ name: { type: String, match: /^a/, required: true }})\n *\n * @param {RegExp} regExp regular expression to test against\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages #error_messages_StorageError-messages\n * @api public\n */\nStringSchema.prototype.match = function match (regExp, message) {\n  // yes, we allow multiple match validators\n\n  var msg = message || errorMessages.String.match;\n\n  var matchValidator = function(v) {\n    var ret = ((null != v && '' !== v)\n        ? regExp.test(v)\n        : true);\n    return ret;\n  };\n\n  this.validators.push({ validator: matchValidator, message: msg, type: 'regexp' });\n  return this;\n};\n\n/**\n * Check required\n *\n * @param {String|null|undefined} value\n * @api private\n */\nStringSchema.prototype.checkRequired = function checkRequired (value, doc) {\n  if (SchemaType._isRef(this, value, doc, true)) {\n    return null != value;\n  } else {\n    return (value instanceof String || typeof value === 'string') && value.length;\n  }\n};\n\n/**\n * Casts to String\n *\n * @api private\n */\nStringSchema.prototype.cast = function ( value ) {\n  if ( value === null ) {\n    return value;\n  }\n\n  if ('undefined' !== typeof value) {\n    // handle documents being passed\n    if (value._id && 'string' === typeof value._id) {\n      return value._id;\n    }\n    if ( value.toString ) {\n      return value.toString();\n    }\n  }\n\n  throw new CastError('string', value, this.path);\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = StringSchema;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/schema/string.js\n ** module id = 31\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./lib/schema/string.js?")},/*!******************************!*\
  !*** ./lib/schema/number.js ***!
  \******************************/
function(module,exports,__webpack_require__){eval("'use strict';\n\n/*!\n * Module requirements.\n */\n\nvar SchemaType = __webpack_require__(/*! ../schematype */ 22)\n  , CastError = SchemaType.CastError\n  , errorMessages = __webpack_require__(/*! ../error */ 15).messages;\n\n/**\n * Number SchemaType constructor.\n *\n * @param {String} key\n * @param {Object} options\n * @inherits SchemaType\n * @api private\n */\nfunction NumberSchema (key, options) {\n  SchemaType.call(this, key, options, 'Number');\n}\n\n/*!\n * Inherits from SchemaType.\n */\nNumberSchema.prototype = Object.create( SchemaType.prototype );\nNumberSchema.prototype.constructor = NumberSchema;\n\n/**\n * Required validator for number\n *\n * @api private\n */\nNumberSchema.prototype.checkRequired = function ( value ) {\n  if ( SchemaType._isRef( this, value ) ) {\n    return null != value;\n  } else {\n    return typeof value === 'number' || value instanceof Number;\n  }\n};\n\n/**\n * Sets a minimum number validator.\n *\n * ####Example:\n *\n *     var s = new Schema({ n: { type: Number, min: 10 })\n *     var M = db.model('M', s)\n *     var m = new M({ n: 9 })\n *     m.save(function (err) {\n *       console.error(err) // validator error\n *       m.n = 10;\n *       m.save() // success\n *     })\n *\n *     // custom error messages\n *     // We can also use the special {MIN} token which will be replaced with the invalid value\n *     var min = [10, 'The value of path `{PATH}` ({VALUE}) is beneath the limit ({MIN}).'];\n *     var schema = new Schema({ n: { type: Number, min: min })\n *     var M = mongoose.model('Measurement', schema);\n *     var s= new M({ n: 4 });\n *     s.validate(function (err) {\n *       console.log(String(err)) // ValidationError: The value of path `n` (4) is beneath the limit (10).\n *     })\n *\n * @param {Number} value minimum number\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages #error_messages_StorageError-messages\n * @api public\n */\nNumberSchema.prototype.min = function (value, message) {\n  if (this.minValidator) {\n    this.validators = this.validators.filter(function (v) {\n      return v.validator != this.minValidator;\n    }, this);\n  }\n\n  if (null != value) {\n    var msg = message || errorMessages.Number.min;\n    msg = msg.replace(/{MIN}/, value);\n    this.validators.push({\n      validator: this.minValidator = function (v) {\n        return v === null || v >= value;\n      },\n      message: msg,\n      type: 'min'\n    });\n  }\n\n  return this;\n};\n\n/**\n * Sets a maximum number validator.\n *\n * ####Example:\n *\n *     var s = new Schema({ n: { type: Number, max: 10 })\n *     var M = db.model('M', s)\n *     var m = new M({ n: 11 })\n *     m.save(function (err) {\n *       console.error(err) // validator error\n *       m.n = 10;\n *       m.save() // success\n *     })\n *\n *     // custom error messages\n *     // We can also use the special {MAX} token which will be replaced with the invalid value\n *     var max = [10, 'The value of path `{PATH}` ({VALUE}) exceeds the limit ({MAX}).'];\n *     var schema = new Schema({ n: { type: Number, max: max })\n *     var M = mongoose.model('Measurement', schema);\n *     var s= new M({ n: 4 });\n *     s.validate(function (err) {\n *       console.log(String(err)) // ValidationError: The value of path `n` (4) exceeds the limit (10).\n *     })\n *\n * @param {Number} value maximum number\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages #error_messages_StorageError-messages\n * @api public\n */\nNumberSchema.prototype.max = function (value, message) {\n  if (this.maxValidator) {\n    this.validators = this.validators.filter(function(v){\n      return v.validator != this.maxValidator;\n    }, this);\n  }\n\n  if (null != value) {\n    var msg = message || errorMessages.Number.max;\n    msg = msg.replace(/{MAX}/, value);\n    this.validators.push({\n      validator: this.maxValidator = function(v) {\n        return v === null || v <= value;\n      },\n      message: msg,\n      type: 'max'\n    });\n  }\n\n  return this;\n};\n\n/**\n * Casts to number\n *\n * @param {Object} value value to cast\n * @api private\n */\nNumberSchema.prototype.cast = function ( value ) {\n  var val = value && value._id\n    ? value._id // documents\n    : value;\n\n  if (!isNaN(val)){\n    if (null === val) return val;\n    if ('' === val) return null;\n    if ('string' === typeof val) val = Number(val);\n    if (val instanceof Number) return val;\n    if ('number' === typeof val) return val;\n    if (val.toString && !Array.isArray(val) &&\n        val.toString() == Number(val)) {\n      return new Number(val);\n    }\n  }\n\n  throw new CastError('number', value, this.path);\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = NumberSchema;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/schema/number.js\n ** module id = 32\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./lib/schema/number.js?")},/*!*******************************!*\
  !*** ./lib/schema/boolean.js ***!
  \*******************************/
function(module,exports,__webpack_require__){eval("'use strict';\n\n/*!\n * Module dependencies.\n */\n\nvar SchemaType = __webpack_require__(/*! ../schematype */ 22);\n\n/**\n * Boolean SchemaType constructor.\n *\n * @param {String} path\n * @param {Object} options\n * @inherits SchemaType\n * @api private\n */\nfunction BooleanSchema (path, options) {\n  SchemaType.call(this, path, options);\n}\n\n/*!\n * Inherits from SchemaType.\n */\nBooleanSchema.prototype = Object.create( SchemaType.prototype );\nBooleanSchema.prototype.constructor = BooleanSchema;\n\n/**\n * Required validator\n *\n * @api private\n */\nBooleanSchema.prototype.checkRequired = function (value) {\n  return value === true || value === false;\n};\n\n/**\n * Casts to boolean\n *\n * @param {Object} value\n * @api private\n */\nBooleanSchema.prototype.cast = function (value) {\n  if (null === value) return value;\n  if ('0' === value) return false;\n  if ('true' === value) return true;\n  if ('false' === value) return false;\n  return !! value;\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = BooleanSchema;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/schema/boolean.js\n ** module id = 33\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./lib/schema/boolean.js?")},/*!*************************************!*\
  !*** ./lib/schema/documentarray.js ***!
  \*************************************/
function(module,exports,__webpack_require__){eval("'use strict';\n\nvar SchemaType = __webpack_require__(/*! ../schematype */ 22)\n  , ArrayType = __webpack_require__(/*! ./array */ 35)\n  , StorageDocumentArray = __webpack_require__(/*! ../types/documentarray */ 26)\n  , Subdocument = __webpack_require__(/*! ../types/embedded */ 28)\n  , Document = __webpack_require__(/*! ../document */ 14)\n  , oid = __webpack_require__(/*! ../types/objectid */ 11)\n  , utils = __webpack_require__(/*! ../utils */ 9);\n\n\n/**\n * SubdocsArray SchemaType constructor\n *\n * @param {String} key\n * @param {Schema} schema\n * @param {Object} options\n * @inherits SchemaArray\n * @api private\n */\nfunction DocumentArray (key, schema, options) {\n\n  // compile an embedded document for this schema\n  function EmbeddedDocument () {\n    Subdocument.apply( this, arguments );\n  }\n\n  EmbeddedDocument.prototype = Object.create( Subdocument.prototype );\n  EmbeddedDocument.prototype.constructor = EmbeddedDocument;\n  EmbeddedDocument.prototype.$__setSchema( schema );\n\n  // apply methods\n  for (var i in schema.methods) {\n    EmbeddedDocument.prototype[i] = schema.methods[i];\n  }\n\n  // apply statics\n  for (var j in schema.statics) {\n    EmbeddedDocument[j] = schema.statics[j];\n  }\n\n  EmbeddedDocument.options = options;\n  this.schema = schema;\n\n  ArrayType.call(this, key, EmbeddedDocument, options);\n\n  this.schema = schema;\n  var path = this.path;\n  var fn = this.defaultValue;\n\n  this.default(function(){\n    var arr = fn.call(this);\n    if (!Array.isArray(arr)) arr = [arr];\n    return new StorageDocumentArray(arr, path, this);\n  });\n}\n\n/*!\n * Inherits from ArrayType.\n */\nDocumentArray.prototype = Object.create( ArrayType.prototype );\nDocumentArray.prototype.constructor = DocumentArray;\n\n\n\n/**\n * Performs local validations first, then validations on each embedded doc\n *\n * @api private\n */\nDocumentArray.prototype.doValidate = function (array, fn, scope) {\n  var self = this;\n\n  SchemaType.prototype.doValidate.call(this, array, function (err) {\n    if (err) return fn(err);\n\n    var count = array && array.length\n      , error;\n\n    if (!count) return fn();\n\n    // handle sparse arrays, do not use array.forEach which does not\n    // iterate over sparse elements yet reports array.length including\n    // them :(\n\n    for (var i = 0, len = count; i < len; ++i) {\n      // sidestep sparse entries\n      var doc = array[i];\n      if (!doc) {\n        --count || fn();\n        continue;\n      }\n\n      !(function (i) {\n        doc.validate(function (err) {\n          if (err && !error) {\n            // rewrite the key\n            err.key = self.key + '.' + i + '.' + err.key;\n            return fn(error = err);\n          }\n          --count || fn();\n        });\n      })(i);\n    }\n  }, scope);\n};\n\n\n/**\n * Performs local validations first, then validations on each embedded doc.\n *\n * ####Note:\n *\n * This method ignores the asynchronous validators.\n *\n * @return {StorageError|undefined}\n * @api private\n */\nDocumentArray.prototype.doValidateSync = function (array, scope) {\n  var schemaTypeError = SchemaType.prototype.doValidateSync.call(this, array, scope);\n  if (schemaTypeError) return schemaTypeError;\n\n  var count = array && array.length\n      , resultError = null;\n\n  if (!count) return;\n\n  // handle sparse arrays, do not use array.forEach which does not\n  // iterate over sparse elements yet reports array.length including\n  // them :(\n\n  for (var i = 0, len = count; i < len; ++i) {\n    // only first error\n    if ( resultError ) break;\n    // sidestep sparse entries\n    var doc = array[i];\n    if (!doc) continue;\n\n    var subdocValidateError = doc.validateSync();\n\n    if (subdocValidateError) {\n      resultError = subdocValidateError;\n    }\n  }\n\n  return resultError;\n};\n\n\n/**\n * Casts contents\n *\n * @param {*} value\n * @param {Document} doc that triggers the casting\n * @param {Boolean} init flag\n * @param {DocumentArray} prev\n * @api private\n */\nDocumentArray.prototype.cast = function (value, doc, init, prev) {\n  var selected\n    , subdoc\n    , i;\n\n  if (!Array.isArray(value)) {\n    // m-gh-2442: if we're loading this from the db and its not an array, mark\n    // the whole array as modified.\n    if (!!doc && !!init) {\n      doc.markModified(this.path);\n    }\n    return this.cast([value], doc, init, prev);\n  }\n\n  // Если два массива примерно (кроме _id) одинаковые - не надо перезаписывать\n  if ( prev && approximatelyEqual( value, prev ) ){\n    return prev;\n  }\n\n  if (!(value.isStorageDocumentArray)) {\n    value = new StorageDocumentArray(value, this.path, doc);\n    if (prev && prev._handlers) {\n      for (var key in prev._handlers) {\n        doc.off(key, prev._handlers[key]);\n      }\n    }\n  }\n\n  i = value.length;\n\n  while (i--) {\n    if (!(value[i] instanceof Subdocument) && value[i]) {\n      if (init) {\n        selected || (selected = scopePaths(this, doc.$__.selected, init));\n        subdoc = new this.casterConstructor(null, value, true, selected);\n        value[i] = subdoc.init(value[i]);\n      } else {\n        try {\n          subdoc = prev.id(value[i]._id);\n        } catch(e) {}\n\n        if (prev && subdoc) {\n          // handle resetting doc with existing id but differing data\n          // doc.array = [{ doc: 'val' }]\n          subdoc.set(value[i]);\n        } else {\n          subdoc = new this.casterConstructor(value[i], value);\n\n          restorePopulatedFields( subdoc, this.schema.tree, value[i], prev );\n        }\n\n        // if set() is hooked it will have no return value\n        // see gh-746\n        value[i] = subdoc;\n      }\n    }\n  }\n\n  return value;\n};\n\n/*!\n * Приблизительное сравнение двух массивов\n *\n * Это нужно для populated полей - их мы преобразовываем в id.\n *\n * Так же в сравнении не участвует id существующих Embedded документов,\n * Если на сервере _id: false, а на клиенте по умолчанию есть _id.\n *\n * todo: переименовать в specialEqual\n *\n * @param value\n * @param prev\n * @returns {*}\n */\nfunction approximatelyEqual ( value, prev ) {\n  prev = prev.toObject({depopulate: 1});\n\n  // Не сравнивать по subdoc _id\n  var i = value.length;\n  if ( i === prev.length ){\n    _.forEach( value, function( subdoc, i ){\n      if ( !subdoc._id ){\n        delete prev[ i ]._id;\n      }\n    });\n  }\n\n  return utils.deepEqual( value, prev );\n}\n\n/*!\n * Restore population\n *\n * @param {*} subdoc\n * @param {Object} schemaTree\n * @param {*} value\n * @param {DocumentArray} prev\n */\nfunction restorePopulatedFields ( subdoc, schemaTree, value, prev ) {\n  var props;\n  _.forEach( schemaTree, function( prop, key ){\n    var curVal;\n\n    if ( prop.ref ){\n      props = {};\n      curVal = value[ key ];\n\n      if ( curVal && oid.isValid( curVal ) ){\n\n        _.forEach( prev, function( prevDoc ){\n          var prevDocProp = prevDoc[ key ];\n\n          if ( prevDocProp instanceof Document ){\n            if ( prevDocProp._id.equals( curVal ) ){\n              subdoc[ key ] = prevDocProp;\n            }\n          }\n        });\n      }\n    }\n  });\n}\n\n/*!\n * Scopes paths selected in a query to this array.\n * Necessary for proper default application of subdocument values.\n *\n * @param {DocumentArray} array - the array to scope `fields` paths\n * @param {Object|undefined} fields - the root fields selected in the query\n * @param {Boolean|undefined} init - if we are being created part of a query result\n */\nfunction scopePaths (array, fields, init) {\n  if (!(init && fields)) return undefined;\n\n  var path = array.path + '.'\n    , keys = Object.keys(fields)\n    , i = keys.length\n    , selected = {}\n    , hasKeys\n    , key;\n\n  while (i--) {\n    key = keys[i];\n    if (0 === key.indexOf(path)) {\n      hasKeys || (hasKeys = true);\n      selected[key.substring(path.length)] = fields[key];\n    }\n  }\n\n  return hasKeys && selected || undefined;\n}\n\n/*!\n * Module exports.\n */\nmodule.exports = DocumentArray;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/schema/documentarray.js\n ** module id = 34\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./lib/schema/documentarray.js?")},/*!*****************************!*\
  !*** ./lib/schema/array.js ***!
  \*****************************/
function(module,exports,__webpack_require__){eval("'use strict';\n\n/*!\n * Module dependencies.\n */\nvar SchemaType = __webpack_require__(/*! ../schematype */ 22)\n  , CastError = SchemaType.CastError\n  , Types = {\n        Boolean: __webpack_require__(/*! ./boolean */ 33)\n      , Date: __webpack_require__(/*! ./date */ 36)\n      , Number: __webpack_require__(/*! ./number */ 32)\n      , String: __webpack_require__(/*! ./string */ 31)\n      , ObjectId: __webpack_require__(/*! ./objectid */ 29)\n      , Buffer: __webpack_require__(/*! ./buffer */ 37)\n    }\n  , StorageArray = __webpack_require__(/*! ../types/array */ 27)\n  , Mixed = __webpack_require__(/*! ./mixed */ 21)\n  , utils = __webpack_require__(/*! ../utils */ 9)\n  , EmbeddedDoc;\n\n/**\n * Array SchemaType constructor\n *\n * @param {String} key\n * @param {SchemaType} cast\n * @param {Object} options\n * @inherits SchemaType\n * @api private\n */\nfunction SchemaArray (key, cast, options) {\n  if (cast) {\n    var castOptions = {};\n\n    if ('Object' === utils.getFunctionName( cast.constructor ) ) {\n      if (cast.type) {\n        // support { type: Woot }\n        castOptions = _.clone( cast ); // do not alter user arguments\n        delete castOptions.type;\n        cast = cast.type;\n      } else {\n        cast = Mixed;\n      }\n    }\n\n    // support { type: 'String' }\n    var name = 'string' === typeof cast\n      ? cast\n      : utils.getFunctionName( cast );\n\n    var Caster = name in Types\n      ? Types[name]\n      : cast;\n\n    this.casterConstructor = Caster;\n    this.caster = new Caster(null, castOptions);\n\n    // lazy load\n    EmbeddedDoc || (EmbeddedDoc = __webpack_require__(/*! ../types/embedded */ 28));\n\n    if (!(this.caster instanceof EmbeddedDoc)) {\n      this.caster.path = key;\n    }\n  }\n\n  SchemaType.call(this, key, options);\n\n  var self = this\n    , defaultArr\n    , fn;\n\n  if (this.defaultValue) {\n    defaultArr = this.defaultValue;\n    fn = 'function' === typeof defaultArr;\n  }\n\n  this.default(function(){\n    var arr = fn ? defaultArr() : defaultArr || [];\n    return new StorageArray(arr, self.path, this);\n  });\n}\n\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaArray.prototype = Object.create( SchemaType.prototype );\nSchemaArray.prototype.constructor = SchemaArray;\n\n/**\n * Check required\n *\n * @param {Array} value\n * @api private\n */\nSchemaArray.prototype.checkRequired = function (value) {\n  return !!(value && value.length);\n};\n\n/**\n * Overrides the getters application for the population special-case\n *\n * @param {Object} value\n * @param {Object} scope\n * @api private\n */\nSchemaArray.prototype.applyGetters = function (value, scope) {\n  if (this.caster.options && this.caster.options.ref) {\n    // means the object id was populated\n    return value;\n  }\n\n  return SchemaType.prototype.applyGetters.call(this, value, scope);\n};\n\n/**\n * Casts values for set().\n *\n * @param {Object} value\n * @param {Document} doc document that triggers the casting\n * @param {Boolean} init whether this is an initialization cast\n * @api private\n */\nSchemaArray.prototype.cast = function ( value, doc, init ) {\n  if (Array.isArray(value)) {\n    if (!(value.isStorageArray)) {\n      value = new StorageArray(value, this.path, doc);\n    }\n\n    if (this.caster) {\n      try {\n        for (var i = 0, l = value.length; i < l; i++) {\n          value[i] = this.caster.cast(value[i], doc, init);\n        }\n      } catch (e) {\n        // rethrow\n        throw new CastError(e.type, value, this.path);\n      }\n    }\n\n    return value;\n  } else {\n    // m-gh-2442: if we're loading this from the db and its not an array, mark\n    // the whole array as modified.\n    if (!!doc && !!init) {\n      doc.markModified(this.path);\n    }\n    return this.cast([value], doc, init);\n  }\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaArray;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/schema/array.js\n ** module id = 35\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./lib/schema/array.js?")},/*!****************************!*\
  !*** ./lib/schema/date.js ***!
  \****************************/
function(module,exports,__webpack_require__){eval("'use strict';\n\n/*!\n * Module requirements.\n */\n\nvar SchemaType = __webpack_require__(/*! ../schematype */ 22);\nvar CastError = SchemaType.CastError;\n\n/**\n * Date SchemaType constructor.\n *\n * @param {String} key\n * @param {Object} options\n * @inherits SchemaType\n * @api private\n */\n\nfunction DateSchema (key, options) {\n  SchemaType.call(this, key, options);\n}\n\n/*!\n * Inherits from SchemaType.\n */\nDateSchema.prototype = Object.create( SchemaType.prototype );\nDateSchema.prototype.constructor = DateSchema;\n\n/**\n * Required validator for date\n *\n * @api private\n */\nDateSchema.prototype.checkRequired = function (value) {\n  return value instanceof Date;\n};\n\n/**\n * Casts to date\n *\n * @param {Object} value to cast\n * @api private\n */\nDateSchema.prototype.cast = function (value) {\n  // If null or undefined\n  if (value == null || value === '')\n    return value;\n\n  if (value instanceof Date)\n    return value;\n\n  var date;\n\n  // support for timestamps\n  if (typeof value !== 'undefined') {\n    if (value instanceof Number || 'number' == typeof value\n      || String(value) == Number(value)) {\n      date = new Date(Number(value));\n    } else if (value.toString) {\n      // support for date strings\n      date = new Date(value.toString());\n    }\n\n    if (date.toString() != 'Invalid Date') {\n      return date;\n    }\n  }\n\n  throw new CastError('date', value, this.path);\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = DateSchema;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/schema/date.js\n ** module id = 36\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./lib/schema/date.js?")},/*!******************************!*\
  !*** ./lib/schema/buffer.js ***!
  \******************************/
function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';\n\n/*!\n * Module dependencies.\n */\n\nvar SchemaType = __webpack_require__(/*! ../schematype */ 22)\n  , CastError = SchemaType.CastError\n  , StorageBuffer = __webpack_require__(/*! ../types */ 38).Buffer\n  , Binary = StorageBuffer.Binary\n  , Document;\n\n/**\n * Buffer SchemaType constructor\n *\n * @param {String} key\n * @param {SchemaType} cast\n * @inherits SchemaType\n * @api private\n */\n\nfunction SchemaBuffer (key, options) {\n  SchemaType.call(this, key, options, 'Buffer');\n}\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaBuffer.prototype = Object.create( SchemaType.prototype );\nSchemaBuffer.prototype.constructor = SchemaBuffer;\n\n/**\n * Check required\n *\n * @api private\n */\n\nSchemaBuffer.prototype.checkRequired = function (value, doc) {\n  if (SchemaType._isRef(this, value, doc, true)) {\n    return null != value;\n  } else {\n    return !!(value && value.length);\n  }\n};\n\n/**\n * Casts contents\n *\n * @param {Object} value\n * @param {Document} doc document that triggers the casting\n * @param {Boolean} init\n * @api private\n */\n\nSchemaBuffer.prototype.cast = function (value, doc, init) {\n  var ret;\n\n  if (SchemaType._isRef(this, value, doc, init)) {\n    // wait! we may need to cast this to a document\n\n    if (null == value) {\n      return value;\n    }\n\n    // lazy load\n    Document || (Document = __webpack_require__(/*! ./../document */ 14));\n\n    if (value instanceof Document) {\n      value.$__.wasPopulated = true;\n      return value;\n    }\n\n    // setting a populated path\n    if (Buffer.isBuffer(value)) {\n      return value;\n    } else if (!_.isObject(value)) {\n      throw new CastError('buffer', value, this.path);\n    }\n\n    // Handle the case where user directly sets a populated\n    // path to a plain object; cast to the Model used in\n    // the population query.\n    var path = doc.$__fullPath(this.path);\n    var owner = doc.ownerDocument ? doc.ownerDocument() : doc;\n    var pop = owner.populated(path, true);\n    ret = new pop.options.model(value);\n    ret.$__.wasPopulated = true;\n    return ret;\n  }\n\n  // documents\n  if (value && value._id) {\n    value = value._id;\n  }\n\n  if (Buffer.isBuffer(value)) {\n    if (!value || !value.isStorageBuffer) {\n      value = new StorageBuffer(value, [this.path, doc]);\n    }\n\n    return value;\n  } else if (value instanceof Binary) {\n    ret = new StorageBuffer(value.value(true), [this.path, doc]);\n    if (typeof value.sub_type !== 'number') {\n      throw new CastError('buffer', value, this.path);\n    }\n    ret._subtype = value.sub_type;\n    return ret;\n  }\n\n  if (null === value) return value;\n\n  var type = typeof value;\n  if ('string' === type || 'number' === type || Array.isArray(value)) {\n    ret = new StorageBuffer(value, [this.path, doc]);\n    return ret;\n  }\n\n  throw new CastError('buffer', value, this.path);\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaBuffer;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/node-libs-browser/~/buffer/index.js */ 1).Buffer))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/schema/buffer.js\n ** module id = 37\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./lib/schema/buffer.js?")},/*!****************************!*\
  !*** ./lib/types/index.js ***!
  \****************************/
function(module,exports,__webpack_require__){eval("'use strict';\n\n/*!\n * Module exports.\n */\n\nexports.Array = __webpack_require__(/*! ./array */ 27);\nexports.Buffer = __webpack_require__(/*! ./buffer */ 39);\n\nexports.Embedded = __webpack_require__(/*! ./embedded */ 28);\n\nexports.DocumentArray = __webpack_require__(/*! ./documentarray */ 26);\nexports.ObjectId = __webpack_require__(/*! ./objectid */ 11);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/types/index.js\n ** module id = 38\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./lib/types/index.js?")},/*!*****************************!*\
  !*** ./lib/types/buffer.js ***!
  \*****************************/
function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';\n\n/*!\n * Module dependencies.\n */\n\nvar Binary = __webpack_require__(/*! ../binary */ 40);\nvar utils = __webpack_require__(/*! ../utils */ 9);\n\n/**\n * Storage Buffer constructor.\n *\n * Values always have to be passed to the constructor to initialize.\n *\n * @param {Buffer} value\n * @param {String} encode\n * @param {Number} offset\n * @api private\n * @inherits Buffer\n */\n\nfunction StorageBuffer (value, encode, offset) {\n  var length = arguments.length;\n  var val;\n\n  if (0 === length || null === arguments[0] || undefined === arguments[0]) {\n    val = 0;\n  } else {\n    val = value;\n  }\n\n  var encoding;\n  var path;\n  var doc;\n\n  if (Array.isArray(encode)) {\n    // internal casting\n    path = encode[0];\n    doc = encode[1];\n  } else {\n    encoding = encode;\n  }\n\n  var buf = new Buffer(val, encoding, offset);\n  _.mixin( buf, StorageBuffer.mixin );\n  buf.isStorageBuffer = true;\n\n  // make sure these internal props don't show up in Object.keys()\n  Object.defineProperties(buf, {\n      validators: { value: [] }\n    , _path: { value: path }\n    , _parent: { value: doc }\n  });\n\n  if (doc && 'string' === typeof path) {\n    Object.defineProperty(buf, '_schema', {\n        value: doc.schema.path(path)\n    });\n  }\n\n  buf._subtype = 0;\n  return buf;\n}\n\n/*!\n * Inherit from Buffer.\n */\n\n//StorageBuffer.prototype = new Buffer(0);\n\nStorageBuffer.mixin = {\n\n  /**\n   * Parent owner document\n   *\n   * @api private\n   * @property _parent\n   */\n\n  _parent: undefined,\n\n  /**\n   * Default subtype for the Binary representing this Buffer\n   *\n   * @api private\n   * @property _subtype\n   */\n\n  _subtype: undefined,\n\n  /**\n   * Marks this buffer as modified.\n   *\n   * @api private\n   */\n\n  _markModified: function () {\n    var parent = this._parent;\n\n    if (parent) {\n      parent.markModified(this._path);\n    }\n    return this;\n  },\n\n  /**\n   * Writes the buffer.\n   */\n\n  write: function () {\n    var written = Buffer.prototype.write.apply(this, arguments);\n\n    if (written > 0) {\n      this._markModified();\n    }\n\n    return written;\n  },\n\n  /**\n   * Copies the buffer.\n   *\n   * ####Note:\n   *\n   * `Buffer#copy` does not mark `target` as modified so you must copy from a `StorageBuffer` for it to work as expected. This is a work around since `copy` modifies the target, not this.\n   *\n   * @return {StorageBuffer}\n   * @param {Buffer} target\n   */\n\n  copy: function (target) {\n    var ret = Buffer.prototype.copy.apply(this, arguments);\n\n    if (target && target.isStorageBuffer) {\n      target._markModified();\n    }\n\n    return ret;\n  }\n};\n\n/*!\n * Compile other Buffer methods marking this buffer as modified.\n */\n\n;(\n// node < 0.5\n'writeUInt8 writeUInt16 writeUInt32 writeInt8 writeInt16 writeInt32 ' +\n'writeFloat writeDouble fill ' +\n'utf8Write binaryWrite asciiWrite set ' +\n\n// node >= 0.5\n'writeUInt16LE writeUInt16BE writeUInt32LE writeUInt32BE ' +\n'writeInt16LE writeInt16BE writeInt32LE writeInt32BE ' +\n'writeFloatLE writeFloatBE writeDoubleLE writeDoubleBE'\n).split(' ').forEach(function (method) {\n  if (!Buffer.prototype[method]) return;\n    StorageBuffer.mixin[method] = new Function(\n    'var ret = Buffer.prototype.'+method+'.apply(this, arguments);' +\n    'this._markModified();' +\n    'return ret;'\n  );\n});\n\n/**\n * Converts this buffer to its Binary type representation.\n *\n * ####SubTypes:\n *\n *   var bson = require('bson')\n *   bson.BSON_BINARY_SUBTYPE_DEFAULT\n *   bson.BSON_BINARY_SUBTYPE_FUNCTION\n *   bson.BSON_BINARY_SUBTYPE_BYTE_ARRAY\n *   bson.BSON_BINARY_SUBTYPE_UUID\n *   bson.BSON_BINARY_SUBTYPE_MD5\n *   bson.BSON_BINARY_SUBTYPE_USER_DEFINED\n *\n *   doc.buffer.toObject(bson.BSON_BINARY_SUBTYPE_USER_DEFINED);\n *\n * @see http://bsonspec.org/#/specification\n * @param {Hex} [subtype]\n * @return {Binary}\n * @api public\n */\n\nStorageBuffer.mixin.toObject = function (options) {\n  var subtype = 'number' === typeof options\n    ? options\n    : (this._subtype || 0);\n  return new Binary(this, subtype);\n};\n\n/**\n * Determines if this buffer is equals to `other` buffer\n *\n * @param {Buffer} other\n * @return {Boolean}\n */\n\nStorageBuffer.mixin.equals = function (other) {\n  if (!Buffer.isBuffer(other)) {\n    return false;\n  }\n\n  if (this.length !== other.length) {\n    return false;\n  }\n\n  for (var i = 0; i < this.length; ++i) {\n    if (this[i] !== other[i]) return false;\n  }\n\n  return true;\n};\n\n/**\n * Sets the subtype option and marks the buffer modified.\n *\n * ####SubTypes:\n *\n *   var bson = require('bson')\n *   bson.BSON_BINARY_SUBTYPE_DEFAULT\n *   bson.BSON_BINARY_SUBTYPE_FUNCTION\n *   bson.BSON_BINARY_SUBTYPE_BYTE_ARRAY\n *   bson.BSON_BINARY_SUBTYPE_UUID\n *   bson.BSON_BINARY_SUBTYPE_MD5\n *   bson.BSON_BINARY_SUBTYPE_USER_DEFINED\n *\n *   doc.buffer.subtype(bson.BSON_BINARY_SUBTYPE_UUID);\n *\n * @see http://bsonspec.org/#/specification\n * @param {Hex} subtype\n * @api public\n */\n\nStorageBuffer.mixin.subtype = function (subtype) {\n  if ('number' !== typeof subtype) {\n    throw new TypeError('Invalid subtype. Expected a number');\n  }\n\n  if (this._subtype !== subtype) {\n    this._markModified();\n  }\n\n  this._subtype = subtype;\n};\n\n/*!\n * Module exports.\n */\n\nStorageBuffer.Binary = Binary;\n\nmodule.exports = StorageBuffer;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/node-libs-browser/~/buffer/index.js */ 1).Buffer))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/types/buffer.js\n ** module id = 39\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./lib/types/buffer.js?")},/*!***********************!*\
  !*** ./lib/binary.js ***!
  \***********************/
function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';\n\n/**\n * A class representation of the BSON Binary type.\n *\n * Sub types\n *  - **BSON.BSON_BINARY_SUBTYPE_DEFAULT**, default BSON type.\n *  - **BSON.BSON_BINARY_SUBTYPE_FUNCTION**, BSON function type.\n *  - **BSON.BSON_BINARY_SUBTYPE_BYTE_ARRAY**, BSON byte array type.\n *  - **BSON.BSON_BINARY_SUBTYPE_UUID**, BSON uuid type.\n *  - **BSON.BSON_BINARY_SUBTYPE_MD5**, BSON md5 type.\n *  - **BSON.BSON_BINARY_SUBTYPE_USER_DEFINED**, BSON user defined type.\n *\n * @constructor Represents the Binary BSON type.\n * @param {Buffer} buffer a buffer object containing the binary data.\n * @param {Number} [subType] the option binary type.\n * @return {Grid}\n */\nfunction Binary(buffer, subType) {\n  if(!(this instanceof Binary)) return new Binary(buffer, subType);\n\n  this._bsontype = 'Binary';\n\n  if(buffer instanceof Number) {\n    this.sub_type = buffer;\n    this.position = 0;\n  } else {\n    this.sub_type = subType == null ? BSON_BINARY_SUBTYPE_DEFAULT : subType;\n    this.position = 0;\n  }\n\n  if(buffer != null && !(buffer instanceof Number)) {\n    // Only accept Buffer, Uint8Array or Arrays\n    if(typeof buffer === 'string') {\n      // Different ways of writing the length of the string for the different types\n      if(typeof Buffer !== 'undefined') {\n        this.buffer = new Buffer(buffer);\n      } else if(typeof Uint8Array !== 'undefined' || (Object.prototype.toString.call(buffer) === '[object Array]')) {\n        this.buffer = writeStringToArray(buffer);\n      } else {\n        throw new Error('only String, Buffer, Uint8Array or Array accepted');\n      }\n    } else {\n      this.buffer = buffer;\n    }\n    this.position = buffer.length;\n  } else {\n    if(typeof Buffer !== 'undefined') {\n      this.buffer =  new Buffer(Binary.BUFFER_SIZE);\n    } else if(typeof Uint8Array !== 'undefined'){\n      this.buffer = new Uint8Array(new ArrayBuffer(Binary.BUFFER_SIZE));\n    } else {\n      this.buffer = new Array(Binary.BUFFER_SIZE);\n    }\n    // Set position to start of buffer\n    this.position = 0;\n  }\n}\n\n/**\n * Updates this binary with byte_value.\n *\n * @param {Character} byte_value a single byte we wish to write.\n * @api public\n */\nBinary.prototype.put = function put(byte_value) {\n  // If it's a string and a has more than one character throw an error\n  if(byte_value['length'] != null && typeof byte_value != 'number' && byte_value.length != 1) throw new Error(\"only accepts single character String, Uint8Array or Array\");\n  if(typeof byte_value != 'number' && byte_value < 0 || byte_value > 255) throw new Error(\"only accepts number in a valid unsigned byte range 0-255\");\n\n  // Decode the byte value once\n  var decoded_byte = null;\n  if(typeof byte_value === 'string') {\n    decoded_byte = byte_value.charCodeAt(0);\n  } else if(byte_value['length'] != null) {\n    decoded_byte = byte_value[0];\n  } else {\n    decoded_byte = byte_value;\n  }\n\n  if(this.buffer.length > this.position) {\n    this.buffer[this.position++] = decoded_byte;\n  } else {\n    if(typeof Buffer !== 'undefined' && Buffer.isBuffer(this.buffer)) {\n      // Create additional overflow buffer\n      var buffer = new Buffer(Binary.BUFFER_SIZE + this.buffer.length);\n      // Combine the two buffers together\n      this.buffer.copy(buffer, 0, 0, this.buffer.length);\n      this.buffer = buffer;\n      this.buffer[this.position++] = decoded_byte;\n    } else {\n      var buffer = null;\n      // Create a new buffer (typed or normal array)\n      if(Object.prototype.toString.call(this.buffer) === '[object Uint8Array]') {\n        buffer = new Uint8Array(new ArrayBuffer(Binary.BUFFER_SIZE + this.buffer.length));\n      } else {\n        buffer = new Array(Binary.BUFFER_SIZE + this.buffer.length);\n      }\n\n      // We need to copy all the content to the new array\n      for(var i = 0; i < this.buffer.length; i++) {\n        buffer[i] = this.buffer[i];\n      }\n\n      // Reassign the buffer\n      this.buffer = buffer;\n      // Write the byte\n      this.buffer[this.position++] = decoded_byte;\n    }\n  }\n};\n\n/**\n * Writes a buffer or string to the binary.\n *\n * @param {Buffer|String} string a string or buffer to be written to the Binary BSON object.\n * @param {Number} offset specify the binary of where to write the content.\n * @api public\n */\nBinary.prototype.write = function write(string, offset) {\n  offset = typeof offset === 'number' ? offset : this.position;\n\n  // If the buffer is to small let's extend the buffer\n  if(this.buffer.length < offset + string.length) {\n    var buffer = null;\n    // If we are in node.js\n    if(typeof Buffer !== 'undefined' && Buffer.isBuffer(this.buffer)) {\n      buffer = new Buffer(this.buffer.length + string.length);\n      this.buffer.copy(buffer, 0, 0, this.buffer.length);\n    } else if(Object.prototype.toString.call(this.buffer) === '[object Uint8Array]') {\n      // Create a new buffer\n      buffer = new Uint8Array(new ArrayBuffer(this.buffer.length + string.length))\n      // Copy the content\n      for(var i = 0; i < this.position; i++) {\n        buffer[i] = this.buffer[i];\n      }\n    }\n\n    // Assign the new buffer\n    this.buffer = buffer;\n  }\n\n  if(typeof Buffer !== 'undefined' && Buffer.isBuffer(string) && Buffer.isBuffer(this.buffer)) {\n    string.copy(this.buffer, offset, 0, string.length);\n    this.position = (offset + string.length) > this.position ? (offset + string.length) : this.position;\n    // offset = string.length\n  } else if(typeof Buffer !== 'undefined' && typeof string === 'string' && Buffer.isBuffer(this.buffer)) {\n    this.buffer.write(string, 'binary', offset);\n    this.position = (offset + string.length) > this.position ? (offset + string.length) : this.position;\n    // offset = string.length;\n  } else if(Object.prototype.toString.call(string) === '[object Uint8Array]'\n    || Object.prototype.toString.call(string) === '[object Array]' && typeof string !== 'string') {\n    for(var i = 0; i < string.length; i++) {\n      this.buffer[offset++] = string[i];\n    }\n\n    this.position = offset > this.position ? offset : this.position;\n  } else if(typeof string === 'string') {\n    for(var i = 0; i < string.length; i++) {\n      this.buffer[offset++] = string.charCodeAt(i);\n    }\n\n    this.position = offset > this.position ? offset : this.position;\n  }\n};\n\n/**\n * Reads **length** bytes starting at **position**.\n *\n * @param {Number} position read from the given position in the Binary.\n * @param {Number} length the number of bytes to read.\n * @return {Buffer}\n * @api public\n */\nBinary.prototype.read = function read(position, length) {\n  length = length && length > 0\n    ? length\n    : this.position;\n\n  // Let's return the data based on the type we have\n  if(this.buffer['slice']) {\n    return this.buffer.slice(position, position + length);\n  } else {\n    // Create a buffer to keep the result\n    var buffer = typeof Uint8Array != 'undefined' ? new Uint8Array(new ArrayBuffer(length)) : new Array(length);\n    for(var i = 0; i < length; i++) {\n      buffer[i] = this.buffer[position++];\n    }\n  }\n  // Return the buffer\n  return buffer;\n};\n\n/**\n * Returns the value of this binary as a string.\n *\n * @return {String}\n * @api public\n */\nBinary.prototype.value = function value(asRaw) {\n  asRaw = asRaw == null ? false : asRaw;\n\n  // Optimize to serialize for the situation where the data == size of buffer\n  if(asRaw && typeof Buffer !== 'undefined' && Buffer.isBuffer(this.buffer) && this.buffer.length == this.position)\n    return this.buffer;\n\n  // If it's a node.js buffer object\n  if(typeof Buffer !== 'undefined' && Buffer.isBuffer(this.buffer)) {\n    return asRaw ? this.buffer.slice(0, this.position) : this.buffer.toString('binary', 0, this.position);\n  } else {\n    if(asRaw) {\n      // we support the slice command use it\n      if(this.buffer['slice'] != null) {\n        return this.buffer.slice(0, this.position);\n      } else {\n        // Create a new buffer to copy content to\n        var newBuffer = Object.prototype.toString.call(this.buffer) === '[object Uint8Array]' ? new Uint8Array(new ArrayBuffer(this.position)) : new Array(this.position);\n        // Copy content\n        for(var i = 0; i < this.position; i++) {\n          newBuffer[i] = this.buffer[i];\n        }\n        // Return the buffer\n        return newBuffer;\n      }\n    } else {\n      return convertArraytoUtf8BinaryString(this.buffer, 0, this.position);\n    }\n  }\n};\n\n/**\n * Length.\n *\n * @return {Number} the length of the binary.\n * @api public\n */\nBinary.prototype.length = function length() {\n  return this.position;\n};\n\n/**\n * @ignore\n * @api private\n */\nBinary.prototype.toJSON = function() {\n  return this.buffer != null ? this.buffer.toString('base64') : '';\n};\n\n/**\n * @ignore\n * @api private\n */\nBinary.prototype.toString = function(format) {\n  return this.buffer != null ? this.buffer.slice(0, this.position).toString(format) : '';\n};\n\n// Binary default subtype\nvar BSON_BINARY_SUBTYPE_DEFAULT = 0;\n\n/**\n * @ignore\n * @api private\n */\nvar writeStringToArray = function(data) {\n  // Create a buffer\n  var buffer = typeof Uint8Array !== 'undefined' ? new Uint8Array(new ArrayBuffer(data.length)) : new Array(data.length);\n  // Write the content to the buffer\n  for(var i = 0; i < data.length; i++) {\n    buffer[i] = data.charCodeAt(i);\n  }\n  // Write the string to the buffer\n  return buffer;\n};\n\n/**\n * Convert Array ot Uint8Array to Binary String\n *\n * @ignore\n * @api private\n */\nvar convertArraytoUtf8BinaryString = function(byteArray, startIndex, endIndex) {\n  var result = '';\n  for(var i = startIndex; i < endIndex; i++) {\n    result = result + String.fromCharCode(byteArray[i]);\n  }\n  return result;\n};\n\nBinary.BUFFER_SIZE = 256;\n\n/*!\n * Default BSON type\n *\n * @const SUBTYPE_DEFAULT\n **/\nBinary.SUBTYPE_DEFAULT = 0;\n\n/*!\n * Function BSON type\n *\n * @const SUBTYPE_DEFAULT\n **/\nBinary.SUBTYPE_FUNCTION = 1;\n\n/*!\n * Byte Array BSON type\n *\n * @const SUBTYPE_DEFAULT\n **/\nBinary.SUBTYPE_BYTE_ARRAY = 2;\n\n/*!\n * OLD UUID BSON type\n *\n * @const SUBTYPE_DEFAULT\n **/\nBinary.SUBTYPE_UUID_OLD = 3;\n\n/*!\n * UUID BSON type\n *\n * @const SUBTYPE_DEFAULT\n **/\nBinary.SUBTYPE_UUID = 4;\n\n/*!\n * MD5 BSON type\n *\n * @const SUBTYPE_DEFAULT\n **/\nBinary.SUBTYPE_MD5 = 5;\n\n/*!\n * User BSON type\n *\n * @const SUBTYPE_DEFAULT\n **/\nBinary.SUBTYPE_USER_DEFINED = 128;\n\n/*!\n * Module exports.\n */\nmodule.exports = Binary;\nmodule.exports.Binary = Binary;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./~/node-libs-browser/~/buffer/index.js */ 1).Buffer))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/binary.js\n ** module id = 40\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./lib/binary.js?")},/*!**************************************!*\
  !*** ./~/json-loader!./package.json ***!
  \**************************************/
function(module,exports){eval('module.exports = {\n	"name": "storage",\n	"version": "0.5.0",\n	"description": "Mongoose-like schema validation, collections and documents on browser (client-side)",\n	"author": "Constantine Melnikov <ka.melnikov@gmail.com>",\n	"license": "MIT",\n	"repository": {\n		"type": "git",\n		"url": "https://github.com/archangel-irk/storage.git"\n	},\n	"main": "dist/storage.min.js",\n	"scripts": {\n		"test": "grunt test"\n	},\n	"devDependencies": {\n		"grunt": "latest",\n		"time-grunt": "latest",\n		"grunt-contrib-jshint": "latest",\n		"grunt-karma": "latest",\n		"grunt-karma-coveralls": "latest",\n		"grunt-webpack": "latest",\n		"karma": "latest",\n		"karma-coverage": "latest",\n		"karma-mocha": "latest",\n		"karma-chai": "latest",\n		"karma-phantomjs-launcher": "latest",\n		"karma-chrome-launcher": "latest",\n		"karma-firefox-launcher": "latest",\n		"karma-ie-launcher": "latest",\n		"karma-safari-launcher": "latest",\n		"karma-sauce-launcher": "latest",\n		"karma-sourcemap-loader": "latest",\n		"karma-webpack": "latest",\n		"lodash": "2.4.1",\n		"webpack": "latest",\n		"json-loader": "latest",\n		"istanbul-instrumenter-loader": "latest",\n		"dox": "latest",\n		"highlight.js": "latest",\n		"jade": "latest",\n		"markdown": "latest"\n	}\n}\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/json-loader!./package.json\n ** module id = 41\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./package.json?./~/json-loader')}])});